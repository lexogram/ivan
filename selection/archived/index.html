<!DOCTYPE html>
<html lang=en>
<head>
<meta charset="utf-8">
<title>Text Selection</title>
<link rel="stylesheet" href="../css/core.css" />
<link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
</head>

<body>
  <div class="sidebar">
    <div class="logo">
      <a href="../"><img src="../img/logo.png" alt="openbook home" /></a>
    </div>

    <nav>
      <ol>
        <li><a href="#top">Overview</a></li>
        <li><a href="#intro">Introduction</a></li>
        <li><a href="#discover">Discovering Selections</a></li>
        <li><a href="#whole_word">Selecting whole words</a></li>
        <li><a href="#dictionary">Using a dictionary</a></li>
        <li><a href="#async">An asynchronous call</a></li>
        <li><a href="#jump">Jump to next word</a></li>
        <li><a href="#box">Limiting to one element</a></li>
        <li><a href="#end">Conclusion</a></li>
      </ol>
    </nav>

    <p class="aside support">If you have any difficulty in this tutorial, please <a href="https://github.com/lexogram/openbook/issues/new">tell us about it</a>, and we will do our best to deal with it for you.</p>
  </div>

<main>
<header>
  <a href="https://github.com/lexogram/openbook/blob/master/LICENSE" class="cc">&#59409;</a>
  <h1>Text Selection</h1>
  <ul class="nav">
    <li>
      <a href="#back"><img src="../img/arrow.png" alt="back" /></a>
    </li><li>
      <a href="#next"><img src="../img/arrow.png" alt="next" /></a>
    </li>
  </ul>
</header>

<article>
<!-- INTRODUCTION -->
<section id="intro">
  <h2>Introduction</h2>
  <p>More details to go here</p>

  <footer>
    <ul class="nav">
      <li>
        <a href="#end">
          <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- DISCOVER -->
<section id="discover">
  <h2>Discovering the <code>Selection</code> and <code>Range</code> objects</h2>
  <div class="aside preview">In this section, you'll create test HTML page in order to:
    <ul>
      <li>Learn about the <code>Selection</code> object and its properties and methods</li>
      <li>Learn about the <code>Range</code> object and its properties and methods</li>
      <li>See how text can be made unselectable</li>
      <li>Learn how to select unselectable text</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/03_discover.zip" target="source">Download the source files</a>
  </div>

  <h3>A test page</h3>
  <p>You can start by creating a simple HTML page with a little JavaScript code to show what happens behind the scenes when you select text. You can see what your page will look in Figure 1 below.</p>

  <figure>
  <img src="img/testing.png" alt="Testing a text selection across nodes" />
  <figcaption>Figure 1. Testing a text selection across nodes</figcaption>
  </figure>

  <p>There are a number of things to notice here:</p>
  <ul>
   <li>The HTML includes nodes of different types: <code>&lt;p&gt;</code>, <code>&lt;div&gt;</code>, <code>&lt;span&gt;</code> and <code>&lt;em&gt;</code> tags</li>
   <li>The text uses different writing scripts: Cyrillic, Latin and Thai. In Thai, spaces indicate the end of clauses or sentences (like <code>,</code> and <code>.</code> characters in English). In other words, spaces do not indicate the ends of words. In order to select "the word under the mouse" in Thai (and many other writing scripts) you'll have to learn a technique that doesn't depend on spaces.</li>
   <li>One span in the text is intended to be "unselectable", but when you create a selection that starts before and finishes after this span, it is included in the selection.</li>
   <li>The text of the <code>p#output</code> element at the bottom cannot be selected, to prevent an endless loop where it would try to display the contents of itself inside itself.</li>
   </ul>

   <p>To test this yourself, create a file named <code>index.html</code> in the folder of your choice, enter the HTML code shown below, and save your file.</p>

  <h4><code>index.html</code></h4>
  <pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Selection&lt;/title&gt;
  &lt;style&gt;
    .box {
      width: 80%;
      margin: 0 auto;
      border: 1px solid #ccc;
      border-top-color: #666;
      border-left-color: #666;
      background-color: #f8f8f8;
      padding: 0.5em;
    }
    span {
      color: #c00;
    }
    .unselectable {
      -webkit-touch-callout: none; /* iOS Safari */
      -webkit-user-select: none;   /* Chrome/Safari/Opera */
      -khtml-user-select: none;    /* Konqueror */
      -moz-user-select: none;      /* Firefox */
      -ms-user-select: none;       /* Internet Explorer/Edge */
      user-select: none;  
      color: #999;
    }
  }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;p lang="ru"&gt;Вим ед путант альбюкиюс прёнкипыз, квюо
  эи выльёт аэтырно бландит, видэ фабыллас майыжтатйж прё экз.&lt;/p&gt;

  &lt;div class="box" lang="la"&gt;
    &lt;span&gt;Lorem ipsum dolor sit amet, consectetur adipiscing
    elit.&lt;/span&gt;
    In nunc ipsum, tristique in convallis non, ultrices sed eros.
    &lt;span class="unselectable"&gt;This span has
    &lt;em&gt;user-select: none;&lt;/em&gt; applied to it.&lt;/span&gt;
    &lt;span&gt;Integer eu dignissim justo, eu facilisis est.&lt;/span&gt;
  &lt;/div&gt;

  &lt;p lang="th"&gt;คนึงครวญคร่ำถวิลกินระกำ ระกำกินถวิลคร่ำครวญคนึง&lt;/p&gt;

  &lt;p id="output" class="unselectable"&gt;&lt;/p&gt;

  &lt;script src="js/selection.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

  <p>Now you can create a folder named <code>js</code> alongside your <code>index.html</code> file, create a file named <code>selection.js</code> inside this new folder, enter the JavaScript code as shown below, and save your file. The methods and properties of the <code>Selection</code> and <code>Range</code> objects are shown in red.</p>

  <h4><code>js/selection.js</code></h4>
  <pre>"use strict"

;(function selection(){
  var pOutput = document.getElementById("output")
  var selection = <span class="red">window.getSelection()</span>

  ;(function showSelection(){
    var output = "rangeCount: " + <span class="red">selection.rangeCount</span>
    var range
    var text

    if (<span class="red">selection.anchorNode</span>) {
      text = '"' + selection.anchorNode.textContent + '"'
      output += "&lt;br /&gt;anchorNode: " + text

      output += "&lt;br /&gt;anchorOffset: " + <span class="red">selection.anchorOffset</span>

      text = '"' + <span class="red">selection.focusNode</span>.textContent + '"'
      output += "&lt;br /&gt;focusNode: " + text

      output += "&lt;br /&gt;focusOffset: " + <span class="red">selection.focusOffset</span>
    }

    if (selection.rangeCount) {
      range = <span class="red">selection.getRangeAt(0)</span>

      text =  '"' + <span class="red">range.startContainer</span>.textContent + '"'
      output += "&lt;br /&gt;range.startContainer: " + text

      output += "&lt;br /&gt;range.startOffset: " + <span class="red">range.startOffset</span>

      text =  '"' + <span class="red">range.endContainer</span>.textContent + '"'
      output += "&lt;br /&gt;range.endContainer: " + text

      output += "&lt;br /&gt;range.endOffset: " + <span class="red">range.endOffset</span>

      text = '"' + <span class="red">range.toString()</span> + '"'
      output += "&lt;br /&gt;range.toString(): " + text
    }

    text = '"' + <span class="red">selection.toString()</span> + '"'
    output += "&lt;br /&gt;selection.toString(): " + text

    pOutput.innerHTML = output

    setTimeout(showSelection, 250)
  })()
})()</pre>

  <p class="aside info">You can test a working version <a href="source/03_discover/">here</a>.</p>

  <h3><code>window.getSelection()</code></h3>
  <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection"><code>getSelection()</code></a> method is global: you don't actually need to use <code>window.</code> before you use it. This command returns a live <code>Selection</code> object. The values stored in the <code>Selection</code> object update in real time as you drag the mouse to change your selection.</p>

  <h3>The <code>Selection</code> object</h3>
  <p>You can see all the properties of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection"><code>Selection</code></a> object by typing the command <code>getSelection()</code> in the Developer Tools' Console window:</p>

  <figure>
  <img src="img/getSelection.png" alt="Displaying the properties of the Selection object in the Console" />
  <figcaption>Figure 2. Displaying the properties of the Selection object in the Console</figcaption>
  </figure>

  <p>The <code>isCollapsed</code> property indicates if a selection is visible or not. It will be <code>true</code> if there is no current selection. If the one or more characters are selected, like <span class="select">this</span>, then <code>isCollapsed</code> will be <code>false</code>.</p>

  <p class="aside note">The <code>baseNode</code>, <code>baseOffset</code>, <code>extendNode</code> and <code>extendOffset</code> properties may not be present in your browser. In Chrome, they are aliases for the <code>anchor...</code> and <code>focus...</code> properties. The <code>type</code> property is also non-standard. In Webkit browsers, if <code>isCollapsed</code> is true, it can take the values "None" (before any selection is made), "Caret" (if there is no current visible selection); if <code>isCollapsed</code> is false, it will take the value "Range".</p>

  <h3><code>showSelection</code></h3>
  <p>The custom <code>showSelection</code> calls itself every 250 milliseconds, in order to update the contents of the <code>p#output</code> element in real time, as you modify the selection. Click somewhere on the page and drag the mouse, to see feedback from the <code>Selection</code> object.</p>

  <h3><code>anchorNode</code> and <code>focusNode</code></h3>
  <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/anchorNode"><code>anchorNode</code></a> is a pointer to the HTML node where you click the mouse to start your selection. The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/focusNode"><code>focusNode</code></a> is a pointer to the HTML element under the mouse while you are dragging. This may be the same as <code>anchorNode</code>.</p>
  <p class="aside note">In the <code>p#output</code> element, it's the <code>textContent</code> property of these nodes that is shown, not the HTML node object itself.</p>

  <h3>Unselectable text</h3>
  <p>You can apply a CSS rule to any HTML element to make its contents unselectable. The <code>.unselectable</code> class has this rule, which copes with most browsers in existence.</p>
<pre>.unselectable {
  -webkit-touch-callout: none; /* iOS Safari */
  -webkit-user-select: none;   /* Chrome/Safari/Opera */
  -khtml-user-select: none;    /* Konqueror */
  -moz-user-select: none;      /* Firefox */
  -ms-user-select: none;       /* Internet Explorer/Edge */
  user-select: none;  
}</pre>
  <p>If you're targetting recent browsers (from IE10 and later) then you can probably get away with just using:</p>
<pre>.unselectable {
  user-select: none;  
}</pre>
  <p>This class is applied to the sentence that says "<span class="aaa">This span has <em>user-select: none</em> applied to it,</span>". Note what happens if you click on this sentence and drag the mouse upwards or downwards.</p>
  <dl>
    <dt>Click on <span class="aaa"><em>none</em></span> and drag up:</dt>
    <dd>The <code>anchorNode</code> will be the one containing "<span class="aaa"> applied to it</span>", not the <code>&lt;em&gt;</code> element that you initially clicked on. The <code>focusNode</code> will be the HTML node under the mouse.</dd>
    <dt>Click on <span class="aaa"><em>none</em></span> and drag down:</dt>
    <dd>The <code>anchorNode</code> will be the <code>textNode</code> containing the space between "<span class="aaa">it.</span>" and "Integer". In other words: the first selectable node that follows the unselectable node.</dd>
    <dt>Click on <span class="aaa"><em>none</em></span> and drag over the unselectable phrase:</dt>
    <dd>Both the <code>anchorNode</code> and the <code>focusNode</code> will be the <code>textNode</code> containing the space following the unselectable node.</dd>
  </dl>

  <h3>The <code>Range</code> object</h3>
  <p>The <code>Range</code> object is now the official way to deal with multiple arbitrary chunks of an HTML page.</p>
  <p class="aside warn">Older browsers may not support the <code>Range</code> object. If you need to support older browsers then you might prefer to abandon this tutorial and start <a href="http://www.quirksmode.org/dom/range_intro.html">exploring on your own</a>.</p>

  <p>Before you click on a freshly loaded page, the <code>Selection</code> object will contain no <code>Range</code> objects, and the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/rangeCount"><code>selection.rangeCount</code></a> will return 0. When you click the first time, a <code>Range</code> object will be created, and <code>selection.rangeCount</code> will become <code>1</code>, even if no selection is visible.</p>
  <p class="aside note">It's thus important to check whether <code>selection.rangeCount</code> is greater than zero before using <code>var range = selection.<a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/getRangeAt">getRangeAt(0)</a></code> to obtain the <code>Range</code> object. Using an invalid index for the <code>.getRangeAt(...)</code> call will provoke an error.</p>
  <p>By default, the <code>Selection</code> object normally only contains a single <code>Range</code>. However, as you will see, you can use JavaScript to add other ranges to the user-created selection.</p>

  <h3>The <code>toString()</code> method</h3>
  <p>Both the <code>Selection</code> object and the <code>Range</code> object have a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/toString"><code>toString()</code></a> method which returns the text content of the selected chunk referred to by the object. When a selection has only one range, then both will return exactly the same string.</p>
  <p>Note that you can include "unselectable" text in a selection, by sandwiching the unselectable text with text from selectable nodes.</p>
  <dl>
    <dt>Click on the first word in the box (Lorem) and drag to the last word in the box (est)</dt>
    <dd>The <code>anchorNode</code> and <code>focusNode</code> will be what you should expect, but the values returned by <code>.toString()</code> will include the unselectable text.</dd>
    
  </dl>

  <h3>The <code>startContainer</code> and <code>endContainer</code> properties</h3>
  <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Range/startContainer"><code>startContainer</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Range/endContainer"><code>endContainer</code></a> properties of a range are similar to the <code>anchorNode</code> and <code>focusNode</code> properties of the <code>Selection</code> object, except they are always set in the order in which the text appears in the source HTML.</p>
  <dl>
    <dt>Click on the last word in the box (est) and drag to the last word in the box (Lorem)</dt>
    <dd>This time, you are starting at the end and dragging backwards: the <code>range.startContainer</code> will contain a pointer to the earlier <code>focusNode</code> and the <code>range.endContainer</code> will contain a pointer to the later <code>anchorNode</code>. This means that you can be sure of the order of the words on the page in your selection.</dd>
  </dl>

  <h3>The <code>...Offset</code> properties</h3>
  <p>The <code>anchorNode</code>, <code>focusNode</code>, <code>startContainer</code> and <code>endContainer</code> properties all have their associated <code>...Offset</code> proprties, which indicate where the boundary between non-selection and selection occurs in the particular HTML node. Below, you'll find links where you can read about these in furthur detail:</p>
  <ul>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/anchorOffset">anchorOffset</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/focusOffset">focusOffset</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Range/startOffset">startOffset</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Range/endOffset">endOffset</a></li>
  </ul>
  <p>You'll get a chance to work with these properties in the coming sections.</p>
  
  <h3>Putting it all together</h3>
  <p>Imagine the following HTML:</p>
<pre>&lt;blockquote&gt;&lt;p&gt;I have called this principle &lt;span&gt;...&lt;/span&gt; 
Natural Selection.&lt;/p&gt;
&lt;footer&gt;Charles Darwin&lt;/footer&gt;&lt;/blockquote&gt;</pre>
  <p>Imagine that you click between the "D" and the "a" of "Darwin" and drag your mouse upwards and release it between the two "ll"s of "called", to make the selection shown below:</p>
  <figure>
  <img src="img/natural.png" alt="The properties of a Selection" />
  <figcaption>Figure 3. The properties of a Selection</figcaption>
  </figure>
  <p>Here are the values that you will obtain:</p>
  <ul>
  <li><code>anchorNode.textContent</code>: "Charles Darwin"</li>
  <li><code>anchorNode</code>: 9</li>
  <li><code>focusNode.textContent</code>: "I have called this principle"</li>
  <li><code>focusOffset</code>: 11</li>
  </ul>
  <ul>
  <li><code><span class="ymmv">range</span>.startContainer.textContent</code>: "I have called this principle"</li>
  <li><code><span class="ymmv">range</span>.startOffset</code>: 11</li>
  <li><code><span class="ymmv">range</span>.endContainer.textContent:</code> "Charles Darwin"</li>
  <li><code><span class="ymmv">range</span>.endOffset</code>: 9</li>
  </ul>

  <div class="aside next">In this section, you've seen the basics about how text selections are treated in JavaScript.
    <ul>
      <li>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection">Selection</a> object
        <ul>
          <li><span class="ymmv">window.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection">getSelection()</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/anchorNode">anchorNode</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/anchorOffset">anchorOffset</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/focusNode">focusNode</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/focusOffset">focusOffset</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/rangeCount">rangeCount</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/getRangeAt">getRangeAt()</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/toString">toString()</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/isCollapsed">isCollapsed</a></li>
        </ul>
      </li>
      <li>The <a href="">Range</a> object
        <ul>
          <li><span class="ymmv">range.</span><a href="">startContainer</a></li>
          <li><span class="ymmv">range.</span><a href="">startOffset</a></li>
          <li><span class="ymmv">range.</span><a href="">endContainer</a></li>
          <li><span class="ymmv">range.</span><a href="">endContainer</a></li>
          <li><span class="ymmv">range.</span><a href="">endOffset</a></li>
          <li><span class="ymmv">range.</span><a href="">toString()</a></li>
        </ul>
      </li>
      <li>How a text selection is expressed in terms of its start and end points.</li>

    </ul>
    <p>In the <a href="#whole_word">next section</a>, you'll see how to extend a selection so that a single click can be used to select a whole word.</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#whole_word">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- WHOLE WORD -->
<section id="whole_word">
  <h2>Selecting the whole word</h2>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Ensure that when you make a selection, only complete words are selected</li>
      <li>Modify the selection by manipulating the <code>Range</code> object and its <code>startOffset</code> and <code>endOffset</code> properties.</li>
      <li>Use a regular expression to detect word boundaries</li>
      <li>Search backwards with a regular expression</li>
      <li>Refine the regular expression to exclude unwanted punctuation</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/CHANGE_MY_NAME.zip" target="source">Download the source files</a>
  </div>

  <h3>Setting the start and end points of a selection</h3>
  <p>By default, a click on a browser page will create an anchor point for a selection; if you drag the mouse, you can extend the selection forwards or backwards form the anchor point. With this default technique, selecting a whole word requires a composite precision action. If your interface is designed for selecting whole words, you can convert a click into a 'whole word selection' action and save your users time and reduce their risk of carpal tunnel syndrome.</p>
  <p>The trick is to extend the current selection backwards to the preceding word boundary and forwards to the next word boundary. This poses two questions:</p>
  <ul>
  <li>How do you define a word boundary?</li>
  <li>How do you extend a selection?</li>
  </ul>

  <p>Finding word boundaries with Regular Expressions</p>
  <p>Regular Expressions are designed to let you search for a particular pattern in a string of text. If you're not familiar with Regular Expressions, you might like to work through a <a href="http://regexone.com/">beginner's tutorial</a> so that the explanations below make more sense to you.</p>
  <p>You can start with a very simple pattern that will be a good approximation for a word boundary: <code>/\s/g</code>. This means: any space, anywhere in your text. You can refine this later, to exclude unwanted punctuation, but it will do for now.</p>

  <h3>Modifying a <code>Range</code></h3>
  <p>As soon as you click on a web page, the window's <code>Selection</code> object will possess a <code>Range</code> object. You can manipulate the <code>startOffset</code> of the Range's <code>startContainer</code> and the <code>endOffset</code> of its <code>endContainer</code>, to move them out to nearest word boundaries, but simply modifying the <code>Range</code> object will not be enough to change the visible selection on the page: you will also have to remove the <code>Range</code> object from the <code>Selection</code> and then add it back again, so that the <code>Selection</code> object becomes aware that it has changed.</p>
  <p>Below, you'll find new code to add to your <code>js/selection.js</code> file:</p>

  <h4><code>js/selection.js</code></h4>
  <pre class="revised">"use strict"

;(function selection(){
  var pOutput = document.getElementById("output")
  var selection = window.getSelection()
  <span class="new">var regex = /\s/g</span>

  ;(function showSelection(){
    <span class="omit">// code omitted for clarity</span>
  })()

  <span class="new">document.body.onmouseup = selectWholeWords

  function selectWholeWords(event) {
    if (event.detail === 3) {
      <span class="comment">// Let triple-clicks take control of the selection</span>
      return
    }

    if (selection.rangeCount) {
      var range = selection.getRangeAt(0)
      
      var container = range.startContainer
      var string = container.textContent 
      var offset = searchBackwards(
        string
      , range.startOffset
      , regex
      )
      <span class="red">range.setStart</span>(container, offset)

      container = range.endContainer
      string = container.textContent
      offset = range.endOffset
      offset += <span class="red">string</span>.substring(offset)<span class="red">.search</span>(regex)
      <span class="red">range.setEnd</span>(container, offset)

      <span class="red">selection.removeAllRanges</span>()
      <span class="red">selection.addRange</span>(range)
    }

    function searchBackwards(string, offset, regex) {
      var adjust = 0
      var result
      string = string.substring(0, offset)

      while (result = <span class="red">regex.exec</span>(string)) {
        offset = <span class="red">result.index</span>
        adjust = <span class="red">result[0].length</span>
      }

      return adjust ? offset + adjust : 0
    }
  }</span>
})()</pre>

  <h3>Searching with a Regular Expression</h3>
  <p>Regular Expressions are designed to start at the beginning of a string and work forward. It is therefore much easier to find the first space <em>after</em> the end of current selection than to find the last space before the selection begins.</p>
  <p>The <code>string.search(regex)</code> method of strings returns the position where the Regular Expression pattern is first found in the string. If you start searching from the <code>endOffset</code> point, you will find how many characters you need to move to get to the first following space.</p>
  <pre>      container = range.endContainer
      string = container.textContent
      offset = range.endOffset
      offset += string.substring(offset).search(regex)
      range.setEnd(container, offset)</pre>

  <h3>Searching backwards</h3>
  <p>To search backwards using an ordinary string as the search term, you can use <code><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf">lastIndexOf()</a></code> string method. However, if your search term is a regular expression, you need to be use a more roundabout technique. One efficient technique is to find all the occurrence of the pattern, and then choose the last one:</p>

<pre>function searchBackwards(string, offset, regex) {
  var adjust = 0
  var result
  string = string.substring(0, offset)

  while (result = regex.exec(string)) {
    offset = result.index
    adjust = result[0].length
  }

  return adjust ? offset + adjust : 0
}</pre>

  <h3><code><span class="ymmv">regex.</span>exec</code></h3>
  <p>The <code>exec</code> method of regular expressions looks for the next match for the regular expression pattern in the string. If there is a match, it returns an array that has two special properties: <code>index</code> and <code>input</code>. The first item in the array is the string of matched characters, while the <code>index</code> property gives the position of the beginning of the match. You can calculate the position of the end of the match, <code>result.index + result[0].length</code>.</p>

  <p>If there is no match for the regular expression pattern, the value of <code>adjust</code> will still be <code>0</code> and this function will return this zero, indicating the beginning of the string. If there is a match, then in the last line, <code>offset</code> and <code>adjust</code> will hold the values for the last match found: their sum will give the position of the end of the match.</p>

  <p class="aside warn">It's easy to create a regular expression that matches everywhere, in which case the <code>while</code> statement will never stop being <code>true</code>, and the browser will freeze. This shouldn't happen with the regular expressions used in this tutorial.</p>

  <h3>Testing</h3>
  <p>You can save the changes that you have made to <code>selection.js</code> and relaunch the page in your browser. Try clicking on words and on blank spaces between words, to see what happens.</p>

  <figure>
  <img src="img/spaces.png" alt="Punctuation may be selected along with words when spaces are used as word boundaries" />
  <figcaption>Figure 4. Punctuation may be selected along with words when spaces are used as word boundaries</figcaption>
  </figure>

  <p>As you can see in Figure 4 above, this solution is not yet perfect. Punctuation is selected along with words, and the last word in an HTML element may not be selected in full, because it is not followed by a space.</p>

  <p class="aside note">In many browsers, a triple-click will select an entire HTML element, before the <code>selectWholeWords</code> function is called. Rather than fight this, the code above uses <code>if (event.<a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail">detail</a> === 3) { return }</code> so that it doesn't interfere with the browser's intentions.</p>

  <h3>Revising the word boundary regular expression</h3>
  <p>In English, both hyphens and apostrophes may appear in the middle of a word such as in the name of the plant "mother-in-law's tongue". However the same symbol that is used for an apostrophe may be used as a single quotation mark, which is not a part of a word. An intermediate case may occur when an apostrophe indicating possession appears at the end of a word, such as in the expression "the twins' beds".</p>
  <p>Creating a regular expression that deals rigourously with all these cases is quite complex. Each language may require a different set of patterns. If you ignore the case of the trailing apostrophe in "twins'" for now, you can consider that:</p>
  <ul>
  <li>If a hyphen or apostrophe appear with another non-word character, then the hyphen or an apostrophe should be considered a word boundary</li>
  <li>If the hyphen or apostrophe appear with a letter character on either side, they should be considered a part of the word</li>
  <li>If any other non-word character appears between two letter characters, it should be considered a word boundary</li>
  <li>The first and last character in a string are word boundaries.</li>
  </ul>

  <p>You can make the following change to your <code>selection.js</code> script. Note that this uses a different regular expression for finding the start of the word than for finding the end. The details of the <code>regex</code> are described below.</p>
<pre><span  class="revised">"use strict"

;(function selection(){
  var pOutput = document.getElementById("output")
  var selection = window.getSelection()</span>
  // RegExp to detect word boundaries but to allow ' and - in
  // the middle of words
  // 1. Match a whole range of non-word characters pairs possibly 
  //    including a ' or a - (found in the range !-/)
  var regex = <span class="new">"[\\s!-@\\[-`\\{-~]{2,}"</span>
  // 2. Match a whole range of non-word characters, excluding ' 
  //    and -, on their own
  <span class="new">regex += "|[\\s!-&amp;\\(-,.-@\\[-`\\{-~]"</span>

  // 3a. Match sequence of single-quotes or hyphens at start
  <span class="new">var startRegex = new RegExp("^['-]+|" + regex, "g")</span>
  // 3b. Match end of string if there is no other boundary first;
  //     ignore trailing apostrophe/quote marks
  <span class="new">var endRegex = new RegExp(regex + "|['-]*$")</span>

  <span class="revised">;(function showSelection(){
    <span class="omit">// code omitted for clarity</span>
  })()

  document.body.onmouseup = selectWholeWords

  function selectWholeWords(event) {
    if (event.detail === 3) {
      <span class="comment">// Let triple-clicks take control of the selection</span>
      return
    }

    if (selection.rangeCount) {
      var range = selection.getRangeAt(0)

      var container = range.startContainer
      var string = container.textContent 
      var offset = searchBackwards( 
        string
      , range.startOffset
      , </span><span class="new">startRegex</span><span class="revised">
      )
      range.setStart(container, offset)     

      container = range.endContainer
      string = container.textContent
      offset = range.endOffset
      offset += string.substring(offset).search</span>(</span><span class="new">endRegex</span><span class="revised">)
      range.setEnd(container, offset)

      selection.removeAllRanges()
      selection.addRange(range)
    }

    function searchBackwards(string, offset, regex) {
      <span class="omit">// code omitted for clarity</span>
    }
  }
})()</span></pre>

  <h3>Explaining the <code>regex</code></h3>
  <p>In JavaScript, a regular expression can be created in two ways:
  </p>
  <ul>
  <li><code>/regular expression/</code></li>
  <li><code>new RegExp("regular expression")</code></li>
  </ul>
  <p>When the <code>new RegExp()</code> constructor is used, any <code>\</code> backslash characters needed to be escaped with another <code>\</code> backslash character. In other words <code>new RegExp("[\\s!-@\\[-`\\{-~]{2,}")</code> will create a regular expression that looks like this: <code>/[\s!-@\[-`\{-~]{2,}/</code></p>
  <p>This means:</p>
  <dl>
    <dt><code>[<span class="ymmv">...</span>]</code></dt>
    <dd>Any one of the characters described within the square brackets. As you will see, these are all the printable characters with a <code>charCode</code> less than 128, which are neither uppercase or lowercase letters: all the non-word characters for English.</dd>
    <dt><code>\s</code></dt>
    <dd>A white-space character such as a space, a non-breaking space, a tab, a carriage return or a line-feed character</dd>
    <dt><code>!-/</code></dt>
    <dd>Any character between <code>!</code> and <code>/</code> in their order in the <a href="">ascii</a> table. To be exact, the characters <code>! " # $ % &amp; <span class="red">'</span> ( ) * + , <span class="red">-</span> . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @</code>. Notice that this includes the characters <code>'</code> and <code>-</code> that create a special case.</dd>
    <dt><code>\[-`</code></dt>
    <dd>All the characters between <code>[</code> and <code>`</code> inclusive. Note that <code>[</code> has a special meaning in regular expressions, so it needs to be escaped with a <code>\</code> backslash character</dd>
    <dt><code>\{-~</code></dt>
    <dd>All the characters between <code>{</code> and <code>~</code> inclusive. Note that <code>[</code> has a special meaning in regular expressions, so it needs to be escaped with a <code>\</code> backslash character</dd>
    <dt>{2,}</dt>
    <dd>Two or more of the characters described in the preceding <code>[<span class="ymmv">...</span>]</code></dd>
  </dl>
  <p>In other words, if a <code>'</code> and <code>-</code> character appears beside another non-word character, it will be considered a word boundary.</p>
  <p>In between each of these sections of non-word characters, the ascii table has sections for:</p>
  <ul>
  <li>A-Z (between <code>@</code> and <code>[</code>)</li>
  <li>a-z (between <code>{</code> and <code>~</code>)</li>
  </ul>
  <p>The second section of the <code>regex</code> starts with the <code>|</code> character, which means OR. There are two differences between what follows and the part you have already seen:</p>
  <ul>
  <li>The <code>'</code> and <code>-</code> characters are excluded</li>
  <li>Only one of any of the other characters is needed to create a word boundary</li>
  </ul>
  <p>In other words, the second part of the <code>regex</code> considers all non-word characters on their own <em>except</em> <code>'</code> and <code>-</code> as word boundaries.</p>

  <h3><code>startRegex</code> and <code>endRegex</code></h3>
  <p>The first character of an HTML node may be an opening single quote, or possibly a hyphen, to indicate a list. If these initial characters were included in <code>endRegex</code>, then a click on an apostrophe or a hyphen in the middle of a word would prevent that character and the remainder of the word from being chosen. The <code>startRegex</code> needs to be applied multiple times, in order to find the last occurrence, so the <code>g</code> global flag is required.</p>
  <p>The last character in an HTML element may be a closing single quote, not followed by any other non-word character. The word might also end with no punctuation to follow it, so the <code>$</code> end of string character is also considered a word boundary. If this were included in <code>startRegex</code> then  a click on an apostrophe or a hyphen in the middle of a word would prevent that character and the beginning of the word from being chosen.</p>

  <h3>Testing the refined regular expression</h3>
  <p>You can now test whether the new regular expression will correctly detect punctuation and words at the end of an element, as well as embedded hyphens and apostrophes. You might like to add a (rather contrived) sentence to your test page, so thet you can check that everything is working as expected.</p>

  <h4><code>index.html</code></h4>
  <pre class="revised">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  <span class="omit">// HTML omitted for clarity</span>
&lt;/head&gt;

&lt;body&gt;
  <span class="omit">// HTML omitted for clarity</span>

  &lt;p lang="th"&gt;คนึงครวญคร่ำถวิลกินระกำ ระกำกินถวิลคร่ำครวญคนึง&lt;/p&gt;

  <span class="new">&lt;p&gt;'Created 2016-08-14:' This'll let you -see- how - the
  word-detection 'works'&lt;/p&gt;</span>

  &lt;p id="output" class="unselectable"&gt;&lt;/p&gt;

  &lt;script src="js/selection.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

  <p>This word detection technique works with English, Latin and Russian, and indeed all the languages that use spaces and standard English-style punctuation. For the Thai text, however, it selects an entire sentence rather than a single word.</p>

  <figure>
  <img src="img/boundaries.png" alt="Words with embedded hyphens and apostrophes are selected whole" />
  <figcaption>Figure 5. Words with embedded hyphens and apostrophes are selected whole</figcaption>
  </figure>

  <p class="aside info">You can test a working version <a href="source/04_whole_word/">here</a>.</p>

  <div class="aside next">In this section, you've:
    <ul>
      <li>Seen how to use a regular expression to define word boundaries for English. </li>
      <li>Manipulated a <code>Range</code> object to modify the current selection</li>
    </ul>
    <p>In particular you have seen:</p>
    <ul>
    <li><code>Selection</code> object
      <ul>
        <li><code><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/removeAllRanges">removeAllRanges</a></code></li>
        <li><code><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/addRange">addRange</a></code></li>
      </ul>
    </li>
    <li><code>Range</code> object
      <ul>
        <li><code><span class="ymmv">range.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Range/setStart">setStart</a></code></li>
        <li><code><span class="ymmv">range.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Range/setEnd">setEnd</a></code></li>
      </ul>
    </li>
    <li><code>RegExp</code> object
      <ul>
        <li><code><span class="ymmv">regex.</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec">exec</a>(string)</code></li>
        <li><code><span class="ymmv">string.</span><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/search">search</a>(regex)</code></li>
      </ul>
    </li>
    </ul>
    <p>One standard technique for finding whole words in Chinese, Japanese, Thai or Khmer is to use a word dictionary. You'll see how to do that using a mini Thai dictionary in the <a href="#dictionary">next section</a>.</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#end">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- DICTIONARY -->
<section id="dictionary">
  <h2>Using a dictionary to find word boundaries</h2>
  <p>Not all languages use spaces to separate words. Chinese, Japanese, Thai and Khmer, for instance, use the internal structure of the language to indicate where word boundaries are. The computer algorithms for detecting these boundaries are complex, because they cannot take into account the meaning of the words. Where, for example, would you put the word boundaries in the domain name "speedofart.com"?</p>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Use a simple dictionary approach to identify words</li>
      <li>Identify situations where the dictionary approach fails</li>
      <li>Practise word detection on a string in English withnospaces</li>
      <li>Add word detection to the Thai sentences on your test page</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/05_dictionary.zip" target="source">Download the source files</a>
  </div>

  <p class="aside tip">If you are not concerned about supporting languages that use non-European writing scripts, you can skip this section.</p>

  <h3>Creating a dictionary</h3>
  <p>The Thai sentences that you have seen so far can be translated as</p>
  <blockquote>lookforaneedleinthesea talkisworthtuppence silenceisworthgold exposedtotheair roundeye</blockquote>
  <p>The last two Thai expressions look identical: ตากลม can be broken up as ตาก ลม (exposedto air) or ตา กลม (eye round). (You might be familiar with the <a href="https://www.youtube.com/watch?v=Cz2-ukrd2VQ">"Four Candles" sketch</a> by the Two Ronnies that plays on just this kind of ambiguity.)</p>
  <<p>Before getting you to work with Thai (where perhaps the character shapes have no meaning to you), you can create a simulation of Thai, using the sentences of runtogetherwords in English above.</p>
  <p>To keep the code for selecting words separate from the language in which they are selected, you can create a new script called <code>dictionaries.js</code> and save it in your <code>js/</code> folder:</p>

<pre>"use strict"

var dico = {}

;(function addDictionaries() {
  dico = {

    dictionaries: {
      enx: {
        " ": 0
      , "a": 0
      , "air": 0
      , "exposed": 0
      , "eye": 0
      , "for": 0
      , "forane": 0 <span class="comment">// nonsense word for testing</span>
      , "gold": 0
      , "in": 0
      , "is": 0
      , "need": 0
      , "needle": 0
      , "or": 0
      , "pence": 0
      , "sea": 0
      , "look": 0
      , "round": 0
      , "silence": 0
      , "talk": 0
      , "the": 0
      , "these": 0
      , "to": 0
      , "tup": 0
      , "tuppence": 0
      , "up": 0
      , "worth": 0
      }
    }

  , tries: {}

  , initialize: function createTries(){
      for (var languageCode in this.dictionaries) {
        this.tries[languageCode] = 
          this.createTrie(this.dictionaries[languageCode])
      }

      return this
    }

  , createTrie: function createTrie(languageMap) {
      var trie = {}
      var end = "$"
      var word
        , ii
        , length
        , last
        , chars
        , char
        , path
        , place


      for (word in languageMap) {
        chars = word.split("")
        path = trie
   
        for (ii = 0, length = word.length, last = length - 1;
          ii < length; ii += 1 ) {

          char = chars[ii]
          place = path[char]
   
          if (!place) {
            place = {}
            path[char] = place
          }
          path = place
        }
        path[end] = true
      }

      return trie
    }
  }.initialize()
})()

console.log(JSON.stringify(dico.tries.enx))</pre>

  <p>This code does two main things:</p>
  <ul>
  <li>It creates a dictionary object that includes all the English words that appear somewhere in the runtogetherstrings. For testing purposes, this uses the non-standard language code <code>enx</code>.</li>
  <li>It uses this dictionary to create a <a href="https://en.wikipedia.org/wiki/Trie">trie</a> of all these words.</li>
  </ul>
  <p>For your viewing pleasure, the trie is printed out into the console, where it will look something like this:</p>

<pre>{" ":{"$":true}
,"a":{"$":true
     ,"i":{"r":{"$":true}}}
,"e":{"x":{"p":{"o":{"s":{"e":{"d":{"$":true}}}}}}
     ,"y":{"e":{"$":true}}}
,"f":{"o":{"r":{"$":true}}}
,"g":{"o":{"l":{"d":{"$":true}}}}
,"i":{"n":{"$":true}
     ,"s":{"$":true}}
,<span class="red">"n":{"e":{"e":{"d"</span>:{"$":true,<span class="red">"l":{"e"</span>:{"$":true}}}}}}
,"o":{"r":{"$":true}}
,"p":{"e":{"n":{"c":{"e":{"$":true}}}}}
,"s":{"e":{"a":{"$":true}}
     ,"i":{"l":{"e":{"n":{"c":{"e":{"$":true}}}}}}}
,"l":{"o":{"o":{"k":{"$":true}}}}
,"r":{"o":{"u":{"n":{"d":{"$":true}}}}}
,<span class="red">"t"</span>:{"a":{"l":{"k":{"$":true}}}
     ,"h":{"e":{"$":true
               ,"s":{"e":{"$":true}}}}
     ,"o":{"$":true}
     ,<span class="red">"u":{"p"</span>:{"$":true
               ,<span class="red">"p":{"e":{"n":{"c":{"e"</span>:{"$":true}}}}}}}}
,"u":{"p":{"$":true}}
,"w":{"o":{"r":{"t":{"h":{"$":true}}}}}}</pre>
<figcaption>Figure 6: A slightly prettified rendering of the Console log of the trie of English words</figcaption>

  <h3>The leaves on a trie</h3>
  <p>The word "trie" in French means "sort, filter". In computing, a trie is an efficient way of story words for operations like auto-complete. As you can see in Figure 6 above, words that start with the same string of letters, like "need" and "needles", or "talk" and "tuppence" are stored in a series of nested object maps. Each character is the key to a sub-map, except for the character "$" whose property is always <code>true</code>. Tunneling down into the trie, following an arbitrary path will always end with an entry of <code>{"$":true}</code>, indicating the end of a word.</p>
  <p class="aside note">The dictionary also contains an entry for <code>" "</code>, as there may be spaces in the text. In a production setting, you would want to include all the possible non-word characters, but for this demonstration, only spaces are used.</p>

  <h3>Using a dictionary to find words</h3>
  <p>An industrial strength algorithm for finding grammatically correct word boundaries in languages like Thai is beyond the scope of this tutorial. Below, you is a new method <code>splitIntoWords</code> method that you can add to your <code>dictionaries.js</code> file.</p>
  <pre class="revised">"use strict"

var dico = {}

;(function addDictionaries() {
  dico = {

    dictionaries: {
      <span class="omit">// code omitted for clarity</span>
    }

  , tries: {}

  , initialize: function createTries(){
      <span class="omit">// code omitted for clarity</span>
    }

  , createTrie: function createTrie(languageMap) {
      <span class="omit">// code omitted for clarity</span>
    }

  <span class="new">, splitIntoWords: function splitIntoWords(string, languageCode) {
      var trie = this.tries[languageCode]
      var alternatives = []
      var path = trie
      var words = []
      var word = ""
      var found = false
      var char
        , next
        , alternative

      words.index = 0

      for (var ii = 0, total = string.length; ii < total ; ii += 1) {
        char = string[ii]
        next = path[char]

        if (next) { <span class="comment">// { "$": 0, "a": { ... }. ...}</span>
          word += char

          if (next.$) {
            if (found) {
              <span class="comment">// We've already added a shorter word to the list.
              // Push the list with the shorter word onto the
              // alternatives array and continue with the longer word</span>
              alternative = words.slice(0)
              alternative.index = words.index
              alternatives.push(alternative)

              words.index -= words.pop().length // remove shorter word
            }
            <span class="comment">// Add this whole word to the list</span>
            words.push(word)
            words.index += word.length
            found = true
          }

          path = next

        } else if (found) {
          <span class="comment">// !next, but we have a complete word already.
          // This character could be the start of a new word.</span>
          word = char
          path = trie[char]
          if (!path) {
            <span class="comment">// It's imposible to start a word with this letter</span>
            backtrack("Initial letter absent: " + char)

          } else if (path.$) {
            <span class="comment">// This is a one-letter word: found remains true</span>
            words.push(word)
            words.index += word.length

          } else {
            found = false
          }

        } else {
          <span class="comment">// !next &and;&and; !found: stop trying to complete this word</span>
          backtrack("Word fragment: " + word)
        }
      }

      if (!next || !next.$) {
        backtrack("Fail – Unknown word: ", word)
      }

      return words

      function backtrack(reason) {
        console.log(reason)

        <span class="comment">// Try the longest earlier alternative ...</span>
        words = alternatives.pop()
        <span class="comment">// ... if one exists ...</span>
        if (!words) {
          console.log("Failed to segment")
          ii = total
          return
        }
        <span class="comment">// ... and see if all the remaining characters can be
        // segmented into words</span>
        ii = words.index - 1
        path = trie
        word = ""
        found = false
      }
    }</span>
  }.initialize()
})()

<span class="new">console.log(dico.splitIntoWords("lookforaneedleinthesea", "enx"))</span>
</pre>

  <h3><code>splitIntoWords</code></h3>
  <p>The <code>splitIntoWords</code> method accepts a string of text and a language code. It uses the language code to select the appropriate language trie. It then takes the first character in the string and looks for it at the top level of the trie, then takes the second letter, and looks for it in the branch of the trie defined by the previous letter, adding it to its <code>word</code> variable as it goes. It will continue to do this until one of three things happens:</p>
  <ul>
  <li>It meets an object with a <code>"$": true</code> key/value pair</li>
  <li>It finds an object which contains no key for the letter in the string that it is currently looking at</li>
  <li>It reaches the end of the text</li>
  </ul>

  <h3>Adding words</h3>
  <p>The algorithm will step through the string and tunnel into the trie until it has created the string "look". At this point, it will encounter a {"$": true} object. This tells it to add the word "look" to its current <code>words</code> list, and to set a flag to say that at least one word has been found. Since an array is special kind of object, it can add a property to the array: it adds an <code>index</code> key with a value equal to the length of the string read so far. You'll see in a moment how this is used.</p>

  <h3>Preparing alternatives</h3>
  <p>The <code>splitIntoWords</code> algorithm is greedy: it will keep looking for the longest word that fits, and this may lead it into a blind alley. To test this, you'll find the nonsense word "forane" in the dictionary. After finding "look", the algorithm keeps moving forward. When it has read "for", it will find an object with both a <code>"$": true</code> key pair and the key "a", with a submap that it can continue to follow.</p>
  <p>It adds the word "for" to the <code>words</code> array, and updates the <code>index</code> of the array: <code>index</code> is now the sum of the lengths of the word in the array.</p>
  <p>The process continues until the <code>{"$": true}</code> object indicating the end of the nonsense word "forane" is found. This time, however, there is already a word that uses the letters "for" in the <code>words</code> array. The <code>splitIntoWords</code> function first uses <code>words.slice(0)</code> to copy the array, and also copies the value of <code>index</code>, to create a full clone. This clone is added to the <code>alternatives</code> array. In the original <code>words</code> array, the last word ("for") is removed and replaced with "forane", and the <code>index</code> value is corrected.</p>
  <p>A new word now begins, starting with the letter "e", but at the next iteration, no sub-map of <code>trie</code> is found that corresponds to the word fragment "ed". The <code>splitIntoWords</code> function has reached the end of a blind alley: it calls the <code>backtrack</code> function. This drops the current <code>words</code> array and replaces it with the longest array in <code>alternatives</code>: <code>["look", "for"]</code>, with its <code>index</code> value of 7. It resets the <code>ii</code> iterator so that the next iteration starts building a new word from position <code>ii = 7</code>: the index of the next letter after "lookfor". This time, it finds the words "a" and "need", which is soon replaced by "needle", and continues to read "these", and "a". This is a complete word and the final letter in the string, so the process stopes there</p>

  <div class="aside issue ">The algorithm has no grammatical "intelligence" built in, so it has no reason to reject "these", "a" and replace it with "the", "sea". It's greediness has led it into error. Refusing to be greedy could lead it to make different wrong choices. A different solution is needed to solve this problem, and that is outside the scope of this tutorial. (It relies on the statistical probablity of finding the combination "these a", compared to that of finding "the sea" in a large corpus of English, and even so a small number of errors may still occur.)</p>
  <p>This simple solution has another shortcoming: it will fail if it encounters any word not in the dictionary.
  <p>It's not feasible to load into the browser all the possible words in every language that might need to be treated. Instead, it would make sense to make a call to the server, where a database can provide a more efficient solution.</p>
  <p>A call to the server would need to be asynchonous: you can see how this could be done in the <a href="#async">next section</a>. For now, you can focus on the mechanics of calculating word breaks in a known tiny subset of the language.</p>
  </div>

  <h3>Integrating word-segmentation with click-to-select</h3>
  <p></p>

  <div class="aside next">In this section, you've ...
    <ul>
      <li>Done things</li>
      <li>Learnt ideas</li>
    </ul>
    <p>In the <a href="#async">next section</a>, you'll ....</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#async">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- ASYNCHRONOUS -->
<section id="async">
  <h2>Making an asynchronous call to get word boundaries</h2>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Do stuff</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/CHANGE_MY_NAME.zip" target="source">Download the source files</a>
  </div>

  <h3>Subsection</h3>
  <p>Stuff goes here</p>

  <div class="aside next">In this section, you've ...
    <ul>
      <li>Done things</li>
      <li>Learnt ideas</li>
    </ul>
    <p>In the <a href="#box">next section</a>, you'll ....</p>
  </div>

  <footer>
    <ul class="box">
      <li>
        <a href="#end">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- ASYNCHRONOUS -->
<section id="async">
  <h2>Making an asynchronous call to get word boundaries</h2>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Do stuff</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/CHANGE_MY_NAME.zip" target="source">Download the source files</a>
  </div>

  <h3>Subsection</h3>
  <p>Stuff goes here</p>

  <div class="aside next">In this section, you've ...
    <ul>
      <li>Done things</li>
      <li>Learnt ideas</li>
    </ul>
    <p>In the <a href="#jump">next section</a>, you'll ....</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#jump">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- JUMP -->
<section id="jump">
  <h2>Jumping to the next word with a shortcut</h2>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Do stuff</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/CHANGE_MY_NAME.zip" target="source">Download the source files</a>
  </div>

  <h3>Subsection</h3>
  <p>Stuff goes here</p>

  <div class="aside next">In this section, you've ...
    <ul>
      <li>Done things</li>
      <li>Learnt ideas</li>
    </ul>
    <p>In the <a href="#box">next section</a>, you'll ....</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#box">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- BOX -->
<section id="box">
  <h2>Limiting the "whole word selection" feature to one HTML element</h2>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Do stuff</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/CHANGE_MY_NAME.zip" target="source">Download the source files</a>
  </div>

  <h3>Subsection</h3>
  <p>Stuff goes here</p>

  <div class="aside next">In this section, you've ...
    <ul>
      <li>Done things</li>
      <li>Learnt ideas</li>
    </ul>
    <p>In the <a href="#end">next section</a>, you'll ....</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#end">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- NEXT -->
<section id="next">
  <h2>Title of section</h2>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Do stuff</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/CHANGE_MY_NAME.zip" target="source">Download the source files</a>
  </div>

  <h3>Subsection</h3>
  <p>Stuff goes here</p>

  <div class="aside next">In this section, you've ...
    <ul>
      <li>Done things</li>
      <li>Learnt ideas</li>
    </ul>
    <p>In the <a href="#end">next section</a>, you'll ....</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#end">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- CONCLUSION -->
<section id="end">
  <h2>Conclusion</h2>
  <div class="aside preview">Here's what you've learnt:
    <ul>
      <li>98% of good stuff</li>
      <li>2% salt</li>
    </ul>
  </div>

  <p>Well done!</p>
</section>

<!-- OVERVIEW : SECTION 0 -->
<section id="top">
  <h2>Overview</h2>
  <p class="top">This tutorial teaches you how to use JavaScript to control the selection of text in a web page.</p>

  <div class="aside preview">In particular, you will be learning about:
    <ul>
      <li>The <code>Selection</code> object</li>
      <li>The <code>Range</code> object</li>
      <li>Selecting the word under the cursor as the user drags the mouse</li>
      <li>Creating <span class="select">discontigous</span> word <span class="select">selections</span></li>
      <li>Working with text in a variety of writing scripts</li>
    </ul>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#intro">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>
</article>
</main>

<script src="../js/core.js"></script>
</body>
</html>
