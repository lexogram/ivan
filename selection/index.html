<!DOCTYPE html>
<html lang=en>
<head>
<meta charset="utf-8">
<title>Text Selection</title>
<link rel="stylesheet" href="../css/core.css" />
<link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
</head>

<body>
  <div class="sidebar">
    <div class="logo">
      <a href="../"><img src="../img/logo.png" alt="openbook home" /></a>
    </div>

    <nav>
      <ol>
        <li><a href="#top">Overview</a></li>
        <li><a href="#intro">Introduction</a></li>
        <li><a href="#discover">Discovering Selections</a></li>
        <li><a href="#whole_word">Selecting whole words</a></li>
        <li><a href="#dictionary">Using a dictionary</a></li>
        <li><a href="#box">Limiting to one element</a></li>
        <li><a href="#end">Conclusion</a></li>
      </ol>
    </nav>

    <p class="aside support">If you have any difficulty in this tutorial, please <a href="https://github.com/lexogram/openbook/issues/new">tell us about it</a>, and we will do our best to deal with it for you.</p>
  </div>

<main>
<header>
  <a href="https://github.com/lexogram/openbook/blob/master/LICENSE" class="cc">&#59409;</a>
  <h1>Text Selection</h1>
  <ul class="nav">
    <li>
      <a href="#back"><img src="../img/arrow.png" alt="back" /></a>
    </li><li>
      <a href="#next"><img src="../img/arrow.png" alt="next" /></a>
    </li>
  </ul>
</header>

<article>
<!-- INTRODUCTION -->
<section id="intro">
  <h2>Introduction</h2>
  <p>More details to go here</p>

  <footer>
    <ul class="nav">
      <li>
        <a href="#end">
          <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- DISCOVER -->
<section id="discover">
  <h2>Discovering the <code>Selection</code> and <code>Range</code> objects</h2>
  <div class="aside preview">In this section, you'll create test HTML page in order to:
    <ul>
      <li>Learn about the <code>Selection</code> object and its properties and methods</li>
      <li>Learn about the <code>Range</code> object and its properties and methods</li>
      <li>See how text can be made unselectable</li>
      <li>Learn how to select unselectable text</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/03_discover.zip" target="source">Download the source files</a>
  </div>

  <h3>A test page</h3>
  <p>You can start by creating a simple HTML page with a little JavaScript code to show what happens behind the scenes when you select text. You can see what your page will look in Figure 1 below.</p>

  <figure>
  <img src="img/testing.png" alt="Testing a text selection across nodes" />
  <figcaption>Figure 1. Testing a text selection across nodes</figcaption>
  </figure>

  <p>There are a number of things to notice here:</p>
  <ul>
   <li>The HTML includes nodes of different types: <code>&lt;p&gt;</code>, <code>&lt;div&gt;</code>, <code>&lt;span&gt;</code> and <code>&lt;em&gt;</code> tags</li>
   <li>The text uses different writing scripts: Cyrillic, Latin and Thai. In Thai, spaces indicate the end of clauses or sentences (like <code>,</code> and <code>.</code> characters in English). In other words, spaces do not indicate the ends of words. In order to select "the word under the mouse" in Thai (and many other writing scripts) you'll have to learn a technique that doesn't depend on spaces.</li>
   <li>One span in the text is intended to be "unselectable", but when you create a selection that starts before and finishes after this span, it is included in the selection.</li>
   <li>The text of the <code>p#output</code> element at the bottom cannot be selected, to prevent an endless loop where it would try to display the contents of itself inside itself.</li>
   </ul>

   <p>To test this yourself, create a file named <code>index.html</code> in the folder of your choice, enter the HTML code shown below, and save your file.</p>

  <h4><code>index.html</code></h4>
  <pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Selection&lt;/title&gt;
  &lt;style&gt;
    .box {
      width: 80%;
      margin: 0 auto;
      border: 1px solid #ccc;
      border-top-color: #666;
      border-left-color: #666;
      background-color: #f8f8f8;
      padding: 0.5em;
    }
    span {
      color: #c00;
    }
    .unselectable {
      -webkit-touch-callout: none; /* iOS Safari */
      -webkit-user-select: none;   /* Chrome/Safari/Opera */
      -khtml-user-select: none;    /* Konqueror */
      -moz-user-select: none;      /* Firefox */
      -ms-user-select: none;       /* Internet Explorer/Edge */
      user-select: none;  
      color: #999;
    }
  }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;p lang="ru"&gt;Вим ед путант альбюкиюс прёнкипыз, квюо
  эи выльёт аэтырно бландит, видэ фабыллас майыжтатйж прё экз.&lt;/p&gt;

  &lt;div class="box" lang="la"&gt;
    &lt;span&gt;Lorem ipsum dolor sit amet, consectetur adipiscing
    elit.&lt;/span&gt;
    In nunc ipsum, tristique in convallis non, ultrices sed eros.
    &lt;span class="unselectable"&gt;This span has
    &lt;em&gt;user-select: none;&lt;/em&gt; applied to it.&lt;/span&gt;
    &lt;span&gt;Integer eu dignissim justo, eu facilisis est.&lt;/span&gt;
  &lt;/div&gt;

  &lt;p lang="th"&gt;คนึงครวญคร่ำถวิลกินระกำ ระกำกินถวิลคร่ำครวญคนึง&lt;/p&gt;

  &lt;p id="output" class="unselectable"&gt;&lt;/p&gt;

  &lt;script src="js/selection.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

  <p>Now you can create a folder named <code>js</code> alongside your <code>index.html</code> file, create a file named <code>selection.js</code> inside this new folder, enter the JavaScript code as shown below, and save your file. The methods and properties of the <code>Selection</code> and <code>Range</code> objects are shown in red.</p>

  <h4><code>js/selection.js</code></h4>
  <pre>"use strict"

;(function selection(){
  var pOutput = document.getElementById("output")
  var selection = <span class="red">window.getSelection()</span>

  ;(function showSelection(){
    var output = "rangeCount: " + <span class="red">selection.rangeCount</span>
    var range
    var text

    if (<span class="red">selection.anchorNode</span>) {
      text = '"' + selection.anchorNode.textContent + '"'
      output += "&lt;br /&gt;anchorNode: " + text

      output += "&lt;br /&gt;anchorOffset: " + <span class="red">selection.anchorOffset</span>

      text = '"' + <span class="red">selection.focusNode</span>.textContent + '"'
      output += "&lt;br /&gt;focusNode: " + text

      output += "&lt;br /&gt;focusOffset: " + <span class="red">selection.focusOffset</span>
    }

    if (selection.rangeCount) {
      range = <span class="red">selection.getRangeAt(0)</span>

      text =  '"' + <span class="red">range.startContainer</span>.textContent + '"'
      output += "&lt;br /&gt;range.startContainer: " + text

      output += "&lt;br /&gt;range.startOffset: " + <span class="red">range.startOffset</span>

      text =  '"' + <span class="red">range.endContainer</span>.textContent + '"'
      output += "&lt;br /&gt;range.endContainer: " + text

      output += "&lt;br /&gt;range.endOffset: " + <span class="red">range.endOffset</span>

      text = '"' + <span class="red">range.toString()</span> + '"'
      output += "&lt;br /&gt;range.toString(): " + text
    }

    text = '"' + <span class="red">selection.toString()</span> + '"'
    output += "&lt;br /&gt;selection.toString(): " + text

    pOutput.innerHTML = output

    setTimeout(showSelection, 250)
  })()
})()</pre>

  <p class="aside info">You can test a working version <a href="source/03_discover/">here</a>.</p>

  <h3><code>window.getSelection()</code></h3>
  <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection"><code>getSelection()</code></a> method is global: you don't actually need to use <code>window.</code> before you use it. This command returns a live <code>Selection</code> object. The values stored in the <code>Selection</code> object update in real time as you drag the mouse to change your selection.</p>

  <h3>The <code>Selection</code> object</h3>
  <p>You can see all the properties of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection"><code>Selection</code></a> object by typing the command <code>getSelection()</code> in the Developer Tools' Console window:</p>

  <figure>
  <img src="img/getSelection.png" alt="Displaying the properties of the Selection object in the Console" />
  <figcaption>Figure 2. Displaying the properties of the Selection object in the Console</figcaption>
  </figure>

  <p>The <code>isCollapsed</code> property indicates if a selection is visible or not. It will be <code>true</code> if there is no current selection. If the one or more characters are selected, like <span class="select">this</span>, then <code>isCollapsed</code> will be <code>false</code>.</p>

  <p class="aside note">The <code>baseNode</code>, <code>baseOffset</code>, <code>extendNode</code> and <code>extendOffset</code> properties may not be present in your browser. In Chrome, they are aliases for the <code>anchor...</code> and <code>focus...</code> properties. The <code>type</code> property is also non-standard. In Webkit browsers, if <code>isCollapsed</code> is true, it can take the values "None" (before any selection is made), "Caret" (if there is no current visible selection); if <code>isCollapsed</code> is false, it will take the value "Range".</p>

  <h3><code>showSelection</code></h3>
  <p>The custom <code>showSelection</code> calls itself every 250 milliseconds, in order to update the contents of the <code>p#output</code> element in real time, as you modify the selection. Click somewhere on the page and drag the mouse, to see feedback from the <code>Selection</code> object.</p>

  <h3><code>anchorNode</code> and <code>focusNode</code></h3>
  <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/anchorNode"><code>anchorNode</code></a> is a pointer to the HTML node where you click the mouse to start your selection. The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/focusNode"><code>focusNode</code></a> is a pointer to the HTML element under the mouse while you are dragging. This may be the same as <code>anchorNode</code>.</p>
  <p class="aside note">In the <code>p#output</code> element, it's the <code>textContent</code> property of these nodes that is shown, not the HTML node object itself.</p>

  <h3>Unselectable text</h3>
  <p>You can apply a CSS rule to any HTML element to make its contents unselectable. The <code>.unselectable</code> class has this rule, which copes with most browsers in existence.</p>
<pre>.unselectable {
  -webkit-touch-callout: none; /* iOS Safari */
  -webkit-user-select: none;   /* Chrome/Safari/Opera */
  -khtml-user-select: none;    /* Konqueror */
  -moz-user-select: none;      /* Firefox */
  -ms-user-select: none;       /* Internet Explorer/Edge */
  user-select: none;  
}</pre>
  <p>If you're targetting recent browsers (from IE10 and later) then you can probably get away with just using:</p>
<pre>.unselectable {
  user-select: none;  
}</pre>
  <p>This class is applied to the sentence that says "<span class="aaa">This span has <em>user-select: none</em> applied to it,</span>". Note what happens if you click on this sentence and drag the mouse upwards or downwards.</p>
  <dl>
    <dt>Click on <span class="aaa"><em>none</em></span> and drag up:</dt>
    <dd>The <code>anchorNode</code> will be the one containing "<span class="aaa"> applied to it</span>", not the <code>&lt;em&gt;</code> element that you initially clicked on. The <code>focusNode</code> will be the HTML node under the mouse.</dd>
    <dt>Click on <span class="aaa"><em>none</em></span> and drag down:</dt>
    <dd>The <code>anchorNode</code> will be the <code>textNode</code> containing the space between "<span class="aaa">it.</span>" and "Integer". In other words: the first selectable node that follows the unselectable node.</dd>
    <dt>Click on <span class="aaa"><em>none</em></span> and drag over the unselectable phrase:</dt>
    <dd>Both the <code>anchorNode</code> and the <code>focusNode</code> will be the <code>textNode</code> containing the space following the unselectable node.</dd>
  </dl>

  <h3>The <code>Range</code> object</h3>
  <p>The <code>Range</code> object is now the official way to deal with multiple arbitrary chunks of an HTML page.</p>
  <p class="aside warn">Older browsers may not support the <code>Range</code> object. If you need to support older browsers then you might prefer to abandon this tutorial and start <a href="http://www.quirksmode.org/dom/range_intro.html">exploring on your own</a>.</p>

  <p>Before you click on a freshly loaded page, the <code>Selection</code> object will contain no <code>Range</code> objects, and the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/rangeCount"><code>selection.rangeCount</code></a> will return 0. When you click the first time, a <code>Range</code> object will be created, and <code>selection.rangeCount</code> will become <code>1</code>, even if no selection is visible.</p>
  <p class="aside note">It's thus important to check whether <code>selection.rangeCount</code> is greater than zero before using <code>var range = selection.<a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/getRangeAt">getRangeAt(0)</a></code> to obtain the <code>Range</code> object. Using an invalid index for the <code>.getRangeAt(...)</code> call will provoke an error.</p>
  <p>By default, the <code>Selection</code> object normally only contains a single <code>Range</code>. However, as you will see, you can use JavaScript to add other ranges to the user-created selection.</p>

  <h3>The <code>toString()</code> method</h3>
  <p>Both the <code>Selection</code> object and the <code>Range</code> object have a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/toString"><code>toString()</code></a> method which returns the text content of the selected chunk referred to by the object. When a selection has only one range, then both will return exactly the same string.</p>
  <p>Note that you can include "unselectable" text in a selection, by sandwiching the unselectable text with text from selectable nodes.</p>
  <dl>
    <dt>Click on the first word in the box (Lorem) and drag to the last word in the box (est)</dt>
    <dd>The <code>anchorNode</code> and <code>focusNode</code> will be what you should expect, but the values returned by <code>.toString()</code> will include the unselectable text.</dd>
    
  </dl>

  <h3>The <code>startContainer</code> and <code>endContainer</code> properties</h3>
  <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Range/startContainer"><code>startContainer</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Range/endContainer"><code>endContainer</code></a> properties of a range are similar to the <code>anchorNode</code> and <code>focusNode</code> properties of the <code>Selection</code> object, except they are always set in the order in which the text appears in the source HTML.</p>
  <dl>
    <dt>Click on the last word in the box (est) and drag to the last word in the box (Lorem)</dt>
    <dd>This time, you are starting at the end and dragging backwards: the <code>range.startContainer</code> will contain a pointer to the earlier <code>focusNode</code> and the <code>range.endContainer</code> will contain a pointer to the later <code>anchorNode</code>. This means that you can be sure of the order of the words on the page in your selection.</dd>
  </dl>

  <h3>The <code>...Offset</code> properties</h3>
  <p>The <code>anchorNode</code>, <code>focusNode</code>, <code>startContainer</code> and <code>endContainer</code> properties all have their associated <code>...Offset</code> proprties, which indicate where the boundary between non-selection and selection occurs in the particular HTML node. Below, you'll find links where you can read about these in furthur detail:</p>
  <ul>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/anchorOffset">anchorOffset</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/focusOffset">focusOffset</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Range/startOffset">startOffset</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Range/endOffset">endOffset</a></li>
  </ul>
  <p>You'll get a chance to work with these properties in the coming sections.</p>
  
  <h3>Putting it all together</h3>
  <p>Imagine the following HTML:</p>
<pre>&lt;blockquote&gt;&lt;p&gt;I have called this principle &lt;span&gt;...&lt;/span&gt; 
Natural Selection.&lt;/p&gt;
&lt;footer&gt;Charles Darwin&lt;/footer&gt;&lt;/blockquote&gt;</pre>
  <p>Imagine that you click between the "D" and the "a" of "Darwin" and drag your mouse upwards and release it between the two "ll"s of "called", to make the selection shown below:</p>
  <figure>
  <img src="img/natural.png" alt="The properties of a Selection" />
  <figcaption>Figure 3. The properties of a Selection</figcaption>
  </figure>
  <p>Here are the values that you will obtain:</p>
  <ul>
  <li><code>anchorNode.textContent</code>: "Charles Darwin"</li>
  <li><code>anchorNode</code>: 9</li>
  <li><code>focusNode.textContent</code>: "I have called this principle"</li>
  <li><code>focusOffset</code>: 11</li>
  </ul>
  <ul>
  <li><code><span class="ymmv">range</span>.startContainer.textContent</code>: "I have called this principle"</li>
  <li><code><span class="ymmv">range</span>.startOffset</code>: 11</li>
  <li><code><span class="ymmv">range</span>.endContainer.textContent:</code> "Charles Darwin"</li>
  <li><code><span class="ymmv">range</span>.endOffset</code>: 9</li>
  </ul>

  <div class="aside next">In this section, you've seen the basics about how text selections are treated in JavaScript.
    <ul>
      <li>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection">Selection</a> object
        <ul>
          <li><span class="ymmv">window.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection">getSelection()</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/anchorNode">anchorNode</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/anchorOffset">anchorOffset</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/focusNode">focusNode</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/focusOffset">focusOffset</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/rangeCount">rangeCount</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/getRangeAt">getRangeAt()</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/toString">toString()</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/isCollapsed">isCollapsed</a></li>
        </ul>
      </li>
      <li>The <a href="">Range</a> object
        <ul>
          <li><span class="ymmv">range.</span><a href="">startContainer</a></li>
          <li><span class="ymmv">range.</span><a href="">startOffset</a></li>
          <li><span class="ymmv">range.</span><a href="">endContainer</a></li>
          <li><span class="ymmv">range.</span><a href="">endContainer</a></li>
          <li><span class="ymmv">range.</span><a href="">endOffset</a></li>
          <li><span class="ymmv">range.</span><a href="">toString()</a></li>
        </ul>
      </li>
      <li>How a text selection is expressed in terms of its start and end points.</li>

    </ul>
    <p>In the <a href="#whole_word">next section</a>, you'll see how to extend a selection so that a single click can be used to select a whole word.</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#whole_word">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- WHOLE WORD -->
<section id="whole_word">
  <h2>Selecting the whole word</h2>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Ensure that when you make a selection, only complete words are selected</li>
      <li>Modify the selection by manipulating the <code>Range</code> object and its <code>startOffset</code> and <code>endOffset</code> properties.</li>
      <li>Use a regular expression to detect word boundaries</li>
      <li>Search backwards with a regular expression</li>
      <li>Refine the regular expression to exclude unwanted punctuation</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/CHANGE_MY_NAME.zip" target="source">Download the source files</a>
  </div>

  <h3>Setting the start and end points of a selection</h3>
  <p>By default, a click on a browser page will create an anchor point for a selection; if you drag the mouse, you can extend the selection forwards or backwards form the anchor point. With this default technique, selecting a whole word requires a composite precision action. If your interface is designed for selecting whole words, you can convert a click into a 'whole word selection' action and save your users time and reduce their risk of carpal tunnel syndrome.</p>
  <p>The trick is to extend the current selection backwards to the preceding word boundary and forwards to the next word boundary. This poses two questions:</p>
  <ul>
  <li>How do you define a word boundary?</li>
  <li>How do you extend a selection?</li>
  </ul>

  <p>Finding word boundaries with Regular Expressions</p>
  <p>Regular Expressions are designed to let you search for a particular pattern in a string of text. If you're not familiar with Regular Expressions, you might like to work through a <a href="http://regexone.com/">beginner's tutorial</a> so that the explanations below make more sense to you.</p>
  <p>You can start with a very simple pattern that will be a good approximation for a word boundary: <code>/\s/g</code>. This means: any space, anywhere in your text. You can refine this later, to exclude unwanted punctuation, but it will do for now.</p>

  <h3>Modifying a <code>Range</code></h3>
  <p>As soon as you click on a web page, the window's <code>Selection</code> object will possess a <code>Range</code> object. You can manipulate the <code>startOffset</code> of the Range's <code>startContainer</code> and the <code>endOffset</code> of its <code>endContainer</code>, to move them out to nearest word boundaries, but simply modifying the <code>Range</code> object will not be enough to change the visible selection on the page: you will also have to remove the <code>Range</code> object from the <code>Selection</code> and then add it back again, so that the <code>Selection</code> object becomes aware that it has changed.</p>
  <p>Below, you'll find new code to add to your <code>js/selection.js</code> file:</p>

  <h4><code>js/selection.js</code></h4>
  <pre class="revised">"use strict"

;(function selection(){
  var pOutput = document.getElementById("output")
  var selection = window.getSelection()
  <span class="new">var regex = /\s/g</span>

  ;(function showSelection(){
    <span class="omit">// code omitted for clarity</span>
  })()

  <span class="new">document.body.onmouseup = selectWholeWords

  function selectWholeWords() {
    if (selection.rangeCount) {
      var range = selection.getRangeAt(0)
      
      var container = range.startContainer
      var string = container.textContent 
      var offset = searchBackwards(
        string
      , range.startOffset
      , regex
      )
      <span class="red">range.setStart</span>(container, offset)

      container = range.endContainer
      string = container.textContent
      offset = range.endOffset
      offset += <span class="red">string</span>.substring(offset)<span class="red">.search</span>(regex)
      <span class="red">range.setEnd</span>(container, offset)

      <span class="red">selection.removeAllRanges</span>()
      <span class="red">selection.addRange</span>(range)
    }

    function searchBackwards(string, offset, regex) {
      var adjust = 0
      var result
      string = string.substring(0, offset)

      while (result = <span class="red">regex.exec</span>(string)) {
        offset = <span class="red">result.index</span>
        adjust = <span class="red">result[0].length</span>
      }

      return adjust ? offset + adjust : 0
    }
  }</span>
})()</pre>

  <h3>Searching with a Regular Expression</h3>
  <p>Regular Expressions are designed to start at the beginning of a string and work forward. It is therefore much easier to find the first space <em>after</em> the end of current selection than to find the last space before the selection begins.</p>
  <p>The <code>string.search(regex)</code> method of strings returns the position where the Regular Expression pattern is first found in the string. If you start searching from the <code>endOffset</code> point, you will find how many characters you need to move to get to the first following space.</p>
  <pre>      container = range.endContainer
      string = container.textContent
      offset = range.endOffset
      offset += string.substring(offset).search(regex)
      range.setEnd(container, offset)</pre>

  <h3>Searching backwards</h3>
  <p>To search backwards using an ordinary string as the search term, you can use <code><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf">lastIndexOf()</a></code> string method. However, if your search term is a regular expression, you need to be use a more roundabout technique. One efficient technique is to find all the occurrence of the pattern, and then choose the last one:</p>

<pre>function searchBackwards(string, offset, regex) {
  var adjust = 0
  var result
  string = string.substring(0, offset)

  while (result = regex.exec(string)) {
    offset = result.index
    adjust = result[0].length
  }

  return adjust ? offset + adjust : 0
}</pre>

  <h3><code><span class="ymmv">regex.</span>exec</code></h3>
  <p>The <code>exec</code> method of regular expressions looks for the next match for the regular expression pattern in the string. If there is a match, it returns an array that has two special properties: <code>index</code> and <code>input</code>. The first item in the array is the string of matched characters, while the <code>index</code> property gives the position of the beginning of the match. You can calculate the position of the end of the match, <code>result.index + result[0].length</code>.</p>

  <p>If there is no match for the regular expression pattern, the value of <code>adjust</code> will still be <code>0</code> and this function will return this zero, indicating the beginning of the string. If there is a match, then in the last line, <code>offset</code> and <code>adjust</code> will hold the values for the last match found: their sum will give the position of the end of the match.</p>

  <p class="aside warn">It's easy to create a regular expression that matches everywhere, in which case the <code>while</code> statement will never stop being <code>true</code>, and the browser will freeze. This shouldn't happen with the regular expressions used in this tutorial.</p>

  <h3>Testing</h3>
  <p>You can save the changes that you have made to <code>selection.js</code> and relaunch the page in your browser. Try clicking on words and on blank spaces between words, to see what happens.</p>

  <figure>
  <img src="img/spaces.png" alt="Punctuation may be selected along with words when spaces are used as word boundaries" />
  <figcaption>Figure 4. Punctuation may be selected along with words when spaces are used as word boundaries</figcaption>
  </figure>

  <p>As you can see in Figure 4 above, this solution is not yet perfect. Punctuation is selected along with words, and the last word in an HTML element may not be selected in full, because it is not followed by a space.</p>

  <h3>Revising the word boundary regular expression</h3>
  <p>In English, both hyphens and apostrophes may appear in the middle of a word such as in the name of the plant "mother-in-law's tongue". However the same symbol that is used for an apostrophe may be used as a single quotation mark, which is not a part of a word. An intermediate case may occur when an apostrophe indicating possession appears at the end of a word, such as in the expression "the twins' beds".</p>
  <p>Creating a regular expression that deals rigourously with all these cases is quite complex. Each language may require a different set of patterns. If you ignore the case of the trailing apostrophe in "twins'" for now, you can consider that:</p>
  <ul>
  <li>If a hyphen or apostrophe appear with another non-word character, then the hyphen or an apostrophe should be considered a word boundary</li>
  <li>If the hyphen or apostrophe appear with a letter character on either side, they should be considered a part of the word</li>
  <li>If any other non-word character appears between two letter characters, it should be considered a word boundary</li>
  <li>The first and last character in a string are word boundaries.</li>
  </ul>

  <p>You can make the following change to your <code>selection.js</code> script. Note that this uses a different regular expression for finding the start of the word than for finding the end. The details of the <code>regex</code> are described below.</p>
<pre><span  class="revised">"use strict"

;(function selection(){
  var pOutput = document.getElementById("output")
  var selection = window.getSelection()</span>
  // RegExp to detect word boundaries but to allow ' and - in
  // the middle of words
  // 1. Match a whole range of non-word characters pairs possibly 
  //    including a ' or a - (found in the range !-/)
  var regex = <span class="new">"[\\s!-@\\[-`\\{-~]{2,}"</span>
  // 2. Match a whole range of non-word characters, excluding ' 
  //    and -, on their own
  <span class="new">regex += "|[\\s!-&amp;\\(-,.-@\\[-`\\{-~]"</span>

  // 3a. Match sequence of single-quotes or hyphens at start
  <span class="new">var startRegex = new RegExp("^['-]+|" + regex, "g")</span>
  // 3b. Match end of string if there is no other boundary first;
  //     ignore trailing apostrophe/quote marks
  <span class="new">var endRegex = new RegExp(regex + "|['-]*$")</span>

  <span class="revised">;(function showSelection(){
    <span class="omit">// code omitted for clarity</span>
  })()

  document.body.onmouseup = selectWholeWords

  function selectWholeWords() {
    if (selection.rangeCount) {
      var range = selection.getRangeAt(0)

      var container = range.startContainer
      var string = container.textContent 
      var offset = searchBackwards( 
        string
      , range.startOffset
      , </span><span class="new">startRegex</span><span class="revised">
      )
      range.setStart(container, offset)     

      container = range.endContainer
      string = container.textContent
      offset = range.endOffset
      offset += string.substring(offset).search</span>(</span><span class="new">endRegex</span><span class="revised">)
      range.setEnd(container, offset)

      selection.removeAllRanges()
      selection.addRange(range)
    }

    function searchBackwards(string, offset, regex) {
      <span class="omit">// code omitted for clarity</span>
    }
  }
})()</span></pre>

  <h3>Explaining the <code>regex</code></h3>
  <p>In JavaScript, a regular expression can be created in two ways:
  </p>
  <ul>
  <li><code>/regular expression/</code></li>
  <li><code>new RegExp("regular expression")</code></li>
  </ul>
  <p>When the <code>new RegExp()</code> constructor is used, any <code>\</code> backslash characters needed to be escaped with another <code>\</code> backslash character. In other words <code>new RegExp("[\\s!-@\\[-`\\{-~]{2,}")</code> will create a regular expression that looks like this: <code>/[\s!-@\[-`\{-~]{2,}/</code></p>
  <p>This means:</p>
  <dl>
    <dt><code>[<span class="ymmv">...</span>]</code></dt>
    <dd>Any one of the characters described within the square brackets. As you will see, these are all the printable characters with a <code>charCode</code> less than 128, which are neither uppercase or lowercase letters: all the non-word characters for English.</dd>
    <dt><code>\s</code></dt>
    <dd>A white-space character such as a space, a non-breaking space, a tab, a carriage return or a line-feed character</dd>
    <dt><code>!-/</code></dt>
    <dd>Any character between <code>!</code> and <code>/</code> in their order in the <a href="">ascii</a> table. To be exact, the characters <code>! " # $ % &amp; <span class="red">'</span> ( ) * + , <span class="red">-</span> . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @</code>. Notice that this includes the characters <code>'</code> and <code>-</code> that create a special case.</dd>
    <dt><code>\[-`</code></dt>
    <dd>All the characters between <code>[</code> and <code>`</code> inclusive. Note that <code>[</code> has a special meaning in regular expressions, so it needs to be escaped with a <code>\</code> backslash character</dd>
    <dt><code>\{-~</code></dt>
    <dd>All the characters between <code>{</code> and <code>~</code> inclusive. Note that <code>[</code> has a special meaning in regular expressions, so it needs to be escaped with a <code>\</code> backslash character</dd>
    <dt>{2,}</dt>
    <dd>Two or more of the characters described in the preceding <code>[<span class="ymmv">...</span>]</code></dd>
  </dl>
  <p>In other words, if a <code>'</code> and <code>-</code> character appears beside another non-word character, it will be considered a word boundary.</p>
  <p>In between each of these sections of non-word characters, the ascii table has sections for:</p>
  <ul>
  <li>A-Z (between <code>@</code> and <code>[</code>)</li>
  <li>a-z (between <code>{</code> and <code>~</code>)</li>
  </ul>
  <p>The second section of the <code>regex</code> starts with the <code>|</code> character, which means OR. There are two differences between what follows and the part you have already seen:</p>
  <ul>
  <li>The <code>'</code> and <code>-</code> characters are excluded</li>
  <li>Only one of any of the other characters is needed to create a word boundary</li>
  </ul>
  <p>In other words, the second part of the <code>regex</code> considers all non-word characters on their own <em>except</em> <code>'</code> and <code>-</code> as word boundaries.</p>

  <h3><code>startRegex</code> and <code>endRegex</code></h3>
  <p>The first character of an HTML node may be an opening single quote, or possibly a hyphen, to indicate a list. If these initial characters were included in <code>endRegex</code>, then a click on an apostrophe or a hyphen in the middle of a word would prevent that character and the remainder of the word from being chosen. The <code>startRegex</code> needs to be applied multiple times, in order to find the last occurrence, so the <code>g</code> global flag is required.</p>
  <p>The last character in an HTML element may be a closing single quote, not followed by any other non-word character. The word might also end with no punctuation to follow it, so the <code>$</code> end of string character is also considered a word boundary. If this were included in <code>startRegex</code> then  a click on an apostrophe or a hyphen in the middle of a word would prevent that character and the beginning of the word from being chosen.</p>

  <h3>Testing the refined regular expression</h3>
  <p>You can now test whether the new regular expression will correctly detect punctuation and words at the end of an element, as well as embedded hyphens and apostrophes. You might like to add a (rather contrived) sentence to your test page, so thet you can check that everything is working as expected.</p>

  <h4><code>index.html</code></h4>
  <pre class="revised">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  <span class="omit">// HTML omitted for clarity</span>
&lt;/head&gt;

&lt;body&gt;
  <span class="omit">// HTML omitted for clarity</span>

  &lt;p lang="th"&gt;คนึงครวญคร่ำถวิลกินระกำ ระกำกินถวิลคร่ำครวญคนึง&lt;/p&gt;

  <span class="new">&lt;p&gt;'Created 2016-08-14:' This'll let you -see- how - the
  word-detection 'works'&lt;/p&gt;</span>

  &lt;p id="output" class="unselectable"&gt;&lt;/p&gt;

  &lt;script src="js/selection.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

  <p>This word detection technique works with English, Latin and Russian, and indeed all the languages that use spaces and standard English-style punctuation. For the Thai text, however, it selects an entire sentence rather than a single word.</p>

  <figure>
  <img src="img/boundaries.png" alt="Words with embedded hyphens and apostrophes are selected whole" />
  <figcaption>Figure 5. Words with embedded hyphens and apostrophes are selected whole</figcaption>
  </figure>

  <p class="aside info">You can test a working version <a href="source/04_whole_word/">here</a>.</p>

  <div class="aside next">In this section, you've:
    <ul>
      <li>Seen how to use a regular expression to define word boundaries for English. </li>
      <li>Manipulated a <code>Range</code> object to modify the current selection</li>
    </ul>
    <p>In particular you have seen:</p>
    <ul>
    <li><code>Selection</code> object
      <ul>
        <li><code><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/removeAllRanges">removeAllRanges</a></code></li>
        <li><code><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/addRange">addRange</a></code></li>
      </ul>
    </li>
    <li><code>Range</code> object
      <ul>
        <li><code><span class="ymmv">range.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Range/setStart">setStart</a></code></li>
        <li><code><span class="ymmv">range.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Range/setEnd">setEnd</a></code></li>
      </ul>
    </li>
    <li><code>RegExp</code> object
      <ul>
        <li><code><span class="ymmv">regex.</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec">exec</a>(string)</code></li>
        <li><code><span class="ymmv">string.</span><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/search">search</a>(regex)</code></li>
      </ul>
    </li>
    </ul>
    <p>One standard technique for finding whole words in Chinese, Japanese, Thai or Khmer is to use a word dictionary. You'll see how to do that using a mini Thai dictionary in the <a href="#dictionary">next section</a>.</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#end">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- DICTIONARY -->
<section id="dictionary">
  <h2>Using a dictionary to find word boundaries</h2>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Do stuff</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/CHANGE_MY_NAME.zip" target="source">Download the source files</a>
  </div>

  <h3>Subsection</h3>
  <p>Stuff goes here</p>

  <div class="aside next">In this section, you've ...
    <ul>
      <li>Done things</li>
      <li>Learnt ideas</li>
    </ul>
    <p>In the <a href="#box">next section</a>, you'll ....</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#box">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- BOX -->
<section id="box">
  <h2>Limiting the "whole word selection" feature to one HTML element</h2>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Do stuff</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/CHANGE_MY_NAME.zip" target="source">Download the source files</a>
  </div>

  <h3>Subsection</h3>
  <p>Stuff goes here</p>

  <div class="aside next">In this section, you've ...
    <ul>
      <li>Done things</li>
      <li>Learnt ideas</li>
    </ul>
    <p>In the <a href="#end">next section</a>, you'll ....</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#end">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- NEXT -->
<section id="next">
  <h2>Title of section</h2>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Do stuff</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/CHANGE_MY_NAME.zip" target="source">Download the source files</a>
  </div>

  <h3>Subsection</h3>
  <p>Stuff goes here</p>

  <div class="aside next">In this section, you've ...
    <ul>
      <li>Done things</li>
      <li>Learnt ideas</li>
    </ul>
    <p>In the <a href="#end">next section</a>, you'll ....</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#end">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- CONCLUSION -->
<section id="end">
  <h2>Conclusion</h2>
  <div class="aside preview">Here's what you've learnt:
    <ul>
      <li>98% of good stuff</li>
      <li>2% salt</li>
    </ul>
  </div>

  <p>Well done!</p>
</section>

<!-- OVERVIEW : SECTION 0 -->
<section id="top">
  <h2>Overview</h2>
  <p class="top">This tutorial teaches you how to use JavaScript to control the selection of text in a web page.</p>

  <div class="aside preview">In particular, you will be learning about:
    <ul>
      <li>The <code>Selection</code> object</li>
      <li>The <code>Range</code> object</li>
      <li>Selecting the word under the cursor as the user drags the mouse</li>
      <li>Creating <span class="select">discontigous</span> word <span class="select">selections</span></li>
      <li>Working with text in a variety of writing scripts</li>
    </ul>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#intro">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>
</article>
</main>

<script src="../js/core.js"></script>
</body>
</html>
