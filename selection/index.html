<!DOCTYPE html>
<html lang=en>
<head>
<meta charset="utf-8">
<title>Text Selection</title>
<link rel="stylesheet" href="../css/core.css" />
<link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
</head>

<body>
  <div class="sidebar">
    <div class="logo">
      <a href="../"><img src="../img/logo.png" alt="openbook home" /></a>
    </div>

    <nav>
      <ol>
        <li><a href="#top">Overview</a></li>
        <li><a href="#discover">Discovering Selections</a></li>
        <li><a href="#hyphens">Hyphenated words</a></li>
        <li><a href="#jump">Jump to next word</a></li>
        <li><a href="#next_node">Jump to next node</a></li>
        <li><a href="#unselect">Detecting user-select</a></li>
        <li><a href="#previous">Jump to previous word</a></li>
        <li><a href="#scroll">Scroll into view</a></li>
        <li><a href="#nested-scroll">Scrolling sub-elements</a></li>
        <li><a href="#box">Limiting to one element</a></li>
        <li><a href="#end">Conclusion</a></li>
      </ol>
    </nav>

    <p class="aside support">If you have any difficulty in this tutorial, please <a href="https://github.com/lexogram/openbook/issues/new">tell us about it</a>, and we will do our best to deal with it for you.</p>
  </div>

<main>
<header>
  <a href="https://github.com/lexogram/openbook/blob/master/LICENSE" class="cc">&#59409;</a>
  <h1>Text Selection</h1>
  <ul class="nav">
    <li>
      <a href="#back"><img src="../img/arrow.png" alt="back" /></a>
    </li><li>
      <a href="#next"><img src="../img/arrow.png" alt="next" /></a>
    </li>
  </ul>
</header>

<article>

<!-- DISCOVER -->
<section id="discover">
  <h2>Discovering the <code>Selection</code> and <code>Range</code> objects</h2>
  <div class="aside preview">In this section, you'll create test HTML page in order to:
    <ul>
      <li>Learn about the <code>Selection</code> object and its properties and methods</li>
      <li>Learn about the <code>Range</code> object and its properties and methods</li>
      <li>See how text can be made unselectable</li>
      <li>Learn how to select unselectable text</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/02_discover.zip" target="source">Download the source files</a>
  </div>

  <h3>A test page</h3>
  <p>You can start by creating a simple HTML page with a little JavaScript code to show what happens behind the scenes when you select text. You can see what your page will look in Figure 1 below.</p>

  <figure>
  <img src="img/testing.png" alt="Testing a text selection across nodes" />
  <figcaption>Figure 1. Testing a text selection across nodes</figcaption>
  </figure>

  <p>There are a number of things to notice here:</p>
  <ul>
   <li>The HTML includes nodes of different types: <code>&lt;p&gt;</code>, <code>&lt;div&gt;</code>, <code>&lt;span&gt;</code> and <code>&lt;em&gt;</code> tags</li>
   <li>The text uses two different writing scripts: Cyrillic and Latin.</li>
   <li>One span in the text is intended to be "unselectable", but when you create a selection that starts before and finishes after this span, it is included in the selection.</li>
   <li>The text of the <code>p#output</code> element at the bottom cannot be selected, to prevent an endless loop where it would try to display the contents of itself inside itself.</li>
   </ul>

   <p>To test this yourself, create a file named <code>index.html</code> in the folder of your choice, enter the HTML code shown below, and save your file.</p>

  <h4><code>index.html</code></h4>
  <pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Selection&lt;/title&gt;
  &lt;style&gt;
    .box {
      width: 80%;
      margin: 0 auto;
      border: 1px solid #ccc;
      border-top-color: #666;
      border-left-color: #666;
      background-color: #f8f8f8;
      padding: 0.5em;
    }
    span {
      color: #c00;
    }
    .unselectable {
      -webkit-touch-callout: none; /* iOS Safari */
      -webkit-user-select: none;   /* Chrome/Safari/Opera */
      -khtml-user-select: none;    /* Konqueror */
      -moz-user-select: none;      /* Firefox */
      -ms-user-select: none;       /* Internet Explorer/Edge */
      user-select: none;
      -webkit-user-drag: none;
      user-drag: none; 
      color: #999;
    }
  }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;p lang="ru"&gt;Вим ед путант альбюкиюс прёнкипыз, квюо
  эи выльёт аэтырно бландит, видэ фабыллас майыжтатйж прё экз.&lt;/p&gt;

  &lt;div class="box" lang="la"&gt;
    &lt;span&gt;Lorem ipsum dolor sit amet, consectetur adipiscing
    elit.&lt;/span&gt;
    In nunc ipsum, tristique in convallis non, ultrices sed eros.
    &lt;span class="unselectable"&gt;This span has
    &lt;em&gt;user-select: none;&lt;/em&gt; applied to it.&lt;/span&gt;
    &lt;span&gt;Integer eu dignissim justo, eu facilisis est.&lt;/span&gt;
  &lt;/div&gt;

  &lt;p lang="th"&gt;คนึงครวญคร่ำถวิลกินระกำ ระกำกินถวิลคร่ำครวญคนึง&lt;/p&gt;

  &lt;p id="output" class="unselectable"&gt;&lt;/p&gt;

  &lt;script src="js/selection.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

  <p>Now you can create a folder named <code>js</code> alongside your <code>index.html</code> file, create a file named <code>selection.js</code> inside this new folder, enter the JavaScript code as shown below, and save your file. The methods and properties of the <code>Selection</code> and <code>Range</code> objects are shown in red.</p>

  <h4><code>js/selection.js</code></h4>
  <pre>"use strict"

;(function selection(){
  var pOutput = document.getElementById("output")
  var selection = <span class="red">window.getSelection()</span>

  ;(function showSelection(){
    var output = "rangeCount: " + <span class="red">selection.rangeCount</span>
    var range
    var text

    if (<span class="red">selection.anchorNode</span>) {
      text = '"' + selection.anchorNode.textContent + '"'
      output += "&lt;br /&gt;anchorNode: " + text

      output += "&lt;br /&gt;anchorOffset: " + <span class="red">selection.anchorOffset</span>

      text = '"' + <span class="red">selection.focusNode</span>.textContent + '"'
      output += "&lt;br /&gt;focusNode: " + text

      output += "&lt;br /&gt;focusOffset: " + <span class="red">selection.focusOffset</span>
    }

    if (selection.rangeCount) {
      range = <span class="red">selection.getRangeAt(0)</span>

      text =  '"' + <span class="red">range.startContainer</span>.textContent + '"'
      output += "&lt;br /&gt;range.startContainer: " + text

      output += "&lt;br /&gt;range.startOffset: " + <span class="red">range.startOffset</span>

      text =  '"' + <span class="red">range.endContainer</span>.textContent + '"'
      output += "&lt;br /&gt;range.endContainer: " + text

      output += "&lt;br /&gt;range.endOffset: " + <span class="red">range.endOffset</span>

      text = '"' + <span class="red">range.toString()</span> + '"'
      output += "&lt;br /&gt;range.toString(): " + text
    }

    text = '"' + <span class="red">selection.toString()</span> + '"'
    output += "&lt;br /&gt;selection.toString(): " + text

    pOutput.innerHTML = output

    setTimeout(showSelection, 250)
  })()
})()</pre>

  <div class="test unselectable">
    <a href="source/02_discover/" target="test">Test Here</a>
  </div>

  <h3><code>window.getSelection()</code></h3>
  <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection"><code>getSelection()</code></a> method is global: you don't actually need to use <code>window.</code> before you use it. This command returns a live <code>Selection</code> object. The values stored in the <code>Selection</code> object update in real time as you drag the mouse to change your selection.</p>

  <h3>The <code>Selection</code> object</h3>
  <p>You can see all the properties of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection"><code>Selection</code></a> object by typing the command <code>getSelection()</code> in the Developer Tools' Console window:</p>

  <figure>
  <img src="img/getSelection.png" alt="Displaying the properties of the Selection object in the Console" />
  <figcaption>Figure 2. Displaying the properties of the Selection object in the Console</figcaption>
  </figure>

  <p>The <code>isCollapsed</code> property indicates if a selection is visible or not. It will be <code>true</code> if there is no current selection. If the one or more characters are selected, like <span class="select">this</span>, then <code>isCollapsed</code> will be <code>false</code>.</p>

  <p class="aside note">The <code>baseNode</code>, <code>baseOffset</code>, <code>extendNode</code> and <code>extendOffset</code> properties may not be present in your browser. In Chrome, they are aliases for the <code>anchor...</code> and <code>focus...</code> properties. The <code>type</code> property is also non-standard. In Webkit browsers, if <code>isCollapsed</code> is true, it can take the values "None" (before any selection is made), "Caret" (if there is no current visible selection); if <code>isCollapsed</code> is false, it will take the value "Range".</p>

  <h3><code>showSelection</code></h3>
  <p>The custom <code>showSelection</code> calls itself every 250 milliseconds, in order to update the contents of the <code>p#output</code> element in real time, as you modify the selection. Click somewhere on the page and drag the mouse, to see feedback from the <code>Selection</code> object.</p>

  <h3><code>anchorNode</code> and <code>focusNode</code></h3>
  <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/anchorNode"><code>anchorNode</code></a> is a pointer to the HTML node where you click the mouse to start your selection. The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/focusNode"><code>focusNode</code></a> is a pointer to the HTML element under the mouse while you are dragging. This may be the same as <code>anchorNode</code>.</p>
  <p class="aside note">In the <code>p#output</code> element, it's the <code>textContent</code> property of these nodes that is shown, not the HTML node object itself.</p>

  <h3>Unselectable text</h3>
  <p>You can apply a CSS rule to any HTML element to make its contents unselectable. The <code>.unselectable</code> class has this rule, which copes with most browsers in existence.</p>
<pre>.unselectable {
  -webkit-touch-callout: none; /* iOS Safari */
  -webkit-user-select: none;   /* Chrome/Safari/Opera */
  -khtml-user-select: none;    /* Konqueror */
  -moz-user-select: none;      /* Firefox */
  -ms-user-select: none;       /* Internet Explorer/Edge */
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
}</pre>
  <p>If you're targetting recent browsers (from IE10 and later) then you can probably get away with just using:</p>
<pre>.unselectable {
  user-select: none;
  user-drag: none;
}</pre>
  <p>This class is applied to the sentence that says "<span class="aaa">This span has <em>user-select: none</em> applied to it,</span>". Note what happens if you click on this sentence and drag the mouse upwards or downwards.</p>
  <dl>
    <dt>Click on <span class="aaa"><em>none</em></span> and drag up:</dt>
    <dd>The <code>anchorNode</code> will be the one containing "<span class="aaa"> applied to it</span>", not the <code>&lt;em&gt;</code> element that you initially clicked on. The <code>focusNode</code> will be the HTML node under the mouse.</dd>
    <dt>Click on <span class="aaa"><em>none</em></span> and drag down:</dt>
    <dd>The <code>anchorNode</code> will be the <code>textNode</code> containing the space between "<span class="aaa">it.</span>" and "Integer". In other words: the first selectable node that follows the unselectable node.</dd>
    <dt>Click on <span class="aaa"><em>none</em></span> and drag over the unselectable phrase:</dt>
    <dd>Both the <code>anchorNode</code> and the <code>focusNode</code> will be the <code>textNode</code> containing the space following the unselectable node.</dd>
  </dl>

  <h3>The <code>Range</code> object</h3>
  <p>The <code>Range</code> object is now the official way to deal with multiple arbitrary chunks of an HTML page.</p>
  <p class="aside warn">Older browsers may not support the <code>Range</code> object. If you need to support older browsers then you might prefer to abandon this tutorial and start <a href="http://www.quirksmode.org/dom/range_intro.html">exploring on your own</a>.</p>

  <p>Before you click on a freshly loaded page, the <code>Selection</code> object will contain no <code>Range</code> objects, and the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/rangeCount"><code>selection.rangeCount</code></a> will return 0. When you click the first time, a <code>Range</code> object will be created, and <code>selection.rangeCount</code> will become <code>1</code>, even if no selection is visible.</p>
  <p class="aside note">It's thus important to check whether <code>selection.rangeCount</code> is greater than zero before using <code>var range = selection.<a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/getRangeAt">getRangeAt(0)</a></code> to obtain the <code>Range</code> object. Using an invalid index for the <code>.getRangeAt(...)</code> call will provoke an error.</p>
  <p>By default, the <code>Selection</code> object normally only contains a single <code>Range</code>. However, as you will see, you can use JavaScript to add other ranges to the user-created selection.</p>

  <h3>The <code>toString()</code> method</h3>
  <p>Both the <code>Selection</code> object and the <code>Range</code> object have a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/toString"><code>toString()</code></a> method which returns the text content of the selected chunk referred to by the object. When a selection has only one range, then both will return exactly the same string.</p>
  <p>Note that you can include "unselectable" text in a selection, by sandwiching the unselectable text with text from selectable nodes.</p>
  <dl>
    <dt>Click on the first word in the box (Lorem) and drag to the last word in the box (est)</dt>
    <dd>The <code>anchorNode</code> and <code>focusNode</code> will be what you should expect, but the values returned by <code>.toString()</code> will include the unselectable text.</dd>
    
  </dl>

  <h3>The <code>startContainer</code> and <code>endContainer</code> properties</h3>
  <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Range/startContainer"><code>startContainer</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Range/endContainer"><code>endContainer</code></a> properties of a range are similar to the <code>anchorNode</code> and <code>focusNode</code> properties of the <code>Selection</code> object, except they are always set in the order in which the text appears in the source HTML.</p>
  <dl>
    <dt>Click on the last word in the box (est) and drag to the last word in the box (Lorem)</dt>
    <dd>This time, you are starting at the end and dragging backwards: the <code>range.startContainer</code> will contain a pointer to the earlier <code>focusNode</code> and the <code>range.endContainer</code> will contain a pointer to the later <code>anchorNode</code>. This means that you can be sure of the order of the words on the page in your selection.</dd>
  </dl>

  <h3>The <code>...Offset</code> properties</h3>
  <p>The <code>anchorNode</code>, <code>focusNode</code>, <code>startContainer</code> and <code>endContainer</code> properties all have their associated <code>...Offset</code> proprties, which indicate where the boundary between non-selection and selection occurs in the particular HTML node. Below, you'll find links where you can read about these in furthur detail:</p>
  <ul>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/anchorOffset">anchorOffset</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/focusOffset">focusOffset</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Range/startOffset">startOffset</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Range/endOffset">endOffset</a></li>
  </ul>
  <p>You'll get a chance to work with these properties in the coming sections.</p>
  
  <h3>Putting it all together</h3>
  <p>Imagine the following HTML:</p>
<pre>&lt;blockquote&gt;&lt;p&gt;I have called this principle &lt;span&gt;...&lt;/span&gt; 
Natural Selection.&lt;/p&gt;
&lt;footer&gt;Charles Darwin&lt;/footer&gt;&lt;/blockquote&gt;</pre>
  <p>Imagine that you click between the "D" and the "a" of "Darwin" and drag your mouse upwards and release it between the two "ll"s of "called", to make the selection shown below:</p>
  <figure>
  <img src="img/natural.png" alt="The properties of a Selection" />
  <figcaption>Figure 3. The properties of a Selection</figcaption>
  </figure>
  <p>Here are the values that you will obtain:</p>
  <ul>
  <li><code>anchorNode.textContent</code>: "Charles Darwin"</li>
  <li><code>anchorNode</code>: 9</li>
  <li><code>focusNode.textContent</code>: "I have called this principle"</li>
  <li><code>focusOffset</code>: 11</li>
  </ul>
  <ul>
  <li><code><span class="ymmv">range</span>.startContainer.textContent</code>: "I have called this principle"</li>
  <li><code><span class="ymmv">range</span>.startOffset</code>: 11</li>
  <li><code><span class="ymmv">range</span>.endContainer.textContent:</code> "Charles Darwin"</li>
  <li><code><span class="ymmv">range</span>.endOffset</code>: 9</li>
  </ul>

  <div class="aside next">In this section, you've seen the basics about how text selections are treated in JavaScript.
    <ul>
      <li>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection">Selection</a> object
        <ul>
          <li><span class="ymmv">window.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection">getSelection()</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/anchorNode">anchorNode</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/anchorOffset">anchorOffset</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/focusNode">focusNode</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/focusOffset">focusOffset</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/rangeCount">rangeCount</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/getRangeAt">getRangeAt()</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/toString">toString()</a></li>
          <li><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/isCollapsed">isCollapsed</a></li>
        </ul>
      </li>
      <li>The <a href="">Range</a> object
        <ul>
          <li><span class="ymmv">range.</span><a href="">startContainer</a></li>
          <li><span class="ymmv">range.</span><a href="">startOffset</a></li>
          <li><span class="ymmv">range.</span><a href="">endContainer</a></li>
          <li><span class="ymmv">range.</span><a href="">endContainer</a></li>
          <li><span class="ymmv">range.</span><a href="">endOffset</a></li>
          <li><span class="ymmv">range.</span><a href="">toString()</a></li>
        </ul>
      </li>
      <li>How a text selection is expressed in terms of its start and end points.</li>

    </ul>
    <p>In the <a href="#hyphens">next section</a>, you'll see how to extend a selection so that a single click can be used to select the whole of a hyphenated word.</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#hyphens">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- WHOLE WORD -->
<section id="hyphens">
  <h2>Selecting the whole word</h2>
  <p>As of August 2016, none of the major browsers (Chrome, Firefox, IE, Opera, Safari) allow you to select a hyphenated word with a double-click. The default behaviour is to select only the word that was clicked, or the hypen.</p>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Ensure that when you double-click to make a selection, hyphenated words are fully selected</li>
      <li>Modify the selection by manipulating the <code>Range</code> object and its <code>startOffset</code> and <code>endOffset</code> properties.</li>
      <li>Use a simple regular expression to detect word boundaries</li>
      <li>Search backwards with a regular expression</li>
      <li>Refine your regular expression so that it works with all European languages.</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/03_hyphens.zip" target="source">Download the source files</a>
  </div>

  <h3>Modifying a <code>Range</code></h3>
  <p>As soon as you click on a web page, the window's <code>Selection</code> object will possess a <code>Range</code> object. You can manipulate the <code>startOffset</code> of the Range's <code>startContainer</code> and the <code>endOffset</code> of its <code>endContainer</code>, to move them out to nearest word boundaries, but simply modifying the <code>Range</code> object will not be enough to change the visible selection on the page: you will also have to remove the <code>Range</code> object from the <code>Selection</code> and then add it back again, so that the <code>Selection</code> object becomes aware that it has changed.</p>

  <h3>Defining the problem</h3>
  <p>By default, a click on a browser page will create an anchor point for a selection; if you drag the mouse, you can extend the selection forwards or backwards form the anchor point. If you double-click, you switch to "whole word mode"; as you drag your mouse, the selection will select whole words and the whole non-word spaces between them. With this default technique, selecting a hyphenated word requires a composite action: a (double-)click followed by a drag and release. If it makes sense for your users to select hyphenated words whole by default, you can add a patch that will  save your users time and reduce their risk of carpal tunnel syndrome.</p>
  <p>The trick is to:</p>
  <ul>
   <li>Detect if the current word contains a hyphen</li>
   <li>If so, extend the current selection backwards to the preceding word boundary and forwards to the next word boundary.</li>
  </ul>
  <p>This poses three questions:</p>
  <ul>
  <li>How do you detect that a word contains a hyphen?</li>
  <li>How do you define a word boundary?</li>
  <li>How do you extend a selection?</li>
  </ul>

  <h3>Using Regular Expressions</h3>
  <p>Regular Expressions are designed to let you search for a particular pattern in a string of text. If you're not familiar with Regular Expressions, you might like to work through a <a href="http://regexone.com/">beginner's tutorial</a> so that the explanations below make more sense to you.</p>
  <p>The example below uses three regular expressions. Here's the simplest: <code>/\w/</code>. This means "match the first <span class="keyword">word character</span> in the string". According to the <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.10.2.6">JavaScript specifications</a>, a word character is any of the following:</p>
  <pre>0123456789_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
</pre>
  <p>That's fine if you're working in English and not using any of them fancy foreign words with accents, like "déjà vu" or "mañana". You can use this simple expression for now, for testing the logic of your code, and then create a more generic regular expression when you've got everything working in plain vanilla English.</p>

  <p>The other two regular expressions used are more complicated. For example:</p>
  <pre>var endRegex = /^-('?-?\w+)+/</pre>
  <p>Here's what it means</p>
  <dl>
    <dt><code>^</code></dt>
    <dd>Starting from the beginning of the string ...</dd>
    <dt><code>-</code></dt>
    <dd>... find one a hypen ...</dd>
    <dt><code>(<span class="ymmv">...</span>)+</code></dt>
    <dd>... followed by one or more sequences ...</dd>
   <dt><code>'?-?\w+</code></dt>
    <dd>... of optional apostrophes and hyphens and ending with one of more word characters</dd>
  </dl>
  <p>In summary, this means: <em>look for the longest chunk like "-to-day" or "-friend's", that starts with a hyphen, may include more hyphens and apostrophes, and ends with a letter or a number.</em> If the string you are searching in starts with "no hyphens", then nothing will match.</p>
  <p>The other regex you can use for now is:</p>
  <pre>/(\w+'?-?)+-$/g</pre>
  <p>This uses similar techniques to say: <em>look for the longest chunk that starts with a word character, may include some hyphens and apostrophes, and ends with a hyphen</em>. The final <code>g</code> means: after you've found this pattern, keep looking for more.</p>

  <p class="aside warn">It's easy to create a regular expression that matches everywhere, in which case the <code>while</code> statement in the code listing below will never stop being <code>true</code>, and the browser will freeze. This shouldn't happen with the regular expressions used in this tutorial. If you change the <code>startRegex</code> expression and the browser stops responding, then the best solution is to force quit your browser, and restart it without restoring the previous session. Fix your script before you reload your page.</p>

  <p>Below, you'll find new code to add to your <code>js/selection.js</code> file:</p>

  <h4><code>js/selection.js</code></h4>
  <pre><span class="revised">"use strict"

;(function showSelection(){
  <span class="omit">// code omitted for clarity</span>
})()</span>


;(function selectWholeWordsWithHyphens(){
  var selection = window.getSelection()
  <span class="comment">// Regex designed to find a word+hyphen before the selected word.
  // Example: ad-|lib|
  // It finds the last chunk with no non-word characters (except for
  // ' and -) before the first selected character.</span> 
  var startRegex = /(\w+'?-?)+-$/g
  <span class="comment">// Regex designed to find a hyphen+word after the selected word.
  // Example: |ad|-lib</span>
  var endRegex = /^-('?-?\w+)+/
  <span class="comment">// Edge case: check if the selection contains no word characters.
  // If so, then don't do anything to extend it.</span>
  var edgeRegex = /\w/

  var range
    , container
    , selectionUpdated

  document.body.ondblclick = selectHyphenatedWords

  function selectHyphenatedWords(event) {
    if (!selection.rangeCount) {
      return
    }
    
    selectionUpdated = false
    range = selection.getRangeAt(0)
    container = range.startContainer
    var string = container.textContent

    if (string.substring(range.startOffset, range.endOffset)
              .search(edgeRegex) &lt; 0) {
      <span class="comment">// There are no word characters selected</span>
      return
    }

    extendSelectionBackBeforeHypen(string, range.startOffset)
    extendSelectionForwardAfterHyphen(string, range.endOffset)

    if (selectionUpdated) {
      selection.removeAllRanges()
      selection.addRange(range)
    }
  }

  function extendSelectionBackBeforeHypen(string, offset) {
    var lastIndex = 0
    var result
      , index
    string = string.substring(0, offset)

    while (result = startRegex.exec(string)) {
      index = result.index
      lastIndex = startRegex.lastIndex
    }

    if (lastIndex === offset) {
      range.setStart(container, index)
      selectionUpdated = true
    }
  }

  function extendSelectionForwardAfterHyphen(string, offset) { 
    if (!offset) {
      return
    }

    string = string.substring(offset)
    var result = endRegex.exec(string)

    if (result) {
      range.setEnd(container, offset + result[0].length)
      selectionUpdated = true
    }
  }
})()</pre>

  <h3>All in one place</h3>
  <p>Because this function is triggered by a double-click, you can be sure that the click occurred with no movement, so the <code>range.startContainer</code> and <code>range.endContainer</code> will be the same. The browser will already have selected the item under the mouse. This might in fact be a space, a punctuation character, or a "word" in English or some other language.</p>
  <p>If something other than a word is selected, there is no point in searching for a hypen in the non-word. The first check is therefore to see if there are any word characters included in the selectionA if not, there is no need to go any further:</p>
  <pre>if (string.substring(range.startOffset, range.endOffset)
          .search(edgeRegex) &lt; 0) {
  return
}</pre>

  <h3>Extending the selection</h3>
  <p>If you click on a word, there are four possibilities:</p>
  <ul>
  <li>The word contains no hyphens: there is nothing more to do</li>
  <li>You double-clicked on the hyphen itself and selected it. To simplify this tutorial, you can ignore this possibility.</li>
  <li>You clicked after the first hyphen in a word, so only the part of the word before the hyphen is selected: you need to extend the selection back to the beginning of the word.</li>
  <li>You clicked before a hyphen in a word, so only the part of the word before the hyphen is selected: you need to extend the selection to the end of the word</li>
  </ul>
  <p>In a word like "day-to-day", if you double-click on "to", then your code needs to extend the selection both forwards and backwards.</p>

  <h3>Extending the selection to the end of the word</h3>
  <p>Extending from the end of the current selection to end of the word is the easier problem to solve, so you can start by looking at that. The technique is to  remove all the characters in the <code>textContent</code> string before the end of the current selection, then check if the remaining characters start with a <code>-</code> followed by an apostrophe or a word character, as defined in <code>endRegex</code>: <code>/^-('?-?\w+)+/</code></p>

  <pre>function extendSelectionForwardAfterHyphen(string, offset) { 
  string = string.substring(offset)
  var result = endRegex.exec(string)

  if (result) {
    range.setEnd(container, offset + result[0].length)
    selectionUpdated = true
  }
}</pre>

  <p>If there is a match, <code>result</code> will be an array containing the matching string. The <code>length</code> of this string determines the distance from the end of the current selection (<code>offset</code>) to the end of the hyphenated word.</p>
  <p>You can use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Range/setEnd"><code>range.setEnd</code></a> to move the end of the selection, but this is not enough to update the selection on the screen. Setting the <code>selectionUpdated</code> flag to <code>true</code> will tell your code to perform a necessary second step in just a moment.</p>

  <h3>Extending the selection back to the beginning of the word</h3>
  <p>Finding the beginning of a hyphenated word is not quite so simple, because in JavaScript, regular expressions can only look forwards, not backwards. A good workaround is to look for <em>all</em> the matches for a string like "xxx-" that occur before the beginning of the current selection, then to test if the <em>last</em> of these matches ends exactly at the selection point. If so, the beginning of that last match indicates the beginning of the hyphenated word.</p>
  <p>When a regular expression object, such as <code>startRegex</code>, is first created, its <code>lastIndex</code> property is set to <code>0</code>. Each time its <code>exec</code> method is called  and a match is found, <code>lastIndex</code> is updated to reflect the position of the end of the match. The next time <code>exec</code> is called, it will start searching for a new match from that point. If the last value of <code><span class="ymmv">regex.</span>lastIndex</code> is <code>offset</code> , then the <code>index</code> property of the <code>results</code> array gives the starting point of the hyphenated word. In this case, you can use the <code><span class="ymmv">range.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Range/setStart">setStart</a></code> method to move the begining of the selection to the beginning of the word:</p>
  <pre>function extendSelectionBackBeforeHypen(string, offset) {
  var lastIndex = 0
  var result
    , index
  string = string.substring(0, offset)

  while (result = startRegex.exec(string)) {
    index = result.index
    lastIndex = startRegex.lastIndex
  }

  if (lastIndex === offset) {
    range.setStart(container, index)
    selectionUpdated = true
  }
}</pre>

  <p>If <code>selectionUpdate</code> is set to <code>true</code>,  because the selection has been extended either forwards or backwards or both, then the <code>Selection</code> range needs to be updated:</p>
  <pre>if (selectionUpdated) {
  selection.removeAllRanges()
  selection.addRange(range)
}</pre>

  <h3>Testing</h3>
  <p>Your current <code>index.html</code> page contains hyphenated words only in the unselectable section. To test your new function, you can add the following to your HTML file:</p>

  <h4><code>index.html</code></h4>
  <pre class="revised">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  <span class="omit">// HTML omitted for clarity</span>
&lt;/head&gt;

&lt;body&gt;
  <span class="omit">// HTML omitted for clarity</span>

  <span class="new">&lt;p&gt;-Double-click to test- 'Use A4-size paper.'
  It's a three-o'clock meet-up. An O'Brian-style decision.
  Я — программист. «Ты говоришь по-русски? Скажи что-нибудь.»&lt;/p&gt;</span>

  &lt;p id="output" class="unselectable">&lt;/p&gt;

  &lt;script src="js/selection.js">&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
  <p>You can save the changes that you have made to <code>selection.js</code> and <code>index.html</code> and relaunch the page in your browser. Try clicking on hyphenated words, on hyphens and other punctuation, and on blank spaces between words, to see what happens.</p>
  
  <div class="test unselectable">
    <a href="source/03_hyphens_w/" target="test">Test Here</a>
  </div>

  <figure>
  <img src="img/selection.png" alt="Composite image showing 3 selections. Hyphenated words in English are selected whole." />
  <figcaption>Figure 4. Composite image showing 3 selections. Hyphenated words in English are selected whole.</figcaption>
  </figure>

  <p>As you can see in Figure 4 above, this solution is not yet perfect. Hyphens in words in other writing scripts (Russian in the example) are not treated the same way as hyphenated words in English.</p>

  <h3>Revising the "word character" regular expression</h3>
  <p>The simple regular expression <code>/\w/</code>, meaning "word character" works well for most text in English, but it fails in languages that use accented Roman characters and in non-Roman scripts. In JavaScript, it is a shorthand for <code>/[0-9A-Za-z_]/</code>. When working in other languages, what you need is an expression that means "any printable character in the ASCII table that is not (not a letter or a number)". Here are all the printable ASCII characters:</p>
  <figure>
  <pre>! " # $ % &amp; ' ( ) * + , - . / 
0 1 2 3 4 5 6 7 8 9 
: ; &lt; = &gt; ? @ 
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
[ \ ] ^ _ ` 
a b c d e f g h i j k l m n o p q r s t u v w x y z 
{ } ~</pre>
  <figcaption>Figure 5: The printable ASCII characters</figcaption>
  </figure>
  <p>To refer to a range of characters for a regular expression pattern, such as "all the letters from A to Z" you can use a pattern like <code><span class="ymmv">/[</span>A-Z<span class="ymmv">]/</span></code>. Some characters, such as <code>/</code> have a special meaning in regular expressions, so to refer to that character as a character, you need to <span class="keyword">esape</span> it by placing a <code>\</code> in front of it. The expression <code>/[!-\/]/</code> will match all the characters from <code>!</code> to <code>/</code> (which needs to be escaped). This corresponds to the top line in the character set shown in Figure 5 above. You can put several ranges one after the other inside the square brackets, so the expression <code>/[!-\/:-@[-`{-~]/</code> will match any printable ASCII character other than a letter or a number.</p>
  <p>You can use the <code>^</code> special character to say "not any of the following characters". So <code>/[^!-\/:-@[-`{-~]</code> means "any character that is not one of the following: !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{}~"</p>

  <h3>Unicode characters for punctuation</h3>
  <p>Even in English, characters outside the ASCII range, such as
  <code>“ ” ‘ ’ …</code> are often used for punctuation. In Russian, quoted speech is shown with guillemets characters: <code>« »</code>. These sets of punctuation marks are contained in two different Unicode blocks: <a href="https://en.wikipedia.org/wiki/List_of_Unicode_characters#Latin-1_Supplement">Latin-1 Supplement</a> and <a href="https://en.wikipedia.org/wiki/List_of_Unicode_characters#Unicode_symbols">Unicode Symbols</a> . The Latin-1 supplements block starts with the non-breaking space, which you might know in HTML terms as <code>&amp;nbsp;</code> and which you can('t) see here: <code>&nbsp;</code>. Putting a blank space in your regular expression can make it difficult to understand, so you might prefer to use the Unicode control code: <code>\u00A0</code> Indeed, you might want to use Unicode control characters to show that you are selecting a whole Unicode block. You can add these two Unicode blocks to your "non word character" expression like this:</p>
  <pre>/[!-\/:-@[-`{-~<span class="new">\u00A0-\u00BF\u2013-\u204A</span>]/</pre>
  <p>... or ...</p>
  <pre>/[!-\/:-@[-`{-~<span class="new">\u00A0-¾―-⁊</span>]/</pre>

  <h3>Matching whitespace</h3>
  <p>All the ASCII characters that create a space on the page but which do not print can be expressed in a regular expression as <code>\s</code>. These characters include:</p>
  <ul>
  <li>space</li>
  <li>carriage return</li>
  <li>line feed</li>
  <li>tab</li>
  </ul>
  <p>To say "all characters except those from European languages that are never found in European words" you can write:</p>
  <pre>/[^\s!-\/:-@[-`{-~\u00A0-\u00BF\u2013-\u204A]/</pre>
  or
  <pre>/[^\s!-\/:-@[-`{-~\u00A0-¾—-⁊]/</pre>
  <p class="aside note">To be applicable to all languages, even outside Europe, a rigorous regular expression would need to include all the punctuation and other non-word characters in any script, such as <code>๏ ๛ 。</code>. In practice, it would make more sense to generate a language-specific regular expression, to match just the languages you expect to encounter.</p>

  <h4><code>js/selection.js</code></h4>
  <pre class="revised">"use strict"

;(function showSelection(){
  <span class="omit">// code omitted for clarity</span>

;(function selectWholeWordsWithHyphens(){
  var selection = window.getSelection()
  // Regex designed to find a word+hyphen before the selected word.
  // Example: ad-|lib|
  // It finds the last chunk with no non-word characters (except for
  // ' and -) before the first selected character. 
  var startRegex = /(<span class="new">[^\s!-\/:-@[-`{-~\u00A0-¾—-⁊]</span>+'?-?)+['-]$/g
  // Regex designed to find a hyphen+word after the selected word.
  // Example: |ad|-lib
  var endRegex = /^['-]('?-?<span class="new">[^\s!-\/:-@[-`{-~\u00A0-¾—-⁊]</span>+)+/
  // Edge case: check if the selection contains no word characters.
  // If so, then don't do anything to extend it.
  var edgeRegex = /<span class="new">[^\s!-\/:-@[-`{-~\u00A0-¾—-⁊]</span>/

  <span class="omit">// code omitted for clarity</span>
})()</pre>

  <h3>Testing the refined regular expression</h3>
  <p>You can now test whether the new regular expression will correctly detect words with hyphens in Russian as well as English.</p>

  <div class="test unselectable">
    <a href="source/03_hyphens/" target="test">Test Here</a>
  </div>

  <div class="aside next">In this section, you've:
    <ul>
      <li>Seen how to find the beginning and end of words that contain a hyphen.</li>
      <li>Manipulated a <code>Range</code> object to modify the current selection</li>
    </ul>
    <p>In particular you have seen:</p>
    <ul>
    <li><code>Selection</code> object
      <ul>
        <li><code><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/removeAllRanges">removeAllRanges</a></code></li>
        <li><code><span class="ymmv">selection.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/addRange">addRange</a></code></li>
      </ul>
    </li>
    <li><code>Range</code> object
      <ul>
        <li><code><span class="ymmv">range.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Range/setStart">setStart</a></code></li>
        <li><code><span class="ymmv">range.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Range/setEnd">setEnd</a></code></li>
      </ul>
    </li>
    <li><code>RegExp</code> object
      <ul>
        <li><code><span class="ymmv">regex.</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec">exec</a>(string)</code></li>
        <li><code><span class="ymmv">string.</span><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/search">search</a>(regex)</code></li>
      </ul>
    </li>
    </ul>
    <p>In the <a href="#jump">next section</a>, you will learn to make the selection jump from one word to the next using the arrow keys.</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#jump">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- JUMP -->
<section id="jump">
  <h2>Jumping to the next word with a keyboard shortcut</h2>
  <p>Over the next 4 sections, you will be creating a feature that moves the selection to the next or previous word using the arrow keys. First, you'll see how to select the next word in a given HTML element. Then in <a href="#next_node">section 5</a> you'll see how to jump forward to the first word in the next <code>textNode</code>. In <a href="#unselect">section 6</a> you'll see how to jump over text where the <code>user-select</code> CSS property is set to <code>none</code>. In <a href="#previous">section 7</a>, when everything is in place for jumping forward, you'll see how to adapt this for jumping backwards with the left arrow.</p>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Detect when the user presses the left or right arrow keys</li>
      <li>Detect the beginning of the next word with lookahead regular expression</li>
      <li>Find the end of the next word with a regular expression</li>
      <li>Use stubs to prepare to add new features to your code</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/04_jump.zip" target="source">Download the source files</a>
  </div>

  <h3>Detecting when the arrow keys are pressed</h3>
  <p>You can detect when the user presses any key with the <code>document.body.onkeydown</code> event. Here's how you can add this to your <code>selection.js</code> file:</p>

  <h4><code>js/selection.js</code></h4>
  <pre class="revised">"use strict"

;(function showSelection(){
  <span class="omit">// code omitted for clarity</span>
})()

;(function selectWholeWordsWithHyphens(){
  var selection = window.getSelection() 
  <span class="omit">// code omitted for clarity</span>

  document.body.ondblclick = selectHyphenatedWords
  <span class="new">document.body.onkeydown = jumpToNextWord</span>

  function selectHyphenatedWords(event) {
    <span class="omit">// code omitted for clarity</span>
  }

  function extendSelectionBackBeforeHypen(string, offset) {
    <span class="omit">// code omitted for clarity</span>
  }

  function extendSelectionForwardAfterHyphen(string, offset) { 
    <span class="omit">// code omitted for clarity</span>
  }

  <span class="new">function jumpToNextWord(event) {
    console.log(event.keyCode, event)
  }</span>
})()</pre>

  <h3>The Keyboard Event object</h3>
  <p>Listeners for the <code>keydown</code> event receive a <code><a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent">KeyboardEvent</a></code> object as an argument. Below are the properties of the <code>KeyboardEvent</code> object that can be used to identify which key was pressed. The main values shown are for the Right Arrow key. The values shown as comments are for the "a" key on a QWERTY keyboard using the standard English.</p>

  <pre>{<span class="omit"> ...</span>
, charCode: 0<span class="comment"> // only used by keypress event</span>
, code: "ArrowRight"<span class="comment"> // "KeyA"</span>
, <span class="omit">...</span>
, key: "ArrowRight"<span class="comment"> // "a"</span>
, <span class="red">keyCode: 39</span><span class="comment"> // 65</span>
, keyIdentifier: "Right"<span class="comment"> // "U+0041"</span>
, <span class="omit">...</span>
, type: "keydown"
, <span class="omit">...</span>
, <span class="red">which: 39</span><span class="comment"> // 65</span>
, <span class="omit">...</span>
}</pre>

  <h3>Switching actions depending on which key was pressed</h3>
  <p>You can use a <code>switch</code> statement to call a specific function based on the key pressed by the user. In the code listing below, the variable <code>rangeData</code> is set to an object only if the left or right arrow is pressed. If <code>rangeData</code> has a value, it is printed out into the Developer Console.</p>

  <h4><code>js/selection.js</code></h4>
  <pre class="revised">"use strict"

;(function showSelection(){
  <span class="omit">// code omitted for clarity</span>
})()

;(function selectWholeWordsWithHyphens(){
  var selection = window.getSelection() 
  <span class="omit">// code omitted for clarity</span>

  var range
    , container
    , selectionUpdated

  document.body.ondblclick = selectHyphenatedWords
  document.body.onkeydown = jumpToNextWord

  <span class="omit">// code omitted for clarity</span>

  function jumpToNextWord(event) {
    <span class="new">var rangeData

    switch (event.keyCode) {
      case 37: <span class="comment">// Left</span>
        rangeData = jumpLeft()
      break
      case 39: <span class="comment">// Right</span>
        rangeData = jumpRight()
    }

    if (!rangeData) {
      return
    }

    console.log(rangeData)</span>
  }

  <span class="new">function jumpLeft() {
    return { action: "Jump Left" }
  }

  function jumpRight() {
    return { action: "Jump Right" }
  }</span>
})()</pre>


<h3>Detecting the next word</h3>
<p>You can use a regular expression to detect the beginning of the next word. Basically, your regular expression will do this:</p>
<ul>
<li>Start at the end of the current word</li>
<li>Match all subsequent non-word characters</li>
<li>Check that the next character is not the end of the string</li>
</ul>
<p>For plain ASCII English, this expression could look like this:</p>
<pre>/\W+(?!\W|$)/</pre>
<p>In other words:</p>
<dl>
  <dt>\w*</dt>
  <dd>Optionally, any word characters (that are unselected in the current word) ...</dd>
  <dt>\W+</dt>
  <dd>... followed by one or more non-word characters ...</dd>
  <dt>(?!<span class="omit">...</span>)</dt>
  <dd>... not followed by ...</dd>
  <dt>\W|$</dt>
  <dd>... either a non-word character or the end of the string</dd>
</dl>
<p>For this to work with strings that use non-ASCII characters, you need to replace <code>\W</code> with <code>[\s!-\/:-@[-`{-~\u00A0-¾—-⁊]</code>, which makes the expression more complex:</p>
<pre>/([^\s!-\/:-@[-`{-~\u00A0-¾—-⁊])*[\s!-\/:-@[-`{-~\u00A0-¾—-⁊])+(?!([\s!-\/:-@[-`{-~\u00A0-¾—-⁊]|$)/</pre>
<p>To find the end of the next word, you can start from the beginning of the word and keep going until you reach a non-word character or the end of the string. In simple terms, you could look for the first match or this expression:</p>
<pre>/\W|$/</pre>
<p>Or, more robustly:</p>
<pre>/[\s!-\/:-@[-`{-~\u00A0-¾—-⁊$]/</pre>

<h3>Using <code>new RegExp()</code> to construct a regular expression</h3>
<p>You're using the sequence <code>\s!-\/:-@[-`{-~\u00A0-¾—-⁊</code> in many different places. You might find it easier to create this sequence just once, and use it multiple times. Here's how your regular expressions currently look:</p>

<pre>var startRegex = /([^\s!-\/:-@[-`{-~\u00A0-¾—-⁊]+'?-?)+['-]$/g
var endRegex = /^['-]('?-?[^\s!-\/:-@[-`{-~\u00A0-¾—-⁊]+)+/
var edgeRegex = /[^\s!-\/:-@[-`{-~\u00A0-¾—-⁊]/</pre>

<p>You can use the <code>new <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp">RegExp</a>()</code> constructor to create a regular expression out of a string.</p>

<p class="aside note">Note that when you create a regular expression from a string, with <code>new RegExp()</code>, you need to <span class="keyword">escape</span> all the <code>\</code> characters that indicate special characters. For example <code>new RegExp("\\s+(?=\\w)")</code> will compile to <code>/\s(?=\w)/</code> </p>

<p>Here's how you can declare your regular expression variables now, including the two new ones:</p>

  <h4><code>js/selection.js</code></h4>
  <pre class="revised"><span class="omit">// code omitted for clarity</span>

;(function selectWholeWordsWithHyphens(){
  var selection = window.getSelection()
  
  <span class="new">var _W = "\\s!-\\/:-@[-`{-~\\u00A0-¾—-⁊"</span>
  var startRegex = <span class="new">new RegExp("([^"+ _W +"]+'?-?)+['-]$", "g")</span>
  var endRegex = <span class="new">new RegExp("^['-]('?-?[^"+ _W +"]+)+")</span>
  var edgeRegex = <span class="new">new RegExp("[^"+ _W +"]")
  
  var nextWordRegex = new RegExp(
    "([^"+ _W +"])*"
  + "(["+ _W +"])+"
  + "(?=[^"+ _W +"])"
  )
  var wordEndRegex = new RegExp("(["+ _W +"$]")</span>

  <span class="omit">// code omitted for clarity</span></pre>
<p>The <code>_W</code> variable can remind you of the <code>\W</code> non-word special character.</p>

<h3>Getting the offset for the beginning and end of the next word</h3>
<p>Now that you have these two new regular expressions, you can use them to populate the <code>rangeData</code> object when the user presses the right arrow.</p>

  <h4><code>js/selection.js</code></h4>
  <pre class="revised">"use strict"

;(function showSelection(){
  <span class="omit">// code omitted for clarity</span>
})()

;(function selectWholeWordsWithHyphens(){
  var selection = window.getSelection()
  
  var _W = "\\s!-\\/:-@[-`{-~\\u00A0-¾—-⁊"
  var startRegex = new RegExp("([^"+ _W +"]+'?-?)+['-]$", "g")
  var endRegex = new RegExp("^['-]('?-?[^"+ _W +"]+)+")
  var edgeRegex = new RegExp("[^"+ _W +"]")
  var nextWordRegex = new RegExp(
    "([^"+ _W +"])*"
  + "(["+ _W +"])+"
  + "(?=[^"+ _W +"])")
  var wordEndRegex = new RegExp("(["+ _W +"$]")

  var range
    , container
    , selectionUpdated

  document.body.ondblclick = selectHyphenatedWords
  document.body.onkeydown = jumpToNextWord

  <span class="omit">// code omitted for clarity</span>

  function jumpToNextWord(event) {
    var rangeData

    <span class="new">if (!selection.rangeCount) {
      return
    } 

    range = selection.getRangeAt(0)</span>

    switch (event.keyCode) {
      case 37: <span class="comment">// Left</span>
        rangeData = jumpLeft()
      break
      case 39: <span class="comment">// Right</span>
        rangeData = jumpRight()
      break
      default:
        return
    }

    if (!rangeData) {
      return
    }

    console.log(rangeData)
  }

  function jumpLeft() {
    return { action: "Jump Left" }
  }

  function jumpRight() {
    <span class="new">container = range.endContainer
    var startOffset = range.endOffset
    var string = container.textContent
    var result = nextWordRegex.exec(string.substring(startOffset))
    var endOffset
      , rangeData

    if (result) {
      startOffset += result[0].length

    } else {
      <span class="comment">// TODO</span>
      return
    }

    result = wordEndRegex.exec(string.substring(startOffset))
    endOffset = startOffset + result.index

    rangeData = {
      container: container
    , startOffset: startOffset
    , endOffset: endOffset
    , string: string
    }

    return rangeData</span>
  }
})()</pre>

<p>First, you need to check that the window's <code>Selection</code> object contains at least one <code>Range</code> object. If not, there is no current selection, so no way to get the next word after that non-existant selection.</p>
<p>If there is a selection, you can use the <code><span class="ymmv">range.</span>endOffset</code> as the starting point of your search. You can take the <code>textContent</code> of the <code><span class="ymmv">range.</span>endContainer</code>, clip all the characters before the end of the current selection, and search for the beginning of the next word in the remainder of the string. If there is no match for <code>nextWordRegex</code>, then the current selection is already the last word in the current HTML textNode.</p>

<h3>Moving the selection to the next word</h3>
<p>If there is a match, then <code>rangeData</code> will contain all the information needed to define the next word ... up to, but not including, any hyphen or apostrophe that the word might contain. To select the next word in its hyphenated entirety, you can simply call  <code>extendSelectionForwardAfterHyphen</code>, and pass it the text content of the current container and the <code>endOffset</code> of the detected word.</p>

  <h4><code>js/selection.js</code></h4>
  <pre class="revised">"use strict"

;(function showSelection(){
  <span class="omit">// code omitted for clarity</span>
})()

;(function selectWholeWordsWithHyphens(){
  var selection = window.getSelection()
  <span class="omit">// code omitted for clarity</span>

  var nextWordRegex = new RegExp(
    "([^"+ _W +"])*"
  + "(["+ _W +"])+"
  + "(?=[^"+ _W +"])")
  var wordEndRegex = new RegExp("(["+ _W +"$]")

  var range
    , container
    , selectionUpdated

  document.body.ondblclick = selectHyphenatedWords
  document.body.onkeydown = jumpToNextWord

  <span class="omit">// code omitted for clarity</span>

  function jumpToNextWord(event) {
    var rangeData

    if (selection.toString === "") {
      return
    } else if (!(range = selection.getRangeAt(0))) {
      return
    }

    switch (event.keyCode) {
      case 37: <span class="comment">// Left</span>
        rangeData = jumpLeft()
      break
      case 39: <span class="comment">// Right</span>
        rangeData = jumpRight()
    }

    <span class="new">if (!rangeData) {
      return
    }

    range.setStart(container, rangeData.startOffset)
    range.setEnd(container, rangeData.endOffset)

    switch (event.keyCode) {
      case 37: <span class="comment">// Left
        // TODO</span>
      break
      case 39: <span class="comment">// Right</span>
        extendSelectionForwardAfterHyphen(
          rangeData.string
        , rangeData.endOffset
        )
      break
    }

    selection.removeAllRanges()
    selection.addRange(range)
  }</span>

  function jumpLeft() {
    <span class="new">// TODO</span>
  }

  function jumpRight() {
    <span class="omit">// code omitted for clarity</span>
  }
})()</pre>

  <div class="test unselectable">
    <a href="source/04_jump/" target="test">Test Here</a>
  </div>

  <div class="aside next">In this section, you've learned how to:
    <ul>
      <li>Use an <code>onkeydown</code> event and a <code><a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent">KeyboardEvent</a></code> object to detect when the user presses the right arrow key</li>
      <li>Write regular expressions for detecting the beginning and end of the next word</li>
      <li>Use the <code>new <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp">RegExp</a>()</code> constructor to compile a regular expression from a string</li>
      <li>Move the selection to the next word, when the user presses the right arrow key, unless the selection is currently in the last word of the text nod that contains it.</li>
    </ul>
    <p>In the <a href="#next_node">next section</a>, you'll see how to shift the selection to the first word in the next text node.</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#next_node">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- NEXT NODE -->
<section id="next_node">
  <h2>Jumping to the first text node in the next element</h2>
  <p>As you saw in the <a href="#jump">last section</a>, it's easy enough to find the next word in a text node. But when you reach the last word in that node, you'll need to jump to the next text node that contains text. This might be a sibling node, or it might be a distant cousin, as shown in Figure 6 below.</p>
  <figure>
  <img src="img/nextNode.png" alt="The path to the next textNode may be simple or complex" />
  <figcaption>Figure 6. The path to the next textNode may be simple or complex</figcaption>
  </figure>
  <p>You're going to need three different techniques to find the next text node.</p>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Find the first node which contains text in a given HTML element</li>
      <li>Find the next sibling node of a given HTML element which contains text</li>
      <li>Move up the HTML element hierarchy until you reach an element which contains text</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/05_next_node.zip" target="source">Download the source files</a>
  </div>

  <h3>HTML tags, textNodes, comments, childNodes and children</h3>
  <p>When you create an HTML <span class="keyword">element</span> using a tag such as <code>&lt;p&gt;&lt;/p&gt;</code>, the actual text of the element is contained in a <span class="keyword">node</span>: a <code>textNode</code>, to be specific. All the prettifying whitespace between your HTML elements is also placed in <code>textNode</code>s, and normally you want to ignore these.</p>
  <p>To access the child <span class="keyword">elements</span> of a given HTML element, you can use the <code><a href="https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/children"></a>children</code> property. Invisible script elements will be included in the array of children.</p>
  <p>To access the <code>textNode</code>s as well as the elements, you can use the <code><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/childNodes"></a>childNodes</code> property, which will also include comment nodes. When looking for words that can be selected, you will want to filter out all script elements, comments and <code>textNode</code>s that contain prettifying whitespace .</p>

  <h3>Top-level test</h3>
  <p>You can start by creating a function that will return a pointer to the first <code>textNode</code> that contains more than just whitespace, in a given HTML element. The function shown below assumes that <code>node.textContent</code> contains at least one non-space character. Soon, you will add a check for this before calling the function.</p>
  <p class='aside tip'>For now, you can put the function at the top level, so that you can call it from the Developer Console. Later, you can place it inside another function, to limit its scope.</p>
 
  <h4><code>js/selection.js</code></h4>
  <pre class="revised">"use strict"

<span class="new">function getFirstTextNode(node) {
  var childNodes = [].slice.call(node.childNodes)

  if (!childNodes.length) {
    return node
  }

  while (node = childNodes.shift()) {
    if (node.textContent.search(/\S/) &lt; 0) {
      <span class="comment">// Skip this node and its children</span>
    } else if (node.nodeType === 3) {
      return node
    } else {
      return getFirstTextNode(node)
    }
  }
}</span>

;(function (){
  <span class="omit">// code omitted for clarity</span>
})()
</pre>

  <h3><code>[].slice.call()</code></h3>
  <p>The property <code><span class="ymmv">node.</span>childNodes</code> is an <span class="keyword">array-like</span> object, but it does not support methods like <code>shift</code>. To convert it to a full array, you can use <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Array-like_objects">Array.prototype.slice.call</a>(<span class="omit">...</span>)</code>, or more compactly but slightly less efficiently, <code>[].slice.call()</code>, as in the code listing above.</p>

  <h3><code>if (!childNodes.length)</code> </h3>
  <p>This function assumes that there is at least one non-space character in the <code>textContent</code> of the node, so if the node has no children, it must be the one containing that non-space text.</p>

  <h3><code>while (node = childNodes.shift())</code></h3>
  <p>For the same reason, if the node does have children, then one of them must contain non-space text. The <code>while</code> loop treats each <code>childNode</code> in turn. If ...</p>
  <ul>
  <li>Its <code>textContent</code> matches the <code>/\S/</code> non-whitespace regular expression AND</li>
  <li>This child node has a <code>nodeType</code> of <code>3</code> (which means <code>textNode</code>)</li>
  </ul>
  <p>... then it will be the <code>textNode</code> you are looking for. If it contains text but is not a <code>textNode</code> then you have to tunnel deeper to find the first of its offspring that <em>is</em> a <code>textNode</code> with non-whitespace text. The <code>getFirstTextNode</code> function does this by calling itself recursively with the child node as its new argument.</p>

  <p>In Figure 6 at the top of this section, the blue lines show how <code>getFirstTextNode</code> will tunnel down from <code>body</code> to <code>textNode 1</code>, and from <code>section 2</code> to <code>textNode 3</code>. If the argument of <code>getFirstTextNode</code> is a textNode containing non-whitespace text, then the argument node itself will be returned.</p>
  <p>You can test this from the Developer Console:</p>

  <figure>
  <pre class="console"><span class="input">getFirstTextNode(document.body)</span>
<span class="output">"Вим ед путант альбюкиюс прёнкипыз, квюо эи выльёт аэтырно бландит, видэ фабыллас майыжтатйж прё экз."</span>
<span class="input">getFirstTextNode(document.querySelector(".box"))</span>
<span class="output">"Lorem ipsum dolor sit amet, consectetur adipiscing elit."</span></pre>
<figcaption>Figure 7. Testing the <code>getFirstTextNode</code> function in the Developer Console</figcaption>
</figure>

  <h3>Finding text content in the next sibling node</h3>
  <p>Now that you can find the first text node in any HTML node, you can find the next text node after any given node by asking for the first text node of its next sibling (the red line in Figure 6). If the current node doesn't have a next sibling, you can climb the hierarchy, and find the closest parent that has a sibling, and get its first text node (the green lines in Figure 6).</p>

  <h3><code>getNextTextNode</code></h3>
  <p>You can add the <code>getNextTextNode</code> function, as shown in the code listing below, to your <code>selection.js</code> file, at the top level, so that you can call it from the Developer Console.</p>
  <p>This new function takes an HTML node and checks each of its following siblings in turn until it finds one that has non-whitespace text content. It then tunnels down into that sibling node, if necessary, to return the first node that contains text. This may be the sibling node itself.</p>
  <p>If it reaches the last sibling node without finding any interesting text nodes, the <code>getNextTextNode</code> function will call itself recursively, to look for siblings of the parent node. It keeps going up the DOM hierarchy until it reaches the <code>document.body</code>, in which case it can go no further, and there are no more text nodes to be found. If this happens, the return value will be undefined.</p>
  
  <h4><code>js/selection.js</code></h4>
  <pre class="revised">use strict"

<span class="new">function getNextTextNode(node) {
  var parentNode = node.parentNode

  while (node = node.nextSibling) {
    if (node.textContent.search(/\S/) &lt; 0) {   
      <span class="comment">// Skip this node and its children</span>
    } else if (node.tagName !== "SCRIPT") {
      <span class="comment">// The next child of current parent has non-empty content</span>
      return getFirstTextNode(node)
    }
  } 

  <span class="comment">// If we get here, there were no more sibling nodes. Try the
  // next sibling of the parent, unless we've reached the last
  // child of the body itself.</span>
  if (parentNode !== document.body) {
    return getNextTextNode(parentNode)
  }
}</span>

function getFirstTextNode(node) {
  var childNodes = [].slice.call(node.childNodes)

  if (!childNodes.length) {
    return node
  }

  while (node = childNodes.shift()) {
    if (node.textContent.search(/\S/) &lt; 0) {
      <span class="comment">// Skip this node and its children</span>
    } else if (node.nodeType === 3) {
      return node
    } else {
      return getFirstTextNode(node)
    }
  }
}

;(function (){
  <span class="omit">// code omitted for clarity</span>
})()</pre>

  <h3>Integrating these new functions into <code>jumpRight</code></h3>
  <p>With these new functions in place, your can add ...</p>
  <pre>container = getNextTextNode(container)</pre>
  <p>... to the <code>jumpRight</code> function, for the case where the currently selected word is the last word of the current container. You'll then need to find the start of the first word in the new container, and then proceed with finding the end of the word just as you did before.</p>
  <p>There may be some prettifying whitespace before the first word in the text node. You can create a new regular expression ...</p>
  <pre>var wordStartRegex = new RegExp("[^" + _W + "]")</pre>
  <p>... to find the first non-whitespace character, which will be the beginning of the first word.</p>
  <p>The code listing below shows the code to replace the <code>// TODO</code> placeholder in the <code>jumpRight</code> function. Notice that <code>getFirstTextNode</code> can be placed inside <code>getNextTextNode</code>. You could also place <code>getNextTextNode</code> inside the <code>jumpRight</code> function, but later, you will be converting it to a <code>getAdjacentTextNode</code> function, which you will be able to use to jump both right and left. For this reason, it's better to put it at the same level as the <code>jumpRight</code> function, so that the forthcoming <code>jumpLeft</code> function can use it, too.</p>
  
  <h4><code>js/selection.js</code></h4>
  <pre><span class="revised">"use strict"

;(function showSelection(){
  <span class="omit">// code omitted for clarity</span>
})()

;(function selectWholeWordsWithHyphens(){
  var selection = window.getSelection()
  var _W = "\\s!-\\/:-@[-`{-~\\u00A0-¾—-⁊"
  var startRegex = new RegExp("([^" + _W + "]+'?-?)+['-]$", "g")
  var endRegex = new RegExp("^['-]('?-?[^" + _W + "]+)+")
  var edgeRegex = new RegExp("[^" + _W + "]")
  var nextWordRegex = new RegExp(
    "([^"+ _W +"])*"
  + "(["+ _W +"])+"
  + "(?=[^"+ _W +"])"
  )</span>
  <span class="new">var wordStartRegex = new RegExp("[^" + _W + "]")</span>
  <span class="revised">var wordEndRegex = new RegExp("[" + _W + "$]")

  var range
    , container
    , selectionUpdated

  document.body.ondblclick = selectHyphenatedWords
  document.body.onkeydown = jumpToNextWord

  function selectHyphenatedWords(event) {
    <span class="omit">// code omitted for clarity</span>
  }

  function extendSelectionBackBeforeHypen(string, offset) {
    <span class="omit">// code omitted for clarity</span>
  }

  function extendSelectionForwardAfterHyphen(string, offset) { 
    <span class="omit">// code omitted for clarity</span>
  }

  function jumpToNextWord (event) {   
    <span class="omit">// code omitted for clarity</span>
  }

  function jumpLeft() {
    // TODO
  }

  function jumpRight() {
    container = range.endContainer
    var startOffset = range.endOffset
    var string = container.textContent
    var result = nextWordRegex.exec(string.substring(startOffset))
    var endOffset
      , rangeData

    if (result) {
      startOffset += result[0].length

    } else {</span>
      <span class="new"><span class="comment">// There are no more words in this text node. Try the next.</span>
      container = getNextTextNode(container)

      if (container) {
        string = container.textContent
        result = wordStartRegex.exec(string)
        startOffset = result.index

      } else {
        <span class="comment">// We're at the very end of the selectable text.
        // There's nothing more to select.</span>
        return
      }</span>
    }

    <span class="revised">result = wordEndRegex.exec(string.substring(startOffset))
    endOffset = startOffset + result.index

    rangeData = {
      startOffset: startOffset
    , endOffset: endOffset
    , string: string
    }

    return rangeData</span>
  }

  function getNextTextNode(node) {
    var parentNode = node.parentNode

    while (node = node.nextSibling) {
      if (node.textContent.search(/\S/) &lt; 0) {         
      } else if (node.tagName !== "SCRIPT") {
        <span class="comment">// The next child of current parent has non-empty
        // content</span>
        return getFirstTextNode(node)
      }
    } 

    <span class="comment">// If we get here, there were no more sibling nodes. Try the
    // next sibling of the parent, unless we've reached the last
    // selectable child of the body itself.</span>
    if (parentNode !== document.body) {
      return getNextTextNode(parentNode)
    }

    function getFirstTextNode(node) {
      var childNodes = [].slice.call(node.childNodes)

      if (!childNodes.length) {
        return node
      }

      while (node = childNodes.shift()) {
        if (node.textContent.search(/\S/) &lt; 0) {         
        } if (node.nodeType === 3) {
          return node
        } else {
          return getFirstTextNode(node)
        }
      }
    }
  }
})()</pre>

  <div class="test unselectable">
    <a href="source/05_next_node/" target="test">Test Here</a>
  </div>

  <p class="aside warn">There is a major flaw in this implementation: you can use the right arrow key to jump to words that are not selectable with the mouse; when you do this, the selection highlight vanishes. More dramatically (but only in this context), if you select the last selectable word and press the right arrow key, a word in the (unselectable) data about the selection will become selected, and the contents of the unselectable data will be displayed inside itself, in a loop that continually adds more text to the page. You'll see how to deal with this issue in the next section.</p>

  <div class="aside next">In this section, you've seen how to 
    <ul>
      <li>Use a <code>while</code> loop and recursion to find the first text node in a given HTML element</li>
      <li>Use a <code>while</code> loop and recursion to find the next text node in a sibling or the sibling of a parent</li>
      <li>Jump to the next text node when the last word in the current text node is selected and the right arrow key is pressed</li>
    </ul>
    <p>In particular, you've seen the following expressions:</p>
    <ul>
    <li><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Array-like_objects">[].slice.call</a></code><span class="ymmv">(...)</span></li>
    <li><code><span class="ymmv">array.</span><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/shift">shift</a><span class="ymmv">(...)</span></code></li>
    <li><code><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/while">while</a><span class="ymmv"> (...) {...}</span></code></li>
    <li><code><span class="ymmv">node.</span><a href="https://developer.mozilla.org/en/docs/Web/API/Node/nodeType">nodeType</a></code></li>
    <li><code><span class="ymmv">node.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/parentNode">parentNode</a></code></li>
    <li><code><span class="ymmv">node.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/childNodes">childNodes</a></code></li>
    </ul>
    <p>In the <a href="#unselect">next section</a>, you'll see how to avoid jumping to text nodes that have been made unselectable.</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#unselect">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- unselect -->
<section id="unselect">
  <h2>Detecting unselectable nodes</h2>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Use JavaScript to read the CSS rules applied to a given node</li>
      <li>Check whether a particular CSS property has been set to a particular value</li>
      <li>Modify the <code>getNextTextNode</code> and <code>getFirstTextNode</code> functions to avoid unselectable text nodes</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/06_unselect.zip" target="source">Download the source files</a>
  </div>

  <h3>Accessing CSS from JavaScript</h3>
  <p>You can use <code>window.<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle">getComputedStyle</a>(<span class="ymmv">element</span>)</code> to obtain a <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration">CSSStyleDeclaration</a> which gives you access to all the CSS property-value pairs that apply to the element. To determine whether the element has been made unselectable, you can check whether it has a <code>user-select</code> property set to <code>none</code>.</p>
  <p>Actually, it's not quite as simple as that: the official specifications for the <code><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/user-select">user-select</a></code> property have not been finalized, so each browser vendor implements the property in its own way, and uses a vendor prefix to indicate that the feature is subject to change and may differ from browser to browser.</p>
  <p>As a result, you will need to check for "-webkit-user-select", "-moz-user-select", and other properties. This is all dealt with for you in the <code>elementIsSelectable</code> function in the code listing below. In order to test it easily, you can place it at the top level of your <code>selection.js</code> script.</p>

  <h4><code>js/selection.js</code></h4>
  <pre class="revised">"use strict"

<span class="new">function elementIsSelectable(element) {
  var prefixes = [
    "-webkit-"
  , "-khtml-"
  , "-moz-"
  , "-ms-"
  , ""
  ]
  var style = window.getComputedStyle(element)

  var selectable = prefixes.every(function check(key) {
    key += "user-select"
    return style[key] !== "none"
  })

  return selectable
}</span>

;(function (){
  <span class="omit">// code omitted for clarity</span>
})()</pre>

  <h3>Testing</h3>
  <p>You can test that it is working from the Developer Console.</p>

  <figure>
  <pre class="console"><span class="input">elementIsSelectable(document.body)</span>
<span class="output">true</span>
<span class="input">elementIsSelectable(document.querySelector(".box"))</span>
<span class="output">true</span>
<span class="input">elementIsSelectable(document.querySelector(".unselectable"))</span>
<span class="output">false</span></pre>
<figcaption>Figure 8. Testing the <code>elementIsSelectable</code> function in the Developer Console</figcaption>
  </figure>

  <h3>CSS and textNodes</h3>
  <p>Another complexity is that <code>window.getComputedStyle()</code>functions only on HTML elements and <code>textNodes</code> are not HTML elements. You need to ask for the <code>textNode</code>'s <code>parentNode</code>'s computed style.</p>

  <p>In the code listing below, the <code>getFirstTextNode</code> is modified to return a node only if it is selectable. This means that, although the node contains non-whitespace text, the function may not return a value. As a result, the <code>getNextTextNode</code> function has to play it safe and check whether the call to <code>getFirstTextNode</code> returned a value or not.</p>
  <p>For tidiness, the <code>elementIsSelectable</code> function has been moved inside the <code>selectWholeWordsWithHyphens</code> function, so it will no longer be accessible from the Developer Console.</p>

  <h4><code>js/selection.js</code></h4>
  <pre><span class="revised">"use strict"

;(function showSelection(){ 
  <span class="omit">// code omitted for clarity</span>
})()

;(function selectWholeWordsWithHyphens(){
    <span class="omit">// code omitted for clarity</span>
  }

  function extendSelectionBackBeforeHypen(string, offset) {
    <span class="omit">// code omitted for clarity</span>
  }

  function extendSelectionForwardAfterHyphen(string, offset) { 
    <span class="omit">// code omitted for clarity</span>
  }

  function jumpToNextWord (event) {
    <span class="omit">// code omitted for clarity</span>
  }

  function jumpLeft() {
    // TODO
  }

  function jumpRight() {
    <span class="omit">// code omitted for clarity</span>
  }

  function getNextTextNode(node) {
    var parentNode = node.parentNode
    <span class="new">var nextNode</span>

    while (node = node.nextSibling) {
      if (node.textContent.search(/\S/) &lt; 0) {         
      } else if (node.tagName !== "SCRIPT") {
        // The next child of current parent has non-empty content
        <span class="new">nextNode = getFirstTextNode(node)
        if (nextNode) {
          return nextNode
        }</span>
      }
    } 

    // If we get here, there were no more sibling nodes. Try the
    // next sibling of the parent, unless we've reached the last
    // selectable child of the body itself.
    if (parentNode !== document.body) {
      return getNextTextNode(parentNode)
    }

    function getFirstTextNode(node) {
      var childNodes = [].slice.call(node.childNodes)

      if (!childNodes.length) {
        return node
      }

      while (node = childNodes.shift()) {
        if (node.textContent.search(/\S/) &lt; 0) {         
        } else if (node.nodeType === 3) {
          <span class="new">if (elementIsSelectable(node.parentNode)) {
            return node
          }</span>
        } else {
          return getFirstTextNode(node)
        }
      }
    }
  }</span>

  function elementIsSelectable(element) {
    var prefixes = [
      "-webkit-"
    , "-khtml-"
    , "-moz-"
    , "-ms-"
    , ""
    ]
    var style = window.getComputedStyle(element)

    var selectable = prefixes.every(function check(key) {
      key += "user-select"
      return style[key] !== "none"
    })

    return selectable
  }
<span class="revised">})()</span></pre>

  <div class="test unselectable">
    <a href="source/06_unselect/" target="test">Test Here</a>
  </div>

  <p>Now when you test your script, you'll find that the selection jumps directly from "eros" to "Integer", and that it does not move when you get to the final word.</p>

  <div class="aside next">In this section, you've prevented the <code>getNextTextNode</code> function from setting the range of the <code>Selection</code> object to a chunk of text that cannot be selected. Your work on jumping forward is complete.
  <p>In the <a href="#previous">next section</a>, you'll see how to create similar functions for jumping back to the previous word when you press the left arrow key.</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#previous">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- PREVIOUS -->
<section id="previous">
  <h2>Jumping to the previous word</h2>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Adapt the <code>jumpRight</code> function to create a <code>jumpLeft</code> function</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/07_previous.zip" target="source">Download the source files</a>
  </div>

  <h3>Jumping Left</h3>
  <p>The code you need to write to jump backwards uses the same techniques that you have already seen. As you saw with the selection of hyphenated words, searching backwards needs to be conceived of as "searching forwards until the last match is found".</p>
  <p>To do that, you need to create a new regular expression ...</p>
  <pre>new RegExp("([^"+ _W +"])+", "g")</pre>
  <p>... where <code>_W</code> is the comprehensive "non-word-character" expression that you've already used. The <code>"g"</code> flag means that multiple uses of the <code><span class="ymmv">regex.</span>exec(<span class="ymmv">string</span>)</code> method will start searching from the end of the last match.</p>
  <p>The changes in the code listing below allow you use the left arrow key to jump back, word by word, to the beginning of a textNode. The code for jumping back to the previous text node will be shown later. Where the new code is identical to the code in the <code>jumpRight</code> function, it's shown in plain (not <strong>bold</strong>) characters.</p>

  <h4><code>js/selection.js</code></h4>
  <pre><span class="revised">"use strict"

;(function showSelection(){
  <span class="omit">// code omitted for clarity</span>
})()

;(function selectWholeWordsWithHyphens(){
  var selection = window.getSelection()
  var _W = "\\s!-\\/:-@[-`{-~\\u00A0-¾—-⁊"
  var startRegex = new RegExp("([^" + _W + "]+'?-?)+['-]$", "g")
  var endRegex = new RegExp("^['-]('?-?[^" + _W + "]+)+")
  var edgeRegex = new RegExp("[^" + _W + "]")
  <span class="new">var lastWordRegex = new RegExp("([^"+ _W +"])+", "g")</span>
  var nextWordRegex = new RegExp(
    "([^"+ _W +"])*"
  + "(["+ _W +"])+"
  + "(?=[^"+ _W +"])"
  )
  var wordStartRegex = new RegExp("[^" + _W + "]")
  var wordEndRegex = new RegExp("[" + _W + "]|$")

  var range
    , container
    , selectionUpdated

  document.body.ondblclick = selectHyphenatedWords
  document.body.onkeydown = jumpToNextWord

  function selectHyphenatedWords(event) {
    <span class="omit">// code omitted for clarity</span>
  }

  function extendSelectionBackBeforeHypen(string, offset) {
    <span class="omit">// code omitted for clarity</span>
  }

  function extendSelectionForwardAfterHyphen(string, offset) { 
    <span class="omit">// code omitted for clarity</span>
  }

  function jumpToNextWord (event) {
    var rangeData

    if (!selection.rangeCount) {
      return
    } else if (!(range = selection.getRangeAt(0))) {
      return
    }

    switch (event.keyCode) {
      case 37: <span class="comment">// Left</span>
        rangeData = jumpLeft()
      break
      case 39: <span class="comment">// Right</span>
        rangeData = jumpRight()
    }

    if (!rangeData) {
      return
    }

    range.setStart(container, rangeData.startOffset)
    range.setEnd(container, rangeData.endOffset)

    switch (event.keyCode) {
      case 37: </span><span class="comment">// Left</span>
        <span class="new">extendSelectionBackBeforeHypen</span>(
          rangeData.string
        , rangeData.<span class="new">startOffset</span>
      <span class="revised">break
      case 39: <span class="comment">// Right</span>
        extendSelectionForwardAfterHyphen(
          rangeData.string
        , rangeData.endOffset
        )
      break
    }

    selection.removeAllRanges()
    selection.addRange(range)
  }

  function jumpLeft() {</span>
    container = range.<span class="new">startContainer</span>
    var string = container.textContent
    var result = <span class="new">getPreviousWord(string, range.startOffset)</span>
    var startOffset
      , endOffset
      , rangeData

    if (!result) {
      <span class="comment">// There are no more words in this text node. Try the next.</span>
      container = <span class="new">getPreviousTextNode</span>(container)

      if (container) {
        string = container.textContent
        result = <span class="new">getPreviousWord(string, string.length)</span>

      } else {
        <span class="comment">// We're at the very beginning of the selectable text.
        // There's nothing earlier to select.</span>
        return
      }
    }

    <span class="new">startOffset = result.index</span>
    endOffset = <span class="new">startOffset + result[0].length</span>

    rangeData = {
      container: container
    , startOffset: startOffset
    , endOffset: endOffset
    , string: string
    }

    return rangeData

    <span class="new">function getPreviousWord(string, offset) {
      string = string.substring(0, offset)
      var result
        , temp

      while (temp = lastWordRegex.exec(string)) {
        result = temp
      }

      return result
    }</span>
  }

  function get<span class="new">Previous</span>TextNode(node) {
    <span class="comment">// TODO</span>
  }

  <span class="revised">function jumpRight() {
    <span class="omit">// code omitted for clarity</span>
  }

  function getNextTextNode(node) {
    <span class="omit">// code omitted for clarity</span>
  }

  function elementIsSelectable(element) {
    <span class="omit">// code omitted for clarity</span>
  }
})()</span></pre>

  <h3><code>getPreviousWord</code></h3>
  <p>The most major change in the code listing above is the addition of the <code>getPreviousWord</code> function, which repeatedly searches for matches for <code>lastWordRegex</code>. If any are found, the <code>result</code>  of the last match is returned. (For <code>jumpRight</code> searching forward is done with a single match in a single line).</p>

  <h3>Finding the previous text node</h3>
  <p>Searching backwards through siblings is easier than searching backwards through text: there is a built-in <code>previousSibling</code> property for all nodes. Below, you can see how similar the code for </p>

  <h4><code>js/selection.js</code></h4>
  <pre><span class="revised">"use strict"

;(function showSelection(){
  <span class="omit">// code omitted for clarity</span>
})()

;(function selectWholeWordsWithHyphens(){
  <span class="omit">// code omitted for clarity</span>

  function jumpLeft() {
    container = range.endContainer
    var string = container.textContent
    var result = getPreviousWord(string, range.startOffset)
    var startOffset
      , endOffset
      , rangeData

    if (!result) {
      // There are no more words in this text node. Try the next.
      container = getPreviousTextNode(container)

      if (container) {
        string = container.textContent
        result = getPreviousWord(string, string.length)

      } else {
        // We're at the very beginning of the selectable text.
        // There's nothing earlier to select.
        return
      }
    }

    <span class="omit">// code omitted for clarity</span>

    return rangeData

    <span class="omit">// code omitted for clarity</span>  
  }</span>

  function get<span class="new">Previous</span>TextNode(node) {
    var parent = node.parentNode
    var <span class="new">previousNode</span>

    while (node = node.<span class="new">previousSibling</span>) {
      if (node.textContent.search(/\S/) &lt; 0) {         
      } else if (node.tagName !== "SCRIPT") {
        <span class="comment">// The previous child of current parent has non-empty
        // content but it might not be selectable</span>      
        <span class="new">previousNode</span> = <span class="new">getLastTextNode</span>(node)

        if (<span class="new">previousNode</span>) {
          return <span class="new">previousNode</span>
        }
      }
    } 

    <span class="comment">// If we get here, there were no more sibling nodes. Try the 
    // previous sibling of the parent, unless we've reached the first
    // selectable child of the body itself</span>
    if (parent !== document.body) {
      return get<span class="new">Previous</span>TextNode(parent)
    }

    function get<span class="new">Last</span>TextNode(node) {
      var childNodes = [].slice.call(node.childNodes)

      if (!childNodes.length) {
        return node
      }

      while (node = childNodes.<span class="new">pop</span>()) {
        if (node.textContent.search(/\S/) &lt; 0) {         
        } else if (node.tagName !== "SCRIPT") {
          if (node.nodeType === 3) {
            if (elementIsSelectable(node.parentNode)) {
              return node
            }
          } else {
            node = get<span class="new">Last</span>TextNode(node)
            if (node) {
              return node
            }
          }
        }
      }
    }
  }

  <span class="omit">// code omitted for clarity</span>
})()</pre>

  <h3>Simplifying the code</h3>
  <p>As you can see from the quantity of plain black text in the code listing above, there are many similarities between <code>getNextTextNode</code> and <code>getPreviousTextNode</code>. You can merge these two into one function called <code>getAdjacentTextNode</code>, as shown in the code listing below.</p>

  <h4><code>js/selection.js</code></h4>
  <pre>  function get<span class="new">AdjacentText</span>Node(node, <span class="new">whichSibling, arrayMethod</span>) {
    // &lt;whichSibling&gt; will be "previousSibling" or "nextSibling"
    // &lt;arrayMethod&gt; will be "pop" or "shift"

    var parent = node.parentNode
    var <span class="new">adjacentNode</span>

    while (node = node[<span class="new">whichSibling</span>]) {
      if (node.textContent.search(/\S/) &lt; 0) {         
      } else if (node.tagName !== "SCRIPT") {
        // The adjacent child of current parent has non-empty
        // content but it might not be selectable
        
        <span class="new">adjacentNode</span> = get<span class="new">End</span>Node(node, <span class="new">arrayMethod</span>)

        if (<span class="new">adjacentNode</span>) {
          return <span class="new">adjacentNode</span>
        }
      }
    } 

    // If we get here, there were no more sibling nodes. Try the 
    // adjacent sibling of the parent, unless we've reached the
    // farthest selectable child of the body itself 
    if (parent !== document.body) {
      return get<span class="new">Adjacent</span>TextNode(parent, <span class="new">whichSibling, arrayMethod</span>)
    }

    function get<span class="new">End</span>Node(node, <span class="new">arrayMethod</span>) {
      var childNodes = [].slice.call(node.childNodes)

      if (!childNodes.length) {
        return node
      }

      while (node = childNodes[<span class="new">arrayMethod</span>]()) {
        if (node.textContent.search(/\S/) &lt; 0) {        
        } else if (node.tagName !== "SCRIPT") {
          if (node.nodeType === 3) {
            if (elementIsSelectable(node.parentNode)) {
              return node
            }
          } else {
            node = get<span class="new">End</span>Node(node, arrayMethod)
            if (node) {
              return node
            }
          }
        }
      }
    }
  }</pre>

  <p>After this change, the <code>jumpLeft</code> and <code>jumpRight</code> functions need to look like this:</p>

  <h4><code>js/selection.js</code></h4>
  <pre class="revised"><span class="omit">...</span>

  function jumpLeft() {
    container = range.endContainer
    var string = container.textContent
    var result = getPreviousWord(string, range.startOffset)
    var startOffset
      , endOffset
      , rangeData

    if (!result) {
      // There are no more words in this text node. Try the next.
      container = <span class="new">getAdjacentTextNode(
        container
      , "previousSibling"
      , "pop"
      )</span>

      if (container) {
        <span class="omit">// code omitted for clarity</span>
      }
    }

    <span class="omit">// code omitted for clarity</span>

    return rangeData

    function getPreviousWord(string, offset) {
      <span class="omit">// code omitted for clarity</span>
    }
  }

  function jumpRight() {
    container = range.endContainer
    var startOffset = range.endOffset
    var string = container.textContent
    var result = nextWordRegex.exec(string.substring(startOffset))
    var endOffset
      , rangeData

    if (result) {
      startOffset += result[0].length

    } else {
      // There are no more words in this text node. Try the next.
      container = <span class="new">getAdjacentTextNode(
        container
      , "nextSibling"
      , "shift"
      )</span>

      if (container) {
        <span class="omit">// code omitted for clarity</span>
      }
    }

    <span class="omit">// code omitted for clarity</span>

    return rangeData
  }

<span class="omit">...</span></pre>

  <div class="test unselectable">
    <a href="source/07_previous/" target="test">Test Here</a>
  </div>

  <div class="aside next">In this section, you've ...
    <ul>
      <li>Added a new regular expression to help find the end of the previous word in a string</li>
      <li>Adapted the <code>jumpLeft</code> function to mirror the behavior of the <code>jumpRight</code> function</li>
      <li>Added a new <code>getPreviousTextNode</code> function</li>
      <li>Replaced both the <code>getPreviousTextNode</code> and the <code>getNextTextNode</code> with a generic <code>getAdjacentTextNode</code> which requires two additional arguments.</li>
    </ul>
    <p>You can now use the arrow keys to move backwards and forwards in the text, selecting hyphenated words whole. However, there are two minor issues to handle: scrolling the page or the parent element to keep the selection in view, and limiting the word selection feature to one HTML element.</p>
    <p>In the <a href="#scroll">next section</a>, you'll see how to detect where the current selection is on the page, and how to scroll the page to ensure that it is visible.</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#scroll">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- scroll -->
<section id="scroll">
  <h2>Scrolling the selection into view</h2>
  <p>Currently, if you use the left and right arrow keys to move the selection from word to word, the current selection may be outside the visible area of the window. It would be nice to scroll the window to make the selection visible.</p>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>User <code>range.getBoundingClientRect</code> to get the coordinates of the selection area relative to the window</li>
      <li>Set the <code>scrollTop</code> of the window to ensure that the selection is in view</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/08_scroll.zip" target="source">Download the source files</a>
  </div>

  <h3><code>getBoundingClientRect</code></h3>
  <p>The <code><span class="ymmv">element.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect"></a>getBoundingClientRect</code> returns an <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIDOMClientRect">object</a> that tells you the ...</p>
  <ul>
  <li><code>bottom</code></li>
  <li><code>height</code></li>
  <li><code>left</code></li>
  <li><code>right</code></li>
  <li><code>top</code></li>
  <li><code>width</code></li>
  <li></li>
  </ul>
  <p>... of the element, in pixels, relative to area visible in the browser window. In most browsers, the <code>Range</code> object also responds to the <code>getBoundingClientRect</code> method, so you can use this to detect where the selection appears in the browser window.</p>

  <h3><code>scrollTop</code></h3>
  <p>For scrollable elements, setting <code><span class="ymmv">element.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop">scrollTop</a></code> will change the number of pixels hidden above the top of the element. In this section, you will be setting the <code>scrollTop</code> of the document itself. Some browsers (such as Firefox), do this by changing <code>document.documentElement.scrollTop</code>; others (such as Chrome) continue to use the deprecated <code>document.body.scrollTop</code>, even in strict mode. Setting the <code>scrollTop</code> of the wrong element will have no effect. The simplest solution is to set both, and let the best one win.</p>
  <p class="aside info">You can read more about this issue <a href="http://stackoverflow.com/a/20060513/1927589">here</a></p>
  <p>You can add the following function to your JavaScript file:</p>

  <h4><code>js/selection.js</code></h4>
  <pre class="revised">"use strict"

;(function showSelection(){
  <span class="omit">// code omitted for clarity</span>
})()

;(function selectWholeWordsWithHyphens(){
  <span class="omit">// code omitted for clarity</span>

  <span class="new">function scrollIntoView(range) {
    if (!range.getBoundingClientRect) {
      return
    }
    
    var rect = range.getBoundingClientRect()
    var viewHeight = document.documentElement.clientHeight

    if (rect.top &lt; 0) {
      document.body.scrollTop += rect.top
      document.documentElement.scrollTop += rect.top
    } else if (rect.bottom > viewHeight) {
      document.body.scrollTop += rect.bottom - viewHeight
      document.documentElement.scrollTop += rect.bottom - viewHeight
    }
  }</span>
})()</pre>

  <h3>Scrolling into view on <code>dblclick</code> and when the arrow keys are used </h3>
  <p>To trigger the <code>scrollIntoView</code> function after selecting a word with a double-click or after moving the selection to the next word with left or right arrow keys, you need to add two calls to <code>scrollIntoView</code>: one at the end of the <code>selectHyphenatedWords</code> function, and one at the end of the <code>jumpToNextWord</code> function, as shown below:</p>

  <h4><code>js/selection.js</code></h4>
  <pre class="revised">"use strict"

;(function showSelection(){
  <span class="omit">// code omitted for clarity</span>
 }

;(function selectWholeWordsWithHyphens(){
  <span class="omit">// code omitted for clarity</span>

  document.body.ondblclick = selectHyphenatedWords
  document.body.onkeydown = jumpToNextWord

  <span class="omit">// code omitted for clarity</span>

  function selectHyphenatedWords(event) {
    <span class="omit">// code omitted for clarity</span>

    extendSelectionBackBeforeHypen(string, range.startOffset)
    extendSelectionForwardAfterHyphen(string, range.endOffset)

    if (selectionUpdated) {
      selection.removeAllRanges()
      selection.addRange(range)
    }

    <span class="new">scrollIntoView(range)</span>
  }

  function extendSelectionBackBeforeHypen(string, offset) {
    <span class="omit">// code omitted for clarity</span>
  }

  function extendSelectionForwardAfterHyphen(string, offset) { 
    <span class="omit">// code omitted for clarity</span>
  }

  function jumpToNextWord (event) {
    <span class="omit">// code omitted for clarity</span>

    selection.removeAllRanges()
    selection.addRange(range)
    <span class="new">scrollIntoView(range)</span>
  }

  <span class="omit">// code omitted for clarity</span>
}</pre>

  <div class="test unselectable">
    <a href="source/08_scroll/" target="test">Test Here</a>
  </div>

  <div class="aside next">In this section, you've used ...
    <ul>
      <li><code><span class="ymmv">range.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect">getBoundingClientRect</a></code></li>
      <li>a <code><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIDOMClientRect">ClientRect or DOMRect</a> object</code></li>
      <li><code><span class="ymmv">element.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop">scrollTop</a></code></li>
    </ul>
    <p>... to activate a function that automatically scrolls the page to show the current selection.</p>
    <p>In the <a href="#nested-scroll">next section</a>, you'll see how to ensure that the selection is visible even when it is inside a sub-element of the page that can itself scroll.</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#nested-scroll">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- NESTED SCROLL -->
<section id="nested-scroll">
  <h2>Scrolling a sub-element of the page</h2>
  <div class="aside preview">In this section, you'll see how to:
    <ul>
      <li>Adapt your <code>index.html</code> to create a series of nested scrolling elements</li>
      <li>Extend the <code>scrollIntoView</code> function so that the selection will appear in the window, no matter how deep it is nested in scrolling elements</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/09_subscroll.zip" target="source">Download the source files</a>
  </div>

  <p>To make your <code>scrollIntoView</code> function work in all cases, you can add recursive function to scroll all the intermediate layers between your selection range and the body of your page. The <code>scrollChildIntoView</code> function below will get every scrollable parent to set its <code>scrollTop</code> so that the selection is visible within its viewport. Finally, it will call the <code>scrollWindow</code> function which will finish up the process by moving the selection into the viewport of the window itself.</p>

  <h4><code>js/selection.js</code></h4>
  <pre><span class="revised">"use strict"

;(function showSelection(){
  <span class="omit">// code omitted for clarity</span>
})()

;(function selectWholeWordsWithHyphens(){
  <span class="omit">// code omitted for clarity</span>

  document.body.ondblclick = selectHyphenatedWords
  document.body.onkeydown = jumpToNextWord

  function selectHyphenatedWords(event) {
    <span class="omit">// code omitted for clarity</span>

    if (selectionUpdated) {
      selection.removeAllRanges()
      selection.addRange(range)
    }</span>

    scrollIntoView(range)
  <span class="revised">}

  <span class="omit">// code omitted for clarity</span>

  function jumpToNextWord (event) {
    <span class="omit">// code omitted for clarity</span>

    selection.removeAllRanges()
    selection.addRange(range)</span>
    scrollIntoView(range)
  <span class="revised">}

  <span class="omit">// code omitted for clarity</span>

  function scrollIntoView(range) {
    if (!range.getBoundingClientRect) {
      return
    }
    
    var rect = range.getBoundingClientRect()
    <span class="new">var parentNode = range.startContainer.parentNode
    scrollChildIntoView(parentNode, rect.top, rect.bottom)
  }

  function scrollChildIntoView(parentNode, top, bottom) {
    var parentRect = parentNode.getBoundingClientRect()
    var topAdjust = parentRect.top - top
    var adjust = parentRect.bottom - bottom

    if (topAdjust > 0) {
      adjust = topAdjust
      parentNode.scrollTop -= adjust

    } else if (adjust &lt; 0) {
      adjust = Math.max(adjust, topAdjust)
      parentNode.scrollTop -= adjust
    } else {
      adjust = 0
    }

    parentNode = parentNode.parentNode
    top += adjust
    bottom += adjust
    if (parentNode !== document.body) {
      scrollChildIntoView(parentNode, top, bottom)
    } else {
      scrollWindow(top, bottom)
    }
  }

  function scrollWindow(top, bottom) {</span>
    var viewHeight = document.documentElement.clientHeight

    if (<span class="new">top</span> &lt; 0) {
      document.body.scrollTop += <span class="new">top</span>
      document.documentElement.scrollTop += <span class="new">top</span>
    } else if (bottom > viewHeight) {
      document.body.scrollTop += <span class="new">bottom</span> - viewHeight
      document.documentElement.scrollTop += <span class="new">bottom</span> - viewHeight
    }
  }
})()</span></pre>

  <h3>Adding scrolling items to the HTML page</h3>
  <p>Currently all the HTML elements in your <code>index.html</code> page appear one beneath the other. To test that the new <code>scrollIntoView</code> code works correctly, you can modify your <code>index.html</code> page as shown below.</p>

  <h4><code>index.html</code></h4>
  <pre class="revised">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Selection&lt;/title&gt;
  &lt;style&gt;
    <span class="new">body {
      width: 200px;
      margin: 0 auto;
    }
    div {
      overflow: auto;
    }
    .container {
      width: 80%;
      height: 100px;
      margin: 0 auto;
      background-color: #fee;
      padding: 0.5em;
    }</span>
    .box {    
      <span class="new">height: 200px;</span>
      width: 80%;
      margin: 0 auto;
      border: 1px solid #ccc;
      border-top-color: #666;
      border-left-color: #666;
      background-color: #f8f8f8;
      padding: 0.5em;
    }
    span {
      color: #c00;
    }
    .unselectable {
      -webkit-touch-callout: none; /* iOS Safari */
      -webkit-user-select: none;   /* Chrome/Safari/Opera */
      -khtml-user-select: none;    /* Konqueror */
      -moz-user-select: none;      /* Firefox */
      -ms-user-select: none;       /* Internet Explorer/Edge */
      user-select: none;
      -webkit-user-drag: none;
      user-drag: none;
      color: #999;
    }
  }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;p lang="ru"&gt;Вим ед путант альбюкиюс прёнкипыз, квюо
  эи выльёт аэтырно бландит, видэ фабыллас майыжтатйж прё экз.&lt;/p&gt;

  <span class="new">&lt;div class="container"&gt;</span>
    &lt;div class="box" lang="la"&gt;
      &lt;span&gt;Lorem ipsum dolor sit amet, consectetur adipiscing
      elit.&lt;/span&gt;
      In nunc ipsum, tristique in convallis non, ultrices sed eros.
      &lt;span class="unselectable" draggable="false" ondragstart="function() { return false; }"&gt;This span has
      &lt;em&gt;user-select: none;&lt;/em&gt; applied to it.&lt;/span&gt;
      &lt;span&gt;Integer eu dignissim justo, eu facilisis est.&lt;/span&gt;
    &lt;/div&gt;
 <span class="new"> &lt;/div&gt;</span>

  &lt;p&gt;-Double-click to test- 'Use A4-size paper.'
  It's a three-o'clock meet-up. An O'Brian-style decision.
  Я — программист. «Ты говоришь по-русски? Скажи что-нибудь.»&lt;/p&gt;

  &lt;p id="output" class="unselectable"&gt;&lt;/p&gt;

  &lt;script src="js/selection.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;></pre>

  <div class="test unselectable">
    <a href="source/09_subscroll/" target="test">Test Here</a>
  </div>

  <div class="aside next">In this section, you've extended the <code>scrollIntoView</code> feature so that it will work in any context.
    <p>In the <a href="#box">next section</a>, you'll see how to limit the "select hyphenated words with a double-click or the left and right arrow keys" feature to just one HTML element.</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#box">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- BOX -->
<section id="box">
  <h2>Limiting the "whole word selection" feature to one HTML element</h2>
  <p>If you want the feature you've been working on to take effect only inside a particular HTML element, you need to make changes in three different places:</p>
  <ul>
  <li>Instead of using <code>document.body.ondblclick</code> to trigger the <code>selectHyphenatedWords</code> function, you'll need to use <code><span class="ymmv">yourCustomElement.</span>ondblclick</code>.</li>
  <li>You'll still need to use <code>document.body.onkeydown = jumpToNextWord</code>, but inside the <code>jumpToNextWord</code> function, you'll need to detect both:
    <ul>
      <li>If the selection is inside the particular HTML element before an arrow key was pressed</li>
      <li>If the selection will still be inside the particular HTML element after it moves to the adjacent word.</li>
    </ul>
    If either of these is false, then the selection should not move.</li>
  </ul>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Detect if the selection starts inside a given HTML element</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/blob/gh-pages/selection/source/zips/10_box.zip" target="source">Download the source files</a>
  </div>

  <h3>Detecting if a node is inside a given node</h3>
  <p>You can use the <code><span class="ymmv">node.</span><a href="https://developer.mozilla.org/en/docs/Web/API/Node/contains">contains</a>(<span class="ymmv">other_node</span>)</code> method to check if the <code><span class="ymmv">range.</span>startContainer</code> node is inside your chosen element. The code listing below shows how you can change the <code>selection.js</code> script to limit the feature to the scrollable box that contains the "Lorem ipsum" text.</p>

  <h4><code>js/selection.js</code></h4>
  <pre><span  class="revised">"use strict"

;(function showSelection(){
  <span class="omit">// code omitted for clarity</span>
})()

;(function selectWholeWordsWithHyphens(){
  <span class="omit">// code omitted for clarity</span>

  var range
    , container
    , selectionUpdated</span>

  <span class="new">var box = document.querySelector(".box")</span>

  <span class="new">box</span>.ondblclick = selectHyphenatedWords
  document.body.onkeydown = jumpToNextWord

  <span class="revised">function selectHyphenatedWords(event) {
    <span class="omit">// code omitted for clarity</span>
  }

  <span class="omit">// code omitted for clarity</span>

  function jumpToNextWord (event) {
    var rangeData

    if (!selection.rangeCount) {
      return
    } else if (!(range = selection.getRangeAt(0))) {
      return
    } <span class="new">else if (!box.contains(range.startContainer)) {
      return
    }</span>

    switch (event.keyCode) {
      case 37: // Left
        rangeData = jumpLeft()
      break
      case 39: // Right
        rangeData = jumpRight()
    }

    if (!rangeData) {
      return
    }

    <span class="new">if (!box.contains(container)) {
      return
    }</span></span>

    range.setStart(container, rangeData.startOffset)
    range.setEnd(container, rangeData.endOffset)

    <span class="omit">// code omitted for clarity</span>
  <span class="revised">}

  <span class="omit">// code omitted for clarity</span>
</span>})()</pre></pre>

  <p>You can save the changes to your file and test that double-clicking a hyphenated word outside the scrollable box will not select the whole word, and pressing the arrow keys will not move the selection. If you click inside the scrollable box, however, everything behaves the way it did before.</p>

  <div class="test unselectable">
    <a href="source/10_box/" target="test">Test Here</a>
  </div>

  <div class="aside next">In this section, you've made changes to your JavaScript code to limit the "whole word selection" feature to one HTML element. To do this, you have used:
  <ul>
      <li><code><span class="ymmv">node.</span><a href="https://developer.mozilla.org/en/docs/Web/API/Node/contains">contains</a>(<span class="ymmv">other_node</span>)</code></li>
    </ul>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#end">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- CONCLUSION -->
<section id="end">
  <h2>Conclusion</h2>
  <p>That's it! Well done!</p>
  <div class="aside preview">Here's what you've learnt:
    <ul>
      <li>How to create a text selection through code</li>
      <li>How to use regular expressions to detect words and word boundaries</li>
      <li>How to extend a selection</li>
      <li>How to find the next whole word in a given text node</li>
      <li>How to find the next text node as it appears in the HTML file</li>
      <li>How to scroll the elements of a page to ensure that the selection is visible</li>
    </ul>
  </div>

  <p>This all works well in  languages that read from left to right and that use spaces to separate words, such as the languages of Europe. To get this feature to work in other languages, more work needs to be done. To continue with this topic, you might like to follow tutorial on using a dictionary <a href="https://en.wikipedia.org/wiki/Trie">trie</a> to help with <a href="../thai/">word segmentation in Thai</a>.</p>

  <p>This feature was designed as a module for the <a href="../notebook/">Lexogram Notebook project</a>. If you are learning a foreign language, you can use the <a href="../annotations/">Annotation</a> extension when you visit a web page in the language you are learning. Any text that you select in that page will appear in a box in a popup window; selecting one word at a time in that box will open up a third-party language reference, such as <a href="https://www.wiktionary.org/">Wiktionary</a>, at the appropriate page. This feature is treated in more detail <a href="../reference/">here</a>.</p>

  <p>Congratulations on all you have learned!</p>
</section>

<!-- OVERVIEW : SECTION 0 -->
<section id="top">
  <h2>Overview</h2>
  <p class="top">This tutorial teaches you how to use JavaScript to control the selection of text in a web page.</p>

  <div class="aside preview">In particular, you will be learning about:
    <ul>
      <li>The <code>Selection</code> object</li>
      <li>The <code>Range</code> object</li>
      <li>Selecting hyphenated words in their entirety</li>
      <li>Using the left and right arrow keys to jump from one word to the next</li>
      <li>Ensuring that the current selection is visible in the browser window</li>
      <li>Working with text in a variety of writing scripts</li>
      <li>Limiting the field of action of the selection feature to one particular HTML element.</li>
    </ul>
  </div>
  <p></p>

  <footer>
    <ul class="nav">
      <li>
        <a href="#discover">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>
</article>
</main>

<script src="../js/core.js"></script>
</body>
</html>
