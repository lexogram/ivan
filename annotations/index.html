<!DOCTYPE html>
<html lang=en>
<head>
<meta charset="utf-8">
<title>Chrome extension</title>
<link rel="stylesheet" href="../css/core.css" />
<link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
</head>

<body>
  <div class="sidebar">
    <div class="logo">
      <a href="../"><img src="../img/logo.png" alt="openbook home" /></a>
    </div>

    <nav>    
      <h3>Getting started</h3>
      <ol>
        <li><a href="#top">Overview</a></li>
        <li><a href="#waiver">Waiver</a></li>
        <li><a href="#intro">Introduction</a></li>
      </ol>
      <h3>The building blocks</h3>
      <ol start="4">
        <li><a href="#basic">A basic extension</a></li>
        <li><a href="#window">A standalone window</a></li>
        <li><a href="#meteor">Creating a Meteor site</a></li>
      </ol>
      <h3>Connections</h3>
      <ol start="7">
        <li><a href="#connection">Creating a connection</a></li>
        <li><a href="#actions">Detecting interactions</a></li>
        <li><a href="#server">A server-side script</a></li>
        <li><a href="#call">Talking to the server</a></li>
        <li><a href="#template">Using Blaze templates</a></li>
      </ol>
      <h3>Toolbar</h3>
      <ol start="12">
        <li><a href="#toolbar">Adding a toolbar</a></li>
        <li><a href="#close">Closing the toolbar</a></li>
        <li><a href="#navigate">Navigating</a></li>
      </ol>
      <h3>Customizing the page</h3>
      <ol start="15">
        <li><a href="#copy">Altering a copy</a></li>
        <li><a href="#colouring">Colouring each word</a></li>
        <li><a href="#toggle">Toggling the display</a></li>
      </ol>
      <h3>Delivery</h3>
      <ol start="18">
        <li><a href="#sharing">Sharing your extension</a></li>
        <li><a href="#end">Conclusion</a></li>
      </ol>
    </nav>

    <p class="aside support">If you have any difficulty in this tutorial, please <a href="https://github.com/lexogram/openbook/issues/new">tell us about it</a>, and we will do our best to deal with it for you.</p>
  </div>

<main>
<header>
  <a href="https://github.com/lexogram/openbook/blob/master/LICENSE" class="cc">&#59409;</a>
  <h1>Annotations : a Chrome extension</h1>
  <ul class="nav">
    <li>
      <a href="#back"><img src="../img/arrow.png" alt="back" /></a>
    </li><li>
      <a href="#next"><img src="../img/arrow.png" alt="next" /></a>
    </li>
  </ul>
</header>

<article>
<!-- WAIVER -->
<section id="waiver">
  <div class="aside warn"><span class="h2">Waiver</span>
    <p>To weave its magic, the Annotations extension makes permanent records of your actions in a database on the server at lexogram.com.</p>
    <ul>
      <li>It records the IP address that is assigned to you at the moment when you start using the Annotations extension</li>
      <li>It records what pages you have visited, and on what dates</li>
      <li>It stores a copy of the text of each page you visit</li>
      <li>It stores the personal notes that you make, and, with your permission, may share these notes anonymously with other people</li>
    </ul>
     <p>From this information, the server generates a profile of your language skills which may become more and more accurate the more you use the Annotations extensions and the Lexogram service.</p>
     <p>You may register with Lexogram using a unique username and password, so that you can keep track of your learning on different computers and share the same computer with different learners. You may provide an email address or a cell phone number, in order to reset your password. If you do so, then it will be technically possible to connect the activity associated with your account to you personally. Even if you don't register, your IP address may provide enough information to identify you.</p>
     <p>Lexogram uses this data only to provide you with a service that we hope you will find valuable. Lexogram does not provide any information concerning your activities to any third parties. Lexogram does its best to keep its servers secure from malicious attacks. However, Lexogram cannot guarantee that your personal use of the Annotations extension and the Lexogram infrastructure will remain private forever. By using the Annotations extension, you agree to refrain from any activity that you might regret, and never to hold Lexogram responsible in any way for anything that happens as a result of your use of the services that Lexogram provides.</p>
  </div>

  <footer>
    <ul class="nav">
    <li>
    <a href="#intro">
    <img src="../img/arrow.png" alt="next"/>
    </a>
    </li>
    </ul>
  </footer>
</section>

<!-- INTRODUCTION -->
<section id="intro">
  <h2>Introduction to Chrome extensions</h2>
  <p>A Chrome extension can consist of several moving parts:</p>
  <ul>
  <li>A clickable icon that appears in the Chrome toolbar to the right of the address bar omnibox</li>
  <li>An HTML page that can open either as a popup or as a separate window</li>
  <li>"Background" code that is loaded and run as soon as Chrome is launched. This defines what happens when you click on the toolbar icon</li>
  <li>"Content" code that can be injected into pages that you visit while the extension is enabled, and which run after the page has loaded</li>
  <li>CSS that is injected into every page while the extension is enabled.</li>
  </ul>
  <p class="aside info">The injected data (code and CSS) is not applied to the extension's custom HTML page.</p>
  <p>The Chrome browser provides a number of proprietary methods to call methods in the <span class="keyword">background</span> code or in another window or tab. This means that you can inject code into the pages that your user will visit, and use that to communicate between tabs and windows, via the <span class="keyword">background</span> code.</p>
  <p>You can arrange for an HTML page to open when you click the extension icon. You can also use the injected <code>content</code> code to modify the DOM and the CSS of the main page.</p>
   <div class="aside preview">In this tutorial, you will see how to use these techniques to:
   <ul>
  <li>Add a toolbar at the top of the main page</li>
  <li>Replace the <code>body</code> of the page with a modified copy, so that you can change the colour of individual words</li>
  <li>Display a reactive <a href="https://www.meteor.com/" class="plain">Meteor</a> web site in the custom window</li>
  <li>Tell your Meteor server about the user's actions in a third-party web page</li>
  <li>Use information that you retrieve from your server to update the Notebook window and to customize the appearance of the third-party page</li>
  </ul>
  </div>
  <figure>
  <img src="img/communications.png" alt="How the different modules communicate" />
  <figcaption>Figure 2. How the different modules communicate</figcaption>
  </figure>
  <p class="aside note">For this tutorial, the Meteor website that you will be working with will be a simple proof-of-concept prototype, with just enough features to show how the Chrome extension messaging system works. A <a href="../notebook/">forthcoming tutorial</a> will deal with the more advanced features of the Meteor site.</p>

  <footer>
    <ul class="nav">
    <li>
    <a href="#basic">
    <img src="../img/arrow.png" alt="next"/>
    </a>
    </li>
    </ul>
  </footer>
</section>

<!-- BASIC EXTENSION -->
<section id="basic">
  <h2>Creating a basic extension</h2>
  <div class="aside preview">In this section, you'll learn how to:
  <ul>
  <li>Create a manifest.json file to define your extension</li>
  <li>Create a button for the Chrome Toolbar</li>
  <li>Create a page to display when the button is pressed</li>
  <li>Activate your extension</li>
  </ul>
  <a href="https://github.com/lexogram/notebook-extension/raw/master/tutorial/zips/01_basic_extension.zip" target="source">Download the source files</a>
  </div>

  <p>To create the simplest possible extension, you will need to create three files:</p>
  <dl>
    <dt>manifest.json</dt>
    <dd>This file tells Chrome about your extension and how to find the other two files. It must be called "manifest.json". The other files can have any name you want, so long as their names are recorded inside the <code>manifest.json</code> file.</dd>
    <dt>A 19 x 19 pixel image</dt>
    <dd>This will be used to create a button in the Chrome toolbar. In the <code>manifest.json</code> file shown below, it is named <code>icon.png</code>.</dd>
    <dt>A simple HTML file</dt>
    <dd>This contents of this file will be displayed in a window when you click on the Chrome toolbar icon. In the <code>manifest.json</code> file shown below, it is named <code>popup.html</code>.</dd>
  </dl>
  <h3>manifest.json</h3>
  <p>The <code>manifest.json</code> file is in <a href="http://www.json.org/">JSON</a> format. It can contain a wide range of information. The essential details are shown below.</p>
<pre>{
  "manifest_version": 2

, "name": "Annotations"
, "version": "alpha"
, "description": "Helps you save and share notes about web pages"

, "browser_action": {
    "default_icon": "icon.png"
  , "default_popup": "popup.html"
  }

, "permissions": [
    "activeTab"
  ]
}</pre>
  <div class="aside note">Notes on the essential fields used in manifest.json
    <ul>
    <li><code>manifest_version</code> must be <code>2</code> in order to ensure that all the features mentioned in this tutorial are available.</li>
    <li>In the Chrome Extensions management page, <code>name</code> will be used as the name of the extension. It may also be used as the tooltip when you roll your mouse over the extension's icon. The name does not have to be unique. It should be 45 characters or less.</li>
    <li>The <code>version</code> must be a string of between 1-4 dot-separated integers each between 0 and 65536, such as "1" or "4.32.1.0"</li>
    <li>The <code>description</code> is optional. It should be a plain text string (no HTML or other formatting) of 132 characters or less. The description will be used both in the Chrome extension page and in the Chrome Web Store.</li>
    <li>There are two types of extension: <a href="https://developer.chrome.com/extensions/browserAction">browser_action</a>  extensions that can be used with any page, and <a href="https://developer.chrome.com/extensions/pageAction">page_action</a> extensions that will only be activated if the current page fits a particular set of criteria. The Annotations extension is designed for use with any page, so this <code>manifest.json</code> file contains an entry for <code>browser_action</code>.</li>
    <li>If no <code>default_icon</code> is provided, then the button in the Chrome toolbar will use the first letter of the <code>name</code> to create an image for the button. You can use in image of any size, but it will be redimensioned to 19 x 19 pixels, so it's best to create an image at that size.</li>
    <li>The simplest action for an extension is to display a popup window when the toolbar button is clicked. To see this in action, for now, you can create a simple HTML page. However, the Annotations extension will not use a popup window, so the <code>default_popup</code> entry will be removed later.</li>
    <li>Users must grant an extension <code>permissions</code> to access any personal information. The lowest level of permission is access to the data on the current page or <code><a href="https://developer.chrome.com/extensions/activeTab">activeTab</a></code>. You'll need to add other permissions later.</li>
    </ul>
  </div>

  <figure>
  <img src="img/tooltip.png" alt="extension tooltip" />
  <figcaption>Figure 3. The <code>name</code> appears as a tooltip on rollover</figcaption>
  </figure>

  <h3>The default_popup file</h3>
  <p>For the Annotations extension, you will be opening a new window rather than using a popup, but to get started, you can create a file named <code>popup.html</code> with the following minimal content:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;body&gt;
&lt;h1&gt;Popup&lt;/h1&gt;
&lt;p&gt;More stuff can go here&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

  <h3>Loading your extension</h3>
  <p>Place your <code>manifest.json</code>, <code>popup.html</code> and <code>icon.png</code> files in the same folder on your hard drive (or <a href="https://github.com/lexogram/notebook-extension/raw/master/tutorial/zips/01_basic_extension.zip" target="source">download the source files</a> and decompress them). Open Chrome and type <code>chrome://extensions</code> in the address omnibox, then press the Enter key.</p>
  <figure>
  <img src="img/load.png" alt="loading your extension" />
  <figcaption>Figure 4. Loading your extension</figcaption>
  </figure>
  <p>Make sure the Developer Mode checkbox is selected, and then click on the Load Unpacked Extension button. A dialogue window will open; you can select the folder in which you saved your three files. The icon that you chose will appear in a button to the right of the address omnibox. If you click on it, a popup window will open to display your HTML page.</p>

  <figure>
  <img src="img/basic.png" alt="popup window" />
  <figcaption>Figure 5. The <code>default_popup</code> appears when you click on the icon</figcaption>
  </figure>

  <div class="aside next">In this section, you've created a minimalist Chrome extension that opens a popup window. You seen the importance of the <code>manifest.json</code> file and how to tell Chrome that your extension exists.
  <p>In the <a href="#window">next section</a>, you'll see how to create a background script to open a stand-alone window.</p>
  </div>
  <div class="optional tips">
  <input type="checkbox" id="icon-tips"/>
  <label for="icon-tips">Tip: Additional Icons</label>
  <div>
  <p>Currently, a generic icon is used for your extension in the Chrome Extensions management page.</p>
  <figure>
  <img src="img/default_icon.png" alt="default icon" />
  <figcaption>Figure 6. The default Chrome extension icon</figcaption>
  </figure>
  <p>It's a good idea to create additional icons that will be used on the Extensions management page, in the Chrome Web Store, during the installation of your extension, and as the favicon of any browser pages your extension might create.</p>
  <p>You can <a href="https://github.com/lexogram/notebook-extension/raw/master/tutorial/zips/01a_additional_icons.zip" target="source">download the source files</a> for a slightly more complex extension which places all the icon files in the same <code>img</code> folder, and gives them names that indicate their sizes.</p>
<pre class="revised">{
  "manifest_version": 2

, "name": "Annotations"
, "version": "1.0"
, "description": "Helps you save and share notes about web pages."

, "browser_action": {
    "default_icon": "<span class="new">img/</span>icon<span class="new">19</span>.png"
  , "default_popup": "popup.html"
  }

, "permissions": [
    "activeTab"
  ]

<span class="new">, "icons": {
    "16": "img/icon16.png"
  , "48": "img/icon48.png"
  , "128": "img/icon128.png"
  }</span>
}</pre>
  <p>If you use this version of the extension, you'll see a custom icon for your extension in the Extensions management page.</p>
  <figure>
  <img src="img/custom_icons.png" alt="custom icons" />
  <figcaption>Figure 7. A custom icon for your extension</figcaption>
  </figure>
  <p>You can find more information about this on the <a href="https://developer.chrome.com/apps/manifest/icons">Chrome Developer site</a>.</p>
  </div>
  </div>

  <footer>
    <ul class="nav">
    <li>
    <a href="#window">
    <img src="../img/arrow.png" alt="next"/>
    </a>
    </li>
    </ul>
  </footer>
</section>

<!-- WINDOW -->
<section id="window">
  <h2>A standalone window</h2>
  <div class="aside preview">In this section, you'll learn how to:
  <ul>
  <li>Create a background script that will be loaded as soon as Chrome is launched</li>
  <li>Call a method in the background script when the extensions toolbar button is clicked</li>
  <li>Tell Chrome to open a new window to display a specific URL</li>
  <li>Debug a background script</li>
  </ul>
  <a href="https://github.com/lexogram/notebook-extension/raw/master/tutorial/zips/02_standalone_window.zip" target="source">Download the source files</a>
  </div>

  <h3>Declaring a background script</h3>
  <p>In your <code>manifest.json</code> file, you can declare scripts that will be added to an automatically-generated <span class="keyword">background</span> page. Chrome will create the page when it first starts up (or when you reload your extension) but will never show it. You can use the background page to load scripts that will be available at all times the browser is open. Here's how you can modify your <code>manifest.json</code> file so that it loads a script called <code>background.js</code>:</p>

<pre class="revised">{
  "manifest_version": 2

, "name": "Annotations"
, "version": "1.0"
, "description": "Helps you save and share notes about web pages."

, "browser_action": {
    "default_icon": "img/icon19.png"
  }

, "permissions": [
    "activeTab"
  ]

, "icons": {
    "16": "img/icon16.png"
  , "48": "img/icon48.png"
  , "128": "img/icon128.png"
  }

<span class="new">, "background": {
    "scripts": [
      "js/background.js"
    ]</span>
  }
}</pre>

  <h3>background.js</h3>
  <p>You can create a file called <code>background.js</code> with the following script. Notice that it refers to another file called <code>popup.html</code>; you can use the existing file with that name for now.</p>
  <p>Notice that the script uses a custom <code>notify()</code> method to both show an alert and log data in the console. You'll see shortly how to bring up the console where you can see the logged data. You'll also notice that this script makes calls to methods that are defined on a global <code>chrome</code> object.</p>

<pre>"use strict"

;(function background(){

  function notify() {
    console.log.apply(console, arguments)
    alert(arguments[0])
  }

  function useExtension() {
    notify ("useExtension triggered")

    var URL = <span class="red">chrome.extension.getURL</span>("html/popup.html")
    var width = 300
    var top = 0

    var options = {
      url: URL
    , left: screen.availWidth - width
    , top: top
    , width: width
    , height: screen.availHeight - top
    , focused: false
    , type: "popup" // "normal"
    }

    <span class="red">chrome.windows.create</span>(options, callback)

    function callback(window_data) {
      notify ("window opened", window_data)
    }
  }

  <span class="red">chrome.browserAction.onClicked.addListener</span>(useExtension)
  notify ("Background script loaded")
})()</pre>

  <h3>Reloading your extension</h3>
  <p>Here's how your files should be organized now, so that the <code>manifest.json</code> file can find them all:</p>
  <figure>
  <img src="img/background_js.png" alt="file hierarchy" />
  <figcaption>Figure 8. The new arrangement of your extension files</figcaption>
  </figure>

  <p>Each time you make a change to your extension, you need to tell Chrome to reload it. You can do this by clicking on the Reload link for your extension in the Chrome Extensions management window.</p>

  <figure>
  <img src="img/reload.png" alt="Reload your extension and open the Inspector window for the background page" />
  <figcaption>Figure 9. Reload your extension and open the Inspector window for the background page</figcaption>
  </figure>

  <h3>Debugging a background script</h3>
  <p>As you can see in Figure 9, abovo, when you reload your extension after adding a background script, you will see a new Inspect Views link in the Extension management panel, which allows you to open a Developer Tools Inspector window for the <span class="keyword">background</span> page which Chrome has now created. When you activate your extension, your <code>popup.html</code> page should open in a new window. You'll see that the output of the <code>console.log()</code> command appears in the Console in the Inspector window for your <span class="keyword">background</span> page.</p>

  <h3>The <code>chrome</code> object</h3>
  <p>It's time now to look closer at what your <code>background.js</code> script is doing, and especially at the following three lines:</p>

<pre><span class="red">chrome.extension.getURL</span>("html/popup.html")

<span class="red">chrome.windows.create</span>(options, callback)

<span class="red">chrome.browserAction.onClicked.addListener</span>(useExtension)</pre>

  All scripts running in Chrome have access to a  object named <code>chrome</code>. However, scripts running in a standard window and script running in the <span class="keyword">background</span> have access to different objects that have the same name.
  <figure>
  <img src="img/page_chrome.png" alt="page chrome object" />
  <figcaption>Figure 10. The <code>chrome</code> object available in standard windows</figcaption>
  </figure> 

  <figure>
  <img src="img/background_chrome.png" alt="background chrome object" />
  <figcaption>Figure 11. The <code>chrome</code> object available to background scripts</figcaption>
  </figure>
  <p>As you can see from Figure 11, the <code>chrome</code> object that is available to <span class="keyword">background</span> scripts posseses a number of extension-specific properties:</p>
  <ul>
  <li><code><a href="https://developer.chrome.com/extensions/browserAction">browserAction</a></code> </li>
  <li><code><a href="https://developer.chrome.com/extensions/extension">extension</a></code> </li>
  <li><code><a href="https://developer.chrome.com/extensions/i18n">i18n</a></code> (i<em>nternationalizatio</em>n)</li>
  <li><code><a href="https://developer.chrome.com/extensions/management">management</a></code> </li>
  <li><code><a href="https://developer.chrome.com/extensions/permissions">permissions</a></code> </li>
  <li><code><a href="https://developer.chrome.com/extensions/tabs">tabs</a></code> </li>
  <li><code><a href="https://developer.chrome.com/extensions/windows">windows</a></code> </li>
  </ul>
  <p>You will be using several of these background extension objects as you develop your extension, as well as the <code>chrome.runtime</code> object that is available in standard web pages.</p>
  <h4><code>chrome.extension</code></h4>
  <p>The <code>chrome.extension</code> API provides support for exchanging messages between extensions or between an extension and its content scripts that have been injected into the pages in a standard window.</p>
  <p>The <code><a href="https://developer.chrome.com/extensions/extension#method-getURL">chrome.extension.getURL()</a></code> method converts a relative path such as <code>"html/popup.html"</code> into a fully-qualified URL: <code>"chrome-extension://maabmcngoiolpokniappbcolnflbgopo/html/popup.html"</code> </p>
  <h4><code>chrome.windows</code></h4>
  <p>You can use the <code>chrome.windows</code> API to create, modify, and rearrange windows in the browser.</p>
  <p>The <code><a href="https://developer.chrome.com/extensions/windows#method-create">chrome.windows.create(options, callback)</a></code> opens a new browser window with any optional sizing, position or default URL that you provide in the <code>options</code> argument.</p>
  <h4>chrome.browserAction</h4>
  <p>The <code>chrome.browserAction</code> allows you to control the extension button in the Chrome toolbar. You can modify its appearance, its title, and whether it is enabled. You can also detect when it is clicked, using the <code>chrome.browserAction.onClicked</code> event. The code above sets a listener for this event, and uses that to open a custom window with a specified position and size.</p>
  <p class="aside note">The listener for the <code>chrome.browserAction.onClicked</code> event will be triggered every time the toolbar button is clicked, not just the first time. Later you will be modifying this code so that it reacts differently if the extensions custom window is already open.</p>
  <h4>Window <code>type</code></h4>
  <p>The <code><a href="https://developer.chrome.com/extensions/windows#type-CreateType">type</a></code> of the window is set to <code>"popup"</code>. This creates a window with no toolbar, so the user cannot navigate to another page in this window. There are four possible values for <code>type</code>:</p>
  <ul>
  <li><code>"normal"</code> (default)</li>
  <li><code>"popup"</code></li>
  <li><code>"panel"</code></li>
  <li><code>"detached_panel"</code></li>
  </ul>
  <p>At the time of writing, <code>"popup"</code>, <code>"panel"</code> and <code>"detached_panel"</code> all have the same effect.</p>
  <figure>
  <img src="img/normal_window.png" alt='A window with a type of "normal"' />
  <figcaption>Figure 12. A window with a <code>type</code> of "normal"</figcaption>
  </figure>
  <figure>
  <img src="img/popup_window.png" alt='A window with a <code>type</code> of "popup"' />
  <figcaption>Figure 13. A window with a <code>type</code> of "popup"</figcaption>
  </figure>

  <h3>The <code>Window</code> object</h3>
  <p>When <code>chrome.windows.create(options, callback)</code> is run, it activates an optional callback, and sends a <code>Window</code> object as the argument:</p>
<pre>{ alwaysOnTop: false
, focused: false
, height: 777
, id: 161
, incognito: false
, left: 880
, state: "normal"
, tabs: [
    active: true
  , audible: false
  , height: 682
  , highlighted: true
  , id: 162
  , incognito: false
  , index: 0
  , mutedInfo: Object
  , pinned: false
  , selected: true
  , status: "loading"
  , width: 400
  , windowId: 161
  ]
, top: 23
, type: "normal"
, width: 400
}</pre>

  <div class="aside next">In this section, you've set up a a background script to react to a click on the toolbar button for your extension, and you've used that action to open a custom window. You've also seen how to open a Developer Tools Inspector window, so that you can debug your background script.
  <p>You've used the following expressions that are specific to Chrome extensions:</p>
  <ul>
  <li><code>"background"</code> </li>
  <li><code>chrome.extension.getURL()</code> </li>
  <li><code>chrome.windows.create()</code> </li>
  <li><code>chrome.browserAction.onClicked.addListener()</code></li>
  </ul>
  <p>In the <a href="#meteor">next section</a>, you'll see how to install and run a Meteor web server on your development computer, and you'll get your custom popup window to display the site running on your Meteor server.</p>
  </div>

  <footer>
    <ul class="nav">
    <li>
    <a href="#meteor">
    <img src="../img/arrow.png" alt="next"/>
    </a>
    </li>
    </ul>
  </footer>
</section>

<!-- METEOR -->
<section id="meteor">
  <h2>Creating a Meteor site</h2>
  <div class="aside preview">In this section, you'll learn how to:
  <ul>
  <li>Install Meteor on your development computer</li>
  <li>View the default Meteor app in your extension popup window</li>
  </ul>
  <a href="https://github.com/lexogram/notebook-extension/raw/master/tutorial/zips/03_meteor.zip" target="source">Download the source files</a>
  <a href="https://www.meteor.com/install">Install Meteor</a>
  </div>

  <p><a href="https://www.meteor.com/">Meteor</a> is an open-source platform for creating reactive web sites in pure JavaScript. It runs on Windows, OSX and Linux and it allows you to write code that runs on the server or in the browser in one place and in one language. To deliver a very basic web page using Meteor takes a little time, but virtually no effort.

  <h3>Installing Meteor</h3>
  <p>It's easy to install Meteor on your development machine. First make sure that you are connected to the Internet.</p>

  <h4>Windows</h4><p>If you are on Windows, simply <a href="https://install.meteor.com/windows">download the installer</a> and run it.</p>
  <h4>OSX and Linux</h4>
  <p>If you are on OSX or Linux, you can install Meteor from a <a href="../html/terminal.html">Terminal window</a>. You need to use the Terminal as an administrator.
  <div class="aside tip">If you are working from a non-admin account, you'll need to start by logging in as an admin:
  <pre class="revised"><span class="new">su <em>admin</em></span>
  Password:•</pre>
  <p>Use the name of an administrator for your computer rather than <em>admin</em>, then type your password.</p></div>
  <p>In a Terminal window, type ...</p>
<pre>curl https://install.meteor.com/ | sh</pre>
<p>... and wait while the latest version of Meteor is automatically installed. The Terminal window will fill up with something like this:</p>
<pre class="revised">  %  Total  % Received  % Xferd  Average Speed    Time     Time
                                 Dload  Upload    Total    Spent
100   7592  0     7592  0     0   5873       0  --:--:--  0:00:01 
Removing your existing Meteor installation.
Downloading Meteor distribution
########################################################## 100.0%
Meteor 1.3.4 has been installed in your home directory (~/.meteor)
Writing a launcher script to /usr/local/bin/meteor for your
convenience.
This may prompt for your password.
Password:•
</pre>
  <p>Enter your admin password when you see the prompt for it, to complete the installation. If you did not run the <code>curl</code> command as an administrator, this step may fail.</p>

  <h3>Creating the default Meteor web site</h3>
  <p>In the Terminal window, use the <code><a href="http://www.computerhope.com/unix/ucd.htm">cd</a></code> command to navigate to the directory where you want to create your Meteor web site, and enter the following commands:</p>
<pre>meteor create NoteBook
cd NoteBook
meteor</pre>
  <p>The first command may take a few minutes, as Meteor performs all the actions necessary for populating the <code>notebook</code> folder. When all is done, your folder should contain five items, including two that may be invisible: <code>.gitignore</code> and <code>.meteor</code>.</p>
  <figure>
  <img src="img/meteor_folder.png" alt="Contents of the notebook folder" />
  <figcaption>Figure 14. Contents of the NoteBook folder</figcaption>
  </figure>

  <p>When you run the final <code>meteor</code> command, you'll see a series of actions logged to the Terminal window, as the Meteor application launches. Finally, you should see something like this:</p>

<pre>
[[[[[ <span class="ymmv">/Path/to/the/folder/NoteBook</span> ]]]]]

=> Started proxy.                             
=> Started MongoDB.
=> Started your app.                          

=> App running at: http://localhost:3000/
</pre>
  <p class="aside note">When you want to stop the Meteor app, press <code>Ctrl-C</code></p>
  <p class="aside note"><a href="https://www.mongodb.com/">MongoDB</a> is a free open-source cross-platform document-oriented database. It stores data in a JSON-like format, similar to the format of the <code>manifest.json</code> document you created earlier. (TODO: add reference to Neo4j?)</p>

  <h3>Displaying the Meteor web page in the popup window</h3>
  <p>You can test that the Meteor server is running by visiting <a href="http://localhost:3000/">http://localhost:3000/</a> in your browser. To get the Meteor page to show in your extensions popup window, you need to make some changes to your <code>background.js</code> script, as shown below.</p>
<pre class="revised">"use strict"

;(function background(){

  <span class="new">var windowOpen = false</span>

  function useExtension() {
    <span class="new">if (windowOpen) {
      return
    }</span>

    var URL = <span class="new">"http://localhost:3000/"</span>
    var width = 300
    var top = 0

    var options = {
      url: URL
    , left: screen.availWidth - width
    , top: top
    , width: width
    , height: screen.availHeight - top
    , focused: false
    , type: "popup"
    }

    chrome.windows.create(options, callback)

    function callback(window_data) {
      <span class="new">windowOpen = true</span>
    }
  }

  chrome.browserAction.onClicked.addListener(useExtension)
})()</pre>
  <p>The most important change is setting the <code>URL</code> to <code>"http://localhost:3000/"</code> so the window shows your Meteor site. The other changes ensure that the window is only opened once, the first time you click on the toolbar button.</p>
  <p class="aside note">Right now, if you close the popup window, then it will stay closed until you relaunch Google or reload your extension. In <a href="#">TODO</a>, you will be adding code that resets <code>windowOpen</code> to false when the window is closed.</p>
  <p>When you reload your extension and click on the toolbar button, you should see something like this:</p>
  <figure>
  <img src="img/meteor_default.png" alt="The default Meteor page in your extensions popup window" />
  <figcaption>Figure 15. The default Meteor page in your extensions popup window</figcaption>
  </figure>

  <p class="aside note">The default Meteor site doesn't do anything that you want it to do yet. If you've never used Meteor before you may want to follow the Learn Meteor links that are shown in the window, in order to gain an understanding of the Meteor development environment. However, this is not essential; this tutorial covers all the basics that you will need to know.</p>

  <div class="aside next">In this section, you've seen how simple it is to install Meteor and to launch a default web site. You've also seen how to get the popup window of your extension to display this Meteor web site.
  <p>In the <a href="#connection">next section</a>, you'll start modifying the Meteor NoteBook app and see how to get its page script to communicate with the extension's background script.</p>
  </div>

  <footer>
    <ul class="nav">
    <li>
    <a href="#connection">
    <img src="../img/arrow.png" alt="next"/>
    </a>
    </li>
    </ul>
  </footer>
</section>

<!-- CONNECTION -->
<section id="connection">
  <h2>Creating a connection between the page script and the background</h2>
  <p>In this section, to check that the connection is working, you'll create a simple "ping" feature in your background script, and use this to increment a number in the NoteBook. Once this counting system is working, you can replace it with more useful features.</p>
  <div class="aside preview">In this section, you'll learn how to:
  <ul>
  <li>Allow a page script to communicate with your extension's background script</li>
  <li>Open a two-way connection between a page script and your extension's background script</li>
  <li>Send a messages between the page script and the background</li>
  </ul>
  <a href="https://github.com/lexogram/notebook-extension/raw/master/tutorial/zips/04_connection.zip" target="source">Download the source files</a>
  </div>
  <p>When the Annotation extension is fully working, the following flow of actions will occur when you select a word or phrase in a web page that you visit:</p>

  <ol>
  <li>A <span class="keyword">content script</span> in the web page will tell the <span class="keyword">background script</span> about the selection</li>
  <li><strong>The <span class="keyword">background script</span> will forward information to a <span class="keyword">page script</span> in the NoteBook window</strong></li>
  <li>The <span class="keyword">client-side page script</span> in the NoteBook window will send a message to a <span class="keyword">server-side script</span> on the Meteor server</li>
  <li>The <span class="keyword">server-side script</span> will query a <span class="keyword">database</span></li>
  <li>The <span class="keyword">server-side script</span> will send the result of the database query back to the <span class="keyword">client-side page script</span> in the NoteBook window</li>
  <li>The NoteBook window will update</li> 
  <li><strong>The <span class="keyword">page script</span> in the NoteBook window will send some of the information it received to the <span class="keyword">background script</span></strong></li>
  <li>The <span class="keyword">background script</span> will forward the information to the <span class="keyword">content script</span> in the web page you are reading</li>
  <li>The display of the web page will update.</li>
  </ol>
  <p class="aside note">In this tutorial, the interactions with the database mentioned in steps 4 and 5 will be simulated. They will be covered in a <a href="../notebook/">separate tutorial</a>.</p>
  <p>This section deals with setting up the connections that you will need to deal with the two items shown in bold above.</p>

  <h3><code>manifest.json</code></h3>
  <p>As you've already seen, the <code>manifest.json</code> controls the files that your extension can use. For the sake of security, before your extension can accept a connection coming from a script in a web page, you must provide a filter to identify the web pages that should be allowed to connect.</p>
  <p>This is done with the <code><a href="https://developer.chrome.com/extensions/manifest/externally_connectable">"externally_connectable"</a></code> manifest property. To allow any page script from your Meteor site to connect with your extension's background script, you can provide as <code>"matches"</code> array, containing the pattern <code>"http://localhost:*/*"</code>. This will match with <code>"http://localhost:3000/"</code>, or any custom port number that you have set Meteor to run on.</p>
<pre class="revised">{
  "manifest_version": 2

, "name": "Annotations"
, "version": "1.0"
, "description": "Helps you save and share notes about web pages."

, "browser_action": {
    "default_icon": "img/icon19.png"
  }

, "permissions": [
    "activeTab"
  ]

, "icons": {
    "16": "img/icon16.png"
  , "48": "img/icon48.png"
  , "128": "img/icon128.png"
  }

, "background": {
    "scripts": [
      "js/background.js"
    ]
  }

<span class="new">, "externally_connectable": {
    "matches": ["http://localhost:*/*"]
  }</span>
}</pre>

  <h3>The Meteor client files</h3>
  <p>The default Meteor app contains three files inside the <code>client</code> folder: <code>main.html</code>, <code>main.css</code> and <code>main.js</code>. These currently define the default Meteor app. You can edit them now, to start customizing the NoteBook.</p>

  <figure>
  <img src="img/meteor_client.png" alt="The three files inside the Meteor client folder" />
  <figcaption>Figure 16. The three files inside the Meteor client folder</figcaption>
  </figure>

  <h4><code>main.html</code></h4>
  <p>Delete everything inside <code>main.html</code> and replace it with this:</p>
<pre>&lt;head&gt;
  &lt;title&gt;NoteBook&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;p id="selection"&gt;&lt;/p&gt;
&lt;/body&gt;</pre>

  <h4><code>main.css</code></h4>
  <p>The <code>main.css</code> file is probably more or less empty. You can use this rule to make the <code>#selection</code> paragraph visible even if it's empty:</p>
<pre>p#selection {
  min-height: 2em;
  width: 100%;
  background-color: #ddd;
  border: 1px solid #ccc;
  border-bottom-color: #eee;
  border-right-color: #eee;
}</pre>

  <figure>
  <img src="img/notebook_00.png" alt="The new-look NoteBook" />
  <figcaption>Figure 17. The new-look NoteBook</figcaption>
  </figure>

  <h3>A two-way connection</h3>
  <p>To create a two-way connection between the page script of your Meteor app and the background script of your extension, you can use the <code><a href="https://developer.chrome.com/extensions/runtime#method-connect">chrome.runtime.connect</a></code> method. This command requires the unique <code>ID</code> of your extension. You can find this in the Chrome Extension management window:</p>

  <figure>
  <img src="img/extensionID.png" alt="Finding your extension ID" />
  <figcaption>Figure 18. Finding your extension ID</figcaption>
  </figure>

  <h4><code>main.js</code></h4>
  <p>Delete everything inside <code>main.js</code> and replace it with the following code. You'll get the change to edit it again before you're done.</p>
<pre>Meteor.startup(function() {
  var extensionID = "<span class="ymmv">use your own extension ID here</span>"
  var port = chrome.runtime.connect(extensionID)
  var message = { method: "startCounter" }

  setTimeout(function () {
    port.postMessage(message)
  }, 1)
})</pre>

  <div class="aside note">Notes on the <code>main.js</code> script
  <ul>
  <li><code><a href="https://docs.meteor.com/api/core.html#Meteor-startup">Meteor.startup()</a></code> is a function provided by Meteor that will run as soon as the DOM is ready. It's good to use it to wrap initializiation code.</li>
  <li>For <code>extensionID</code>, use the value that you can copy from the Chrome Extension management window, as shown in Figure 18. If you use the wrong value, nothing will happen.</li>
  <li>The <code><a href="https://developer.chrome.com/extensions/runtime#type-Port">port</a></code> object returned by <code>chrome.runtime.connect(extensionID)</code> provides a <code>postMessage</code> function, which you can use to send messages to the background script. In a moment, you'll also discover the port's <code>onMessage</code> object, which allows you to listen for incoming messages from the background.</li>
  <li>When <code>chrome.runtime.connect(extensionID)</code> is called, any listener function attached to the <code>chrome.runtime.onConnectExternal</code> object in the background script will be called, as you will see in a moment. The listener function will be passed its own <code>port object</code> which can be used to send and receive messages in the same way as in the page script.</li>
  <li>The call to <code>port.postMessage(message)</code> will be picked up by any listeners set on the background port's <code>onMessage</code> object.</li>
  <li>It helps to delay the call to <code>port.postMessage</code> slightly, presumably to give the <code>port</code> object time to initialize.</li>
  </ul>
  </div>
  <p class="aside tip">The code to set up a connection between a page script and a background script must be placed in the page script. If you need to initialize a connection to a page from a background script, you must do it via an injected <span class="keyword">content script</span>, as you will see in the next section: <a href="#actions">Detecting user actions</a>.</p>

  <p>The background script below sets up the <code>openConnection</code> function as a listener for <code><a href="https://developer.chrome.com/extensions/runtime#event-onConnectExternal">chrome.runtime.onConnectExternal</a></code>, which fires when a <code>runtime.connect</code> connection is made from another extension or, as in this case, from a page script. The <code>openConnection</code> function receives a <code>port</code> object as an argument, saves it for use later and sets up a listener on it for incoming messages.</p>

  <h4><code>background.js</code></h4>

<pre class="revised">"use strict"

;(function background(){

  <span class="new">var timeout = 0
  var port</span>

  function useExtension() {
    if (<span class="new">!port) {
      openNoteBookWindow()</span>
    }
    
    <span class="new">function openNoteBookWindow() {</span>
      var URL = "http://localhost:3000/"
      var width = 300
      var top = 0

      var options = {
        url: URL
      , left: screen.availWidth - width
      , top: top
      , width: width
      , height: screen.availHeight - top
      , focused: false
      , type: "popup"
      }

      chrome.windows.create(<span class="new">options</span>)
    <span class="new">}</span>
  }

  <span class="new">function openConnection(externalPort) {
    port = externalPort
    port.onMessage.addListener(incoming)
  }

  function incoming(message) {
    if (timeout) {
      clearTimeout(timeout)
    }
    ping()
  }

  function ping() {
    port.postMessage({ method: "ping", counter: timeout })
    timeout = setTimeout(ping, 1000)
  }

  chrome.runtime.onConnectExternal.addListener(openConnection)</span>
  chrome.browserAction.onClicked.addListener(useExtension)
})()</pre>

  <p>After the <code>port</code> is set up, it waits for an incoming message. This is sent from <code>main.js</code> after a 1 ms timeout, and it is handled by the <code>incoming</code> listener function. The output of the <code>setTimeout</code> method is an incrementing integer, and for elegance, this is used as the counter that is sent every second to the NoteBook script.</p>

  <h3><code>main.js</code> revisited</h3>
  <p>In its current state, the Notebook page script knows nothing about the message that is sent to it. You can add a listener to the <code>port</code> object, and use this to update the <code>#selection</code> paragraph.</p>
<pre>Meteor.startup(function() {
  var extensionId = "<span class="ymmv">use your own extension ID here</span>"
  var port = chrome.runtime.connect(extensionId)
  var message = { method: "startCounter" }
  <span class="new">var p = document.getElementById("selection")

  function incoming(message) {
    if (message.method === "ping") {
      p.innerHTML = message.counter
    }
  }

  port.onMessage.addListener(incoming)</span>

  setTimeout(function () {
    port.postMessage(message)
  }, 1)
})</pre>

  <figure>
  <img src="img/notebook_01.png" alt="The background script tells the page script to update the NoteBook" />
  <figcaption>Figure 19. The background script tells the page script to update the NoteBook</figcaption>
  </figure>

  <div class="aside next">In this section, you've set up a two-way messaging system between the Meteor NoteBook page script and the background script, and tested that it is working. However, it's not doing anything very useful yet.
  <p>You've used the following expressions that are specific to Chrome extensions:</p>
  <ul>
  <li><code>"externally_connectable"</code> </li>
  <li><code>"matches"</code> </li>
  <li><code>chrome.runtime.connect()</code> </li>
  <li><code>chrome.runtime.onConnectExternal.addListener()</code> </li>
  <li><code><em>port</em>.onMessage.addListener()</code></li>
  <li><code><em>port</em>.postMessage()</code> </li>
  </ul>
  <p>You've used the following expression that is specific to Meteor:</p>
  <ul>
  <li><code>Meteor.startup(function () {...})</code> </li>
  </ul>
  <p>In the <a href="#actions">next section</a>, you'll see how to inject a <span class="keyword">content script</span> into an arbitrary web page, and use that to pass information from the web page to your NoteBook window, via the background script.</p>
  </div>

  <footer>
    <ul class="nav">
    <li>
    <a href="#actions">
    <img src="../img/arrow.png" alt="next"/>
    </a>
    </li>
    </ul>
  </footer>
</section>

<!-- ACTIONS -->
<section id="actions">
  <h2>Detecting user actions in the main window</h2>
  <div class="aside preview">In this section, you'll learn how to:
  <ul>
  <li>Inject a "content" script into a third-party web page</li>
  <li>Send messages from an arbitrary page to your NoteBook, via the background script</li>
  </ul>
  <a href="https://github.com/lexogram/notebook-extension/raw/master/tutorial/zips/05_content_script.zip" target="source">Download the source files</a>
  </div>

  <p>One of the main features of the Annotation extension is that it allows you to select an expression (a word or a phrase) in any web page you visit, and then use the NoteBook window to explore the meanings of the expression. To get this to work, you need to inject a script into the pages you visit in the main window, and get this to communicate with the background script. The background script can then forward messages to your NoteBook window, using the technique you saw in the <a href="#connection">last section</a>.</p>
  <p>As usual, the first step is to add a new manifest property to <code>manifest.json</code> to define a <a href="https://developer.chrome.com/extensions/content_scripts">content script</a>: a script that can be injected into every <span class="keyword">content</span> page that you visit. Or almost every page: you don't want to inject it into your NoteBook page. The structure of the definition is more complex than the ones you have seen so far, because Chrome requires you to create a filter for URLs, so that your script is only added to pages that match the filter.</p>

<pre class="revised">{
  "manifest_version": 2

, "name": "Annotations"
, "version": "1.0"
, "description": "Helps you save and share notes about web pages."

, "browser_action": {
    "default_icon": "img/icon19.png"
  }

, "permissions": [
    "activeTab"
  ]

, "icons": {
    "16": "img/icon16.png"
  , "48": "img/icon48.png"
  , "128": "img/icon128.png"
  }

, "background": {
    "scripts": [
      "js/background.js"
    ]
  }

, "externally_connectable": {
    "matches": ["http://localhost:*/*"]
  }

<span class="new">, "content_scripts": [ {
    "matches": ["&lt;all_urls&gt;"]
  , "exclude_matches": ["http://localhost:*/*"]
  , "js": [
      "js/content.js"
    ]
  } ]</span>
}</pre>

  <h3><code>content_scripts</code></h3>
  <p>The <a href="https://developer.chrome.com/extensions/content_scripts#registration"><code>content_scripts</code> manifest property</a> defines an array of map objects. Each object must include:</p>
  <ul>
  <li>A <code>"matches"</code> property, whose value must be an array of <a href="https://developer.chrome.com/extensions/match_patterns">match patterns</a>. Since you want the Annotation extension to run anywhere, you can use the pattern <code class='pre'>"&lt;all_urls&gt;"</code>.</li>
  </ul>
  <p>The object should also include one or both of the following:</p>
  <ul>
  <li>A <code>"js"</code> property, whose value is an array of URLs for javascript files</li>
  <li>A <code>"css"</code> property, whose value is an array of URLs for CSS files</li>
  </ul>

  <p>For now, you don't need to inject any CSS, so it's enough to have the entry for <code>"js"</code>. You'll find the JavaScript code for the <code>content.js</code> file below.</p>

  <p>In this case, you want to prevent the content script from being injected into your NoteBook pages, so you can include an optional <code>"exclude_matches"</code> property:</p>
  <ul>
  <li>The <code>"exclude_matches"</code> property is an array of <a href="https://developer.chrome.com/extensions/match_patterns">match pattern</a> strings. In this case you should use the same pattern that you used as a "match" for the <code>"externally_connectable"</code> property in the last section: <code>"http://localhost:*/*"</code>.</li>
  </ul>

  <h3><code>content.js</code></h3>
  <p>Now you can create a file in the <code>js/</code> folder, called <code>content.js</code>. Its role will be to detect when the selected text in the page changes, and to inform the background script.</p>

<pre>"use strict"

;(function content(){

  var selectedText = ""

  function checkSelection(event) {
    var selection = document.getSelection()
    var text = selection.toString()
    var message

    if (selectedText !== text) {
      selectedText = text
      message = {
        method: "changeSelection"
      , data: selectedText
      }

      chrome.runtime.sendMessage(message)
    }
  }

  document.body.addEventListener("mouseup", checkSelection, false)
  document.body.addEventListener("keyup", checkSelection, false)
})()</pre>

  <p>This content script sets up the <code>checkSelection</code> function as a listener for <code>mouseup</code> and <code>keyup</code> events. If the text selected in the page has changed, a message object is created, with a <code>method</code> and a <code>data</code> property. This message is then sent to the background script using <code><a href="https://developer.chrome.com/extensions/runtime#method-sendMessage">chrome.runtime.sendMessage</a></code> </p>

  <div class="aside note">The <code>chrome.runtime.sendMessage</code> method is a simpler way of sending messages to the background script than setting up a port using <code>chrome.runtime.connect</code>, like you saw in the last section. It sets up a temporary connection for a single message and an optional response. A listener in the background script will receive three parameters:
  <ul>
  <li>The <code>request</code> object – in this case: <code>{ method: "changeSelection" , data: selectedText }</code></li>
  <li>A <code>sender</code> object, indicating which content script sent the message</li>
  <li>A <code>sendResponse</code> callback function that can be used to send a reply.</li>
  </ul>
  <p>In this case, no reply is needed, so <code>sender</code> and <code>sendResponse</code> is ignored in the background script below.</p></div>
  <h3>background.js</h3>
  <p>The two-way communication that you set up between the background script and your NoteBook page script in the last section only needs to work in one direction for now. In this section, the page script will still be initializing the connection, but it won't be sending any messages of its own to the background script, and the <code>ping</code> feature was just for testing, so you can remove it.</p>
  <p>To respond to the <code>chrome.runtime.sendMessage()</code> call that you make in the content script, you can add the <code>treatMessage</code> function as a listener to the <code>chrome.runtime.onMessage</code> object. The <code>treatMessage</code> function below checks for a <code>method</code> property in the incoming <code>request</code>, and calls the appropriate function. For now, it only has one method to handle: <code>changeSelection</code>. By using a <code>switch</code> statement, you will easily be able to handle more method requests in the future.</p>
  <p>The <code>changeSelection</code> function checks if the two-way port to the NoteBook page script is open, and if so, simply forwards the request.</p>
  <div class="optional tips">
    <input type="checkbox" id="-details"/>
    <label for="-details">Learn more about the chrome object</label>
    <div>
  <p>Chrome does not allow you to send a message directly from one tab to another: you must always pass through your extension's background script. The <code>chrome</code> object accessible to content scripts has no knowledge of other tabs. Only the <code>chrome</code> object available in the background script has a <code>tabs</code> property.</p>
  <figure>
  <img src="img/content_chrome.png" alt="The chrome object in content scripts has no tabs property" />
  <figcaption>Figure 20. The <code>chrome</code> object in content scripts has no <code>tabs</code> property</figcaption>
  </figure>
  <p>Compare with the <code>chrome</code> objects you have already seen in other scopes:</p>
  <figure>
  <img src="img/page_chrome.png" alt="page chrome object" />
  <figcaption>Figure 10. The <code>chrome</code> object available in standard windows</figcaption>
  </figure> 

  <figure>
  <img src="img/background_chrome.png" alt="background chrome object" />
  <figcaption>Figure 11. The <code>chrome</code> object available to background scripts</figcaption>
  </figure>
    </div>
  </div>
<pre class="revised">"use strict"

;(function background(){

  var port

  function useExtension() {
    // code omitted for clarity
  }

  function openConnection(externalPort) {
    port = externalPort
    port.onMessage.addListener(incoming)
  }

  function incoming(message) {
    <span class="new">// TODO</span>
  }

  <span class="new">function treatMessage(request, sender, sendResponse) {
    switch (request.method) {
      case "changeSelection":
        changeSelection(request)
      break
    }
  }

  function changeSelection(request) {
    if (!port) {
      console.log("Request not treated:", request)
      return
    }

    port.postMessage(request)
  }

  chrome.runtime.onMessage.addListener(treatMessage)</span>
  chrome.runtime.onConnectExternal.addListener(openConnection)
  chrome.browserAction.onClicked.addListener(useExtension)
})()</pre>

  <h3>The NoteBook page script: <code>main.js</code></h3>
  <p>The background script now use the <code>port.sendMessage</code> function to send a message to the page script in your NoteBook window. You can use a <code>switch</code> statement in the <code>incoming</code> function to forward the request to the appropriate function. In this case, all the <code>changeSelection</code> function needs to do it to set the <code>innerHTML</code> of the <code>#selection</code> paragraph to the string of text that was initially selected in the main window.</p>

<pre class="revised">Meteor.startup(function() {
  var extensionId = "<span class="ymmv">use your own extension ID here</span>"
  var port = chrome.runtime.connect(extensionId)
  var p = document.getElementById("selection")

  <span class="new">function incoming(request) {
    switch (request.method) {
      case "changeSelection":
        changeSelection(request.data)
      break
    } 
  }

  function changeSelection(selection) {
    p.innerHTML = selection
  }</span>

  port.onMessage.addListener(incoming)
})</pre>

  <figure>
  <img src="img/selected_text.png" alt="Text selected in the main window is copied to the NoteBook window" />
  <figcaption>Figure 21. Text selected in the main window is copied to the NoteBook window</figcaption>
  </figure>

  <div class="optional trouble">
  <input type="checkbox" id="actions-trouble"/>
  <label for="actions-trouble">Troubleshooting </label>
  <div>
  <p class="symptom">No text appears in the NoteBook when you select text in the main window</p>
  <ul>
  <li>Ensure that the value of <code>extensionID</code> in the <code>main.js</code> script in Meteor <code>client</code> folder matches the ID value given in the Chrome Extensions management window.</li>
  </ul>
  <p class="aside mail">If this doesn't solve your problem, please <a href="https://github.com/lexogram/openbook/issues/new">tell us what happened</a> and we'll do our best to find a solution for you.</p>
  </div>
  </div>

  <div class="aside next">In this section, you've used the <code>manifest.json</code> file to define a content script to inject into all third-party web pages. You've used <code>match</code> patterns to include and exclude the pages into which the content script is injected. You've used sent a one-off message to the background script, and used the two-way connection you created in the last section to forward it to your NoteBook window.
  <p>You've used the following expressions that are specific to Chrome extensions:</p>
  <ul>
  <li><code>"content_scripts"</code> </li>
  <li><code>"exclude_matches"</code> </li>
  <li><code>chrome.runtime.sendMessage()</code> </li>
  <li><code>chrome.runtime.onMessage.addListener()</code></li>
  </ul>
  <p>In the <a href="#server">next section</a>, you'll see how the client-side scripts in your Meteor NoteBook application can call methods on the Meteor server, and how to retrieve the result of the call.</p>
  </div>

  <footer>
    <ul class="nav">
    <li>
    <a href="#server">
    <img src="../img/arrow.png" alt="next"/>
    </a>
    </li>
    </ul>
  </footer>
</section>

<!-- SERVER -->
<section id="server">
  <h2>Writing a server-side script</h2>
  <p>Now you can send text from any third-party web-site to your Meteor page running in the NoteBook window. This means that you are ready to send the selected text to your server. There you can do all sorts of server-side analysis on it and send the results back to display them in your NoteBook. Eventually, the plan is to connect to a database but for now, you can simply check that the next link in the chain of communication is working: getting a browser page to interact with the server.</p>
  <div class="aside preview">In this section, you'll learn how to:
  <ul>
  <li>Create a server-side script using JavaScript</li>
  <li>Read in a file on the server</li>
  </ul>
  <a href="https://github.com/lexogram/notebook-extension/raw/master/tutorial/zips/06_server.zip" target="source">Download the source files</a>
  </div>

  <h3>JavaScript on the server</h3>
  <p>The Meteor server runs on <a href="https://nodejs.org/en/">Node.js</a>. For this tutorial, all you need to know about Node.js is that:</p>
  <ul>
  <li>You can control it by writing JavaScript that runs on the server</li>
  <li>It provides you with a set of built-in packages that extend what you can do with JavaScript. The commands associated with these special packages is shown in <span class="red">red</span> in the script extract below.</li>
  </ul>

  <p>To test reading a file into your server-side script, you can create a new file in the folder for your Meteor app:</p>
  <pre>File read successfully.</pre>
  <p>You can call it <code>words.txt</code> and save it in the folder <code>public/data/</code>.</p>

  <figure>
  <img src="img/server-side.png" alt="The server-side main.js file and the word.txt document" />
  <figcaption>Figure 22. The server-side main.js file and the word.txt document</figcaption>
  </figure>

  <h3>Editing the server-side<code>main.js</code> script</h3>
  <p>You can edit the file <code>server/main.js</code> as shown below:</p>
<pre class="revised"><span class="new">"use strict"</span>

import { Meteor } from 'meteor/meteor'

Meteor.startup(() => {
  <span class="new">readInWordsFile()</span>
});

<span class="new">function readInWordsFile() {
  console.log('reading words.txt')
  var fs = <span class="red">Npm.require('fs')</span>
  var relative = '/../web.browser/app/data/words.txt'
  var path = <span class="red">process.cwd()</span> + relative

  function fileReadCallback(error, data) {
    if (error) {
      console.log('Error: ' + error)
      return
    }

    console.log(data)
  } 

  <span class="red">fs.readFile</span>(path, 'utf8', fileReadCallback)
}</span></pre>

  <p>When Meteor restarts, you should see something like this in the Terminal window:</p>

<pre>=> Started MongoDB.
<span class="ymmv">TIMESTAMP</span> reading words.txt
<span class="ymmv">TIMESTAMP</span> File read successful
=> Started your app.

=> App running at: http://localhost:3000/
</pre>

  <h3>The Node File System package</h3>
  <p>Meteor runs on Node.js and Node.js can be extended with <span class="keyword">packages</span> using <code>Npm</code>, the <span class="keyword">Node package manager</span>. To use JavaScript to read a file from the server you can use the <a href="https://nodejs.org/api/fs.html">fs</a> package. where "fs" stands for File System. You need to tell your Meteor application to use the <code>fs</code> package, and that's what the following line does:</p>
  <pre>var fs = Npm.require('fs')</pre>
  <p>The variable <code>fs</code> now contains an object which provides a complete set of functions for interacting with the server file system, including <code>readFile</code>.</p>
  <h3><code>readfile</code></h3>
  <p>The <code><a href="https://nodejs.org/api/fs.html#fs_fs_readfile_file_options_callback">readFile</a></code> method takes three parameters:</p>
  <ul>
  <li>A string absolute file path</li>
  <li>A string or an object that sets options</li>
  <li>A callback handler</li>
  </ul>
  <h4>The file path</h4>
  <p>You saved the <code>words.txt</code> file at <code>public/data/words.txt</code> but the file path used in the code above is quite different. The call to <code>process.cwd</code>, where "cwd" stands for "current working directory", will return something like:</p>
  <pre><span class="ymmv">/My/Folder/</span>.meteor/local/build/programs/</pre>
  <p>This means that the path defined above will be something like:</p>
  <pre class="wrap"><span class="ymmv">/My/Folder/</span>.meteor/local/build/programs/web.browser/app/data/words.txt</pre>
  <p>This is very different from the path to the file that you saved:</p>
  <pre><span class="ymmv">/My/Folder/</span>public/data/words.txt</pre>
  <p>The reason is that Meteor manipulates your files and rearranges them when the application launches. For you, the folder hierarchy that you use while developing is easy to follow; for Meteor the folder hierarchy is optimized for delivering your content.</p>
  <figure>
  <img src="img/path-to-data-folder.png" alt="The path to the data folder in the compiled Meteor app" />
  <figcaption>Figure 23. The path to the data folder in the compiled Meteor app</figcaption>
  </figure>
  <h4>The callback</h4>
  <p class="aside info">For performance reasons, any Node.js function that may take a significant amount of time to do its job is implemented in an <span class="keyword">asynchronous</span> fashion. You can think of this a being like an email message, as compared to a phone call: you can be busy doing other things while you wait for a reply to an email, whereas you expect to stay on the line to receive a reply during a phone call.</p>
  <p><code>fs.fileread</code> is an asynchronous function: you need to provide a callback function which will handle the result of the <code>fileread</code> call, when the reading process has completed. The result will either provide an error message or the contents of the file. This initial version of the script is written so that, in either case, something printed out in the Terminal window.</p>

  <h3>Reading in a JSON file</h3>
  <p>The <code>words.txt</code> file is only useful insofar as it shows you that your server-side script is working. For the purposes of this tutorial, a more useful file would contain information about the words that you select in the main browser window.</p>
  <p>In the <a href="https://github.com/lexogram/notebook-extension/raw/master/tutorial/zips/06_call.zip" target="source">downloadable source files for this section</a>, you can find a file named <code>words.json</code>. This contains frequency data for the 10,000 most commonly used words in journalistic English.</p>

<pre>{ "the": { "index": 1, "count": 56271872 }
, "of": { "index": 2, "count": 33950064 }
, "and": { "index": 3, "count": 29944184 }
, "to": { "index": 4, "count": 25956096 }
, "in": { "index": 5, "count": 17420636 }
<span class="ymmv">...</span>
, "cooperation": { "index": 9997, "count": 3924.81 }
, "sequel": { "index": 9998, "count": 3924.02 }
, "wench": { "index": 9999, "count": 3924.02 }
, "calves": { "index": 10000, "count": 3923.23 }
}
</pre>

  <p>You can place this in the <code>public/data/</code> folder, and then edit your <code>main.js</code> file in the <code>server</code> folder, as shown below:</p>
<pre class="revised">"use strict"

import { Meteor } from 'meteor/meteor'

var wordFrequencies = {}

Meteor.startup(() => {
  readInWordsFile()
});

function readInWordsFile() {
  console.log('reading words.txt')
  var fs = Npm.require('fs') 
  var relative = '/../web.browser/app/data/words.<span class="new">json</span>'
  var path = process.cwd() + relative

  function fileReadCallback(error, data) {
    if (error) {
      console.log('Error: ' + error)
      return
    }

    <span class="new">try {
      wordFrequencies = JSON.parse(data)
      console.log(wordFrequencies["the"])
    } catch(err) {
      console.log("data is not in JSON format:", err)     
    }</span>
  } 

  fs.readFile(path, 'utf8', fileReadCallback)
}</pre>

  <p>If all goes well, when Meteor restarts, you should now see something like this:</p>

  <pre>=> App running at: http://localhost:3000/
<span class="ymmv">TIMESTAMP</span> reading words.txt 
<span class="ymmv">TIMESTAMP</span> { index: 1, count: 56271872 }
=> Meteor server restarted</pre>

  <div class="aside next">In this section, you've written and tested a server-side script that reads in and parses a JSON file from the server. You've used the following Meteor-specific methods:
  <ul>
  <li>Npm.require()</li>
  <li>process.cwd()</li>
  </ul>
  <p>You've also learned the following Node package methods:</p>
  <ul>
  <li><span class="ymmv">fs.</span>readfile(...)</li>
  </ul>
  <p>In the <a href="#call">next section</a>, you'll see how to create server-side methods and call them from your NoteBook page in the browser.</p>
  </div>

  <footer>
    <ul class="nav">
    <li>
    <a href="#call">
    <img src="../img/arrow.png" alt="next"/>
    </a>
    </li>
    </ul>
  </footer>
</section>

<!-- CALL -->
<section id="call">
  <h2>Talking to the server from the browser</h2>
  <p>Now that you have JavaScript running on your server, it's time to use the power of Meteor to call a method on your server from the browser.</p>
  <div class="aside preview">In this section, you'll learn how to:
  <ul>
  <li>Write a server-side method that returns a value</li>
  <li>Declare the server-side method so that Meteor can call it from the browser</li>
  <li>Call the server-side method from your browser console and retrieve its return value</li>
  <li>Use the data read in from <code>words.json</code> to analyze the text sent from the server</li>
  <li>Display the analyzed data in the browser console</li>
  </ul>
  <a href="https://github.com/lexogram/notebook-extension/raw/master/tutorial/zips/07_call.zip" target="source">Download the source files</a>
  </div>

  <p>Meteor is designed to make two-way communication between the browser and the server as simple as possible. However, for security reasons, you want to be sure that only authorized browser pages can call only the authorized methods on the server. To allow you to do this, Meteor provides a server-side <code>Meteor.methods</code> function which tells the Meteor app which server-side methods to open up to calls from the browser.</p>
  <p>In your public server-side calls, you should check that the incoming data you receive is in the format you expect. The version of <code>main.js</code> below defines a method called <code>analyzeText</code>, which checks that it has received an argument with a structure like <code>{ data: "some string" }</code>. If so, it returns the value of the string (for now); if not, it returns a string describing the error.</p>
  <h4><code>main.js</code> (server)</h4>
<pre class="revised">"use strict"

import { Meteor } from 'meteor/meteor'

var wordFrequencies = {}

Meteor.startup(function () {
  <span class="new">defineMethods()</span>
  readInWordsFile()
})

<span class="new">function defineMethods() {
  Meteor.methods({
    analyzeText: analyzeText
  })
}</span>

function readInWordsFile() {
  console.log('reading words.json')
  var fs = Npm.require('fs')
  var relative = '/../web.browser/app/data/words.json'
  var path = process.cwd() + relative

  function fileReadCallback(error, data) {
    if (error) {
      console.log('Error: ' + error)
      return
    }

    wordFrequencies = JSON.parse(data)
    console.log(wordFrequencies["the"])
  } 

  fs.readFile(path, 'utf8', fileReadCallback)
}

<span class="new">function analyzeText(options) {
  // options = { data: &lt;string&gt; }
  var type = typeof options
  var text

  if (type !== "object" || options === null) {
    return "Object expected in analyzeText: " + type

  } else {
    text = options.data
    type = typeof text
    if (type !== "string") {
      return "String expected in analyzeText: " + type
    }
  }

  return text
}</span>
</pre>

<h3>Testing from the browser console</h3>
<p>If you open the JavaScript Console for your NoteBook window, you can execute the following command. You'll see the output in Figure 24.</p>
<pre><span class="red">Meteor.call</span>(
  "analyzeText"
, { data: "text to analyze" }
, function (error, response) { 
    if (error) {
      console.log ("Error:", error)
    } else {
      console.log ("Response:", response)
    }
  }
)</pre>

<figure>
<img src="img/meteor_call.png" alt="Using Meteor call from the browser console" />
<figcaption>Figure 24. Using Meteor.call(...) from the browser console</figcaption>
</figure>

<h3><code>Meteor.call</code></h3>
<p>Executed from a browser script, <code><a href="https://docs.meteor.com/api/methods.html#Meteor-call"></a>Meteor.call</code> takes any number of arguments.</p>
<ul>
<li>The first should be the name of a method that has been defined on the server with the <code>Meteor.methods()</code> function.</li>
<li>The last can be a callback function that will called with the result sent from the server.</li>
<li>The intervening arguments can be anything you want that can be converted to a string for transfer across the network. In this case, the object <code>{ data: "text to analyze" }</code> is stringified and sent in JSON format, then restored to an object on the server.</li>
</ul>

<h3><code>analyzeText</code></h3>
<p>The script above just shows you how you can use <code>Meteor.call</code> to send data from the browser to the server, and receive a result from the call. The next step is to use the <code>wordFrequencies</code> data read in from the <code>words.json</code> file to perform a simple analysis of the text sent from the browser.</p>
<p class="aside info">In the <a href="../notebook/">NoteBook tutorial</a>, you'll see how to interact with a Neo4j database, and return much more interesting data concerning the text that is sent to the server.</p>

<p>You can edit your server-side <code>main.js</code> script so that the <code>analyseText</code> method appears as shown below.</p>

<pre class="revised">"use strict"

import { Meteor } from 'meteor/meteor'

var wordFrequencies = {}

<span class="ymmv">// Code trimmed for readability</span>

function analyzeText(options) {
  // options = { data: &lt;string&gt; }
  var type = typeof options
  var text

  if (type !== "object" || options === null) {
    return "Object expected in analyzeText: " + type

  } else {
    text = options.data
    type = typeof text
    if (type !== "string") {
      return "String expected in analyzeText: " + type
    }
  }

  <span class="new">var words = text.split(/\W/)
  var output = []
  var treated = []
  var total
    , ii
    , word
    , wordData
    , count
    , data

  // Convert all words to lowercase
  words = words.map(function toLowerCase(word) {
    return word.toLowerCase()
  })

  // Ignore unknown words, word fragments and duplicates
  words = words.filter(function registeredWordsOnly(word, index) {
    return !!wordFrequencies[word] &amp;&amp; words.indexOf(word) === index
  })

  words.sort(function byFrequency(word1, word2) {
    var result = -1
    if (wordFrequencies[word1].index&gt;wordFrequencies[word2].index){
      result = 1
    }

    return result
  })

  // Add all filtered words to the output
  total = words.length  
  for (ii = 0; ii &lt; total; ii += 1) {
    word = words[ii]
    wordData = wordFrequencies[word]
    data = { 
      word: word
    , index: wordData.index
    , count: wordData.count
    }

    output.push(data)
  }

  return output</span>
}</pre>

<p>This function now filters out all unknown and duplicate words, arranges the known words in order from the most frequent to the least frequent, and then returns an array with the format:</p>
<pre>[ { word: &lt;string&gt;, index: &lt;integer&gt;, count:  &lt;number&gt; }
, ...
]</pre>

<p class="aside warn">The <code>analyzeText</code> function above will fail if you use it on text that is not written in a Latin script. This is because, in JavaScript, the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions">regular expression</a> <code>/\W/</code> <a href="http://stackoverflow.com/a/5596262/1927589">does not recognize word boundaries in non-Latin scripts</a>, like руский, ไอต or 日本語. As a workaround, you will need to use <a href="http://stackoverflow.com/questions/23458872/javascript-regex-word-boundary-b-issue">language-specific regular expressions</a>. For languages such as Thai, where words are not separated by spaces, the appropriate regular expression may be rather complex. Indeed, even in English, words like "won't" will not be treated correctly, because <code>/\W/</code> treats the apostrophe as a word boundary.</p>

<p>You can save the edited <code>main.js</code> file and wait for the Meteor server to restart, and then you repeat the call to <code>analyzeText</code>. This time, the response should be an array of objects.</p>

<figure>
<img src="img/meteor_call2.png" alt="The browser console shown the response from the edited analyzeText method" />
<figcaption>Figure 25. The browser console shown the response from the edited <code>analyzeText</code> method</figcaption>
</figure>

<p class="aside note">Notice that the word "analyze" is not included in the results, because it does not appear in the <code>word.json</code> document (although "analyzed" does appear there, because it is more common).</p>

  <div class="aside next">In this section, you've declared a server-side method so that it can be called from the browser, and you've tested this feature from the browser's console.</p>
  <p>You've also used the following Meteor-specific methods:
  <ul>
  <li>Meteor.methods</li>
  <li>Meteor.call</li>
  </ul>
  <p>In the <a href="#template">next section</a>, you'll see how to integrate this browser-server round-trip communication with the text selection detection that you worked on <a href="#actions">earlier</a>. You'll also discover how to use Meteor's <span class="keyword">Blaze</span> templates to create HTML elements whose contents updates automatically as new data is received from the server.</p>
  </div>

    <footer>
      <ul class="nav">
      <li>
      <a href="#template">
      <img src="../img/arrow.png" alt="next"/>
      </a>
      </li>
      </ul>
    </footer>
</section>

<!-- TEMPLATE -->
<section id="template">
  <h2>Using a Blaze template</h2>
  <div class="aside preview">In this section, you'll learn how to:
  <ul>
  <li>Create a reactive Meteor template using Blaze to display the results of the call</li>
  </ul>
  <a href="https://github.com/lexogram/notebook-extension/raw/master/tutorial/zips/08_template.zip" target="source">Download the source files</a>
  </div>

  <h3>Reactive programming in Meteor: Blaze, Angular and React</h3>
  <p>Meteor 1.3 provides three different <span class="keyword">view layers</span>: <a href="https://guide.meteor.com/blaze.html">Blaze</a>, <a href="http://www.angular-meteor.com/">Angular</a> and <a href="https://guide.meteor.com/react.html">React</a>. Each of these allows you to create pages that update automatically as new information becomes available on the server, and each works in a radically different way. For this tutorial, I have chosen to use Meteor's proprietary Blaze templating system, but if you are more familiar with one of the others, you can adapt the code below to suit your preferred workflow.</p>
  <h3>Blaze</h3>
  <p>With Blaze, you write HTML pages that have a non-HTML feature: special <span class="keyword">spacebar</span> tags, using double curly brackets, like this: <code>{{&gt; templateName}}</code>. It uses these in conjunction with standard <a href="http://www.html5rocks.com/en/tutorials/webcomponents/template/">template tags</a>, which look like this: <code>&lt;template name="templateName"&gt; ... &lt;/template&gt;</code></li>
  </ul>
  <p>Thanks to Meteor, your custom HTML page is delivered to the browser along with a serious chunk of JavaScript, which gives you new powers. In particular, the Meteor JavaScript:</p>
  <ul>
  <li>Allows you to access the features of a global <code>Template</code> object, which can customize the data displayed in your <code>&lt;template&gt;</code> tags</li>
  <li>Replaces your <code>{{spacebar}}</code> tags with the appropriate &lt;template&gt;</li>
  </ul>
  <p>Here's a revised version of the HTML for your Notebook page, so that you can see all this in action:</p>
  <h4><code>main.html</code></h4>
<pre class="revised">&lt;head&gt;
  &lt;title&gt;NoteBook&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;p id="selection"&gt;&lt;/p&gt;
  
  <span class="new">&lt;table border="1"&gt;
    &lt;tr&gt;
      &lt;th&gt;Word&lt;/th&gt;
      &lt;th&gt;Index&lt;/th&gt;
      &lt;th&gt;Count/Billion&lt;/th&gt;
    &lt;/tr&gt;
      {{&gt; rows}}
  &lt;/table&gt;</span>
&lt;/body&gt;
 
<span class="new">&lt;!-- TEMPLATES --&gt;

&lt;template name="rows"&gt;
  {{#each rows}}
    &lt;tr&gt;
      &lt;td&gt;{{word}}&lt;/td&gt;
      &lt;td&gt;{{index}}&lt;/td&gt;
      &lt;td&gt;{{count}}&lt;/td&gt;
    &lt;/tr&gt;
  {{/each}}
&lt;/template&gt;</span></pre>

<p>The first half of the new HTML markup creates a table with three columns, each with its own header. You can add some style to the table by editing the <code>main.css</code> file in <code>NoteBook/client/</code> folder inside your Meteor project:</p>  
  <h4><code>main.css</code></h4>
<pre class="revised">p#selection {
  min-height: 2em;
  width: 100%;
  background-color: #ddd;
  border: 1px solid #ccc;
  border-bottom-color: #eee;
  border-right-color: #eee;
}

<span class="new">table {
  border: 1px solid #000;
  border-collapse: collapse;
  min-width: 200px;
  width: 100%;
}
th {
  background-color: #ccc;
  padding: 0.1em 0.25em;
}
td {
  padding: 0 0.25em;
}
td {
  text-align: right;
}
td:first-child {
  text-align: left;
}</span></pre>

<p>When Meteor finishes reloading your app, your NoteBook page should look like this:</p>
<figure>
<img src="img/empty_table.png" alt="The empty table in the NoteBook window" />
<figcaption>Figure 26. The empty table in the NoteBook window</figcaption>
</figure>
<p>If you inspect the HTML markup, you will see that the <code>{{> rows}}</code> spacebars tag and the <code>&lt;template name="rows"&gt;</code> tag have not been rendered. To fill these rows, you'll need to modify the code in the <code>main.js</code> file in the <code>NoteBook/client/</code> folder, as shown below.</p>
<div class="aside issue">Meteor uses <span class="keyword">packages</span> to extend its capabilities. The <code>main.js</code> code shown below will not run until you add the <a href="http://docs.meteor.com/api/session.html">Session package</a>. To do this, stop the Meteor app in the Terminal window, using the shortcut <code>ctrl-C</code> , then run <code>meteor add session</code>:
<pre><span class="revised">=> App running at: http://localhost:3000/</span>
<span class="new">^C</span>
$ <span class="new">meteor add session</span>
                                              
Changes to your project's package version selections:
                                              
reactive-dict  added, version 1.1.8           
session        added, version 1.1.6

                                              
session: Session variable</pre>
<p>When the Session package has been installed, you can restart the Meteor app:</p>
<pre>$ <span class="new">meteor run</span>
[[[[[ <span class="ymmv">/Path/to/folder/for/NoteBook</span> ]]]]]

=> Started proxy.                             
=> Started MongoDB.
=> Started your app.                          

=> App running at: http://localhost:3000/<span class="new"></span></pre></div>
  <h4><code>main.js</code> (client)</h4>
<pre class="revised"><span class="new">import { Template } from 'meteor/templating'
import { Session } from 'meteor/session' 

<span class="red">Session</span>.set("rows", [])
 
Template.rows.helpers({
  rows: function rows() {
    return Session.get("rows")
  }
});</span>

Meteor.startup(function() {
  var extensionId = "dfhlekkdciiblbidbchopphkalomlblf"
  // Use your own extension id ^
  var port = chrome.runtime.connect(extensionId)
  var p = document.getElementById("selection")

  function incoming(request) {
    switch (request.method) {
      case "changeSelection":
        changeSelection(request.data)
      break
    } 
  }

  function changeSelection(selection) {
    p.innerHTML = selection
    <span class="new">Meteor.call("analyzeText", { data: selection }, updateTable)</span>
  }

  <span class="new">function updateTable(error, data) {
    if (error) {
      console.log(error)
    } else {
      <span class="red">Session</span>.set("rows", data)
    }
  }</span>

  port.onMessage.addListener(incoming)
})</pre>

<h3>Session</h3>
<p>The <a href="http://docs.meteor.com/api/session.html">Session package</a> creates a global object named <code>Session</code> which allows you to store <span class="keyword">reactive</span> data. Any time any reactive data is changed, the Blaze templates will update to display the new data.</p>
<figure>
<img src="img/filled_table.png" alt="The contents of the table changes as you change the selection" />
<figcaption>Figure 26. The contents of the table changes as you change the selection</figcaption>
</figure>

<p>The <code>updateTable</code> callback function receives the array of objects that is sent back from the <code>analyzeText</code> server-side method, and tells the <code>Session</code> global to update the value of its <code>rows</code> property. After the selection made in Figure 26 above, <code> Session.get("rows")</code> will now return the array shown below (prettified for readability):</p>
<pre>[ { count: 56271872,   index:    1, word: "the" }
, { count: 25956096,   index:    4, word: "to" }
, { count:  7557477,   index:   13, word: "is" }
, { count:  2320022,   index:   48, word: "will" }
, { count:  1665366,   index:   58, word: "any" }
, { count:  1449681,   index:   69, word: "time" }
, { count:   498040,   index:  175, word: "new" }
, { count:    27765.6, index: 2788, word: "display" }
, { count:    20722.9, index: 3542, word: "data" }
, { count:    12952.4, index: 5098, word: "blaze" }
]</pre>

<h3><code>{{#each rows}}</code></h3>
<p>In your <code>main.html</code> file, the template named <code>"rows"</code> is defined as</p>
<pre>  {{#each <span class="red">rows</span>}}
    &lt;tr&gt;
      &lt;td&gt;{{word}}&lt;/td&gt;
      &lt;td&gt;{{index}}&lt;/td&gt;
      &lt;td&gt;{{count}}&lt;/td&gt;
    &lt;/tr&gt;
  {{/each}}</pre>
<p>In your <code>main.js</code> file, you have defined a Template property called <code>rows</code> which returns the value of the <code> Session.get("rows")</code> array:</p>
<pre>Template.rows.helpers({
  <span class="red">rows</span>: function rows() {
    return Session.get("rows")
  }
})</pre>
<p>The second half of the new HTML markup defines the template that will be used to format the data to be displayed instead of the <code>{{> rows}}</code> spacebars tag. The <code>{{<a href="http://meteorcapture.com/spacebars/#each">#each</a> rows}}</code> spacebars tag tells Meteor to take each object in the array in turn, and insert the value of the appropriate key in place of the key, so that <code>{{word}}</code>, for the first item in the array, for example, becomes <code>the</code> in the table.</p>
  <div class="aside next">In this section, you've used the power of Meteor's Blaze templating system to create a table in the NoteBook window that updates automatically each time you change the selection in the main browser page. To achieve this, you've used:
  <ul>
  <li>The <code>&lt;template&gt;</code> HTML tag</li>
  <li>Blaze's custom spacebars <code>{{ ... }}</code> tags</li>
  <li>Meteor's reactive Session package</li>
  <li>Meteor's Template and Session globals</li>
  <li>The <code>{{#each ...}}</code> spacebars syntax</li>
  </ul>
  <p>You've completed all the following steps, that were originally outlined in the <a href="#connection">Creating a connection</a> section:</p>
  <ol>
  <li>A content script< in the web page will tell the background script about the selection</li>
  <li>The background script will forward information to a page script in the NoteBook window</li>
  <li>The client-side page script in the NoteBook window will send a message to a server-side script on the Meteor server</li>
  <li>The server-side script will <em>perform a simple operation on the incoming text and send the result</em> back to the client-side page script in the NoteBook window</li>
  <li>The NoteBook window will update</li>
  </ol>
  <p>However, the following steps remain to be completed:</p>
  <ol>
  <li>The page script in the NoteBook window will send some of the information it received to the background script</li>
  <li>The background script will forward the information to the content script in the web page you are reading</li>
  <li>The display of the web page will update.</li>
  </ol>
  <p>In the <a href="#toolbar">next section</a>, you'll see how to inject HTML into the main content page, in order to create a Toolbar that indicates that your Annotation extension is active.</p>
  </div>

  <footer>
    <ul class="nav">
    <li>
    <a href="#toolbar">
    <img src="../img/arrow.png" alt="next"/>
    </a>
    </li>
    </ul>
  </footer>
</section>

<!-- TOOLBAR -->
<section id="toolbar">
  <h2>Inserting a toolbar into the current tab</h2>
   <div class="aside preview">In this section, you'll learn how to:
  <ul>
  <li>Inject HTML into third-party content pages</li>
  <li>Use CSS to place a static toolbar at the top of the window</li>
  </ul>
  <a href="https://github.com/lexogram/notebook-extension/raw/master/tutorial/zips/09_toolbar.zip" target="source">Download the source files</a>
  </div>
  <p>Your users will probably not be working with your Annotation extension all the time. They will want it available only on pages in the language(s) they are learning, and the will want to see when it is active and when it is not, and they will want to Deactivate it when they no longer need it.</p>
  <p>You can provide this functionality through a Toolbar at the top of the page, as shown if Figure 24 below. In the next section, you'll learn how to use the Toolbar to switch off the Annotation extension for the current page; in section 17: <a href="#toggle">Toggling the display</a> you'll see how to toggle between the annotated and original versions of the page.</p>
 
  <figure>
  <img src="img/toolbar.png" alt="The first version of the Toolbar injected into a third-party page" />
  <figcaption>Figure 24. The first version of the Toolbar injected into a third-party page</figcaption>
  </figure>

  <h3>Injected Files</h3>
  <p>You can create two new files <code>inject.html</code> and <code>inject.css</code> and save them in folders named <code>html</code> and <code>css</code> as shown below:</p>
  <figure>
  <img src="img/injected_files.png" alt="Saving inject.css and inject.html in your extension folder" />
  <figcaption>Figure 25. Saving inject.css and inject.html in your extension folder</figcaption>
  </figure>
  <h4>inject.html</h4>
  <p>Here's the HTML that you can use in your <code>inject.html</code> file. Notice that it adds a <code>section</code> element with a class of <code>lxo-toolbar</code>, a button, and a link. The link is attached to the character "HEAVY MULTIPLICATION X" &#10006; (<code>&amp;#10006;</code>) which looks good as a close icon.</p>
<pre>&lt;section class="lxo-toolbar"&gt;
  &lt;button type="button"&gt;Show original&lt;/button&gt;
  &lt;a class="close" href="#close"&gt;&amp;#10006;&lt;/a&gt;
&lt;/section&gt;</pre>

<p class="aside note">The &#10006; icon and the <code>Show original</code> button won't do anything yet. You'll be adding code for these in sections 13: <a href="#toggle">Closing the toolbar</a> and 17: <a href="#toggle">Toggling the display</a>.</p>
<div class="aside tip">You might also find that the following special characters can work well as close icons in your own projects:
<ul class="nul">
<li>&#9746;&nbsp;&nbsp;&amp;#9746;</li>
<li>&#10005;&nbsp;&nbsp;&amp;#10005;</li>
<li>&#10007;&nbsp;&nbsp;&amp;#10007;</li>
<li>&#10008;&nbsp;&nbsp;&amp;#10008;</li>
<li>&#10062;&nbsp;&nbsp;&amp;#10062;</li>
</ul>
</div>

<h4>injected.css</h4>
<p>Here are the CSS rules that you can use in your <code>inject.css</code> file. Notice that this creates a margin of 32 pixels above the body of the page, and a toolbar that is 31 + 1 pixels high, which is fixed in the space left by the body margin. It also provides colouring for the &#10006; close icon which changes when the mouse interacts with the link.</p>
<pre>body.lxo-annotations {
  margin-top: 32px;
}

section.lxo-toolbar {
  position: fixed;
  top: 0;
  left: 0;
  height: 31px;
  min-height: 31px;
  min-width: 350px;
  width: 100%;
  padding: 0;
  background-color: #ccc;
  border-bottom: 1px solid #999;
}

a.close {
  text-decoration: none;
  color: #999;
  position: absolute;
  top: 0;
  right: 0;
}

a.close:hover,
a.close:active {
  color: #900;
}</pre>
<h3>Injecting the HTML file</h3>
<p>In order to get Chrome to inject these files into a third-party content page, you're going to have to make changes to both the <code>background.js</code> and the <code>content.js</code> files. You can start with the <code>inject.html</code> file. The <code>background.js</code> code below makes two calls to methods in the <code>content.js</code> script (shown in <em>italics</em>), using <code>chrome.tabs.sendMessage</code>; you'll see the methods from the <code>content.js</code> file in a moment.</p>
<pre class="revised">"use strict"

;(function background(){

  var port
  <span class="new">var injectedHTML = <span class="red">chrome.extension.getURL</span>("html/inject.html")</span>

  function useExtension() {
    <span class="new"><span class="red">chrome.tabs.query</span>(
    { active: true
    , currentWindow: true
    }
  , checkPageStatus)</span>

    if (!port) {
      openNoteBookWindow()
    }
    
    function openNoteBookWindow() {
      // code omitted for clarity
    }

    <span class="new">function checkPageStatus(tabs) {
      var id = tabs[0].id
      var message = { 
        method: "<em>extensionStatus</em>"
      }
      var html // set in customizeContentPage => stateChanged()

      <span class="red">chrome.tabs.sendMessage</span>(id, message, checkExtensionStatus)

      function checkExtensionStatus(response) {
        if (!response.extensionIsActive) {
          customizeContentPage()
        }
      }

      function customizeContentPage() {
        var xhr = new XMLHttpRequest()
        xhr.open("GET", injectedHTML, true)
        xhr.onreadystatechange = stateChanged
        xhr.send()

        function stateChanged() {
          if (xhr.readyState === 4) {
            html = xhr.responseText
            insertToolbar()
          }
        }
      }

      function insertToolbar() {
        var message = { 
          method: "<em>insertToolbar</em>"
        , html: html
        }

        function callback(response) {
          console.log("toolbar inserted", response)
        }

        <span class="red">chrome.tabs.sendMessage</span>(id, message, callback)
      }
    }</span>
  }

  function openConnection(externalPort) {
    // code omitted for clarity
  }

  chrome.runtime.onConnectExternal.addListener(openConnection)
  chrome.browserAction.onClicked.addListener(useExtension)
  chrome.runtime.onMessage.addListener(treatMessage)
})()</pre>

<h3>Step by step</h3>
<p>The new code shown above takes four separate steps after the browser action button is clicked before it's ready to inject any HTML into the content page:</p>
<ol>
  <li>With <code>chrome.tabs.query({ active: true }, checkPageStatus)</code>, it asks Chrome for data concerning the tab where the browser action button has just been clicked, and to call the <code>checkPageStatus</code> when this information is available.</li>
  <li>In <code>checkPageStatus</code>, it gets Chrome to ask this currently active tab if the extension is already active for this tab, using a call to an <code>extensionStatus</code> method in the content script which you will see shortly. It asks Chrome to call the <code>checkExtensionStatus</code> callback function with the result of this enquiry.</li>
  <li>In the <code>checkExtensionStatus</code> callback, if the extension is not already active, a call to <code>customizeContentPage</code> is triggered. This starts an asynchronous AJAX request for the contents of the file <code>inject.html</code> that you created earlier. When this asynchronous call returns with the HTML to insert, the <code>insertToolbar</code> callback method is activated</li>
  <li>The background script can't insert any new HTML directly into the content page, so it forwards the HTML string to a second <code>insertToolbar</code> method in the <code>content.js</code> script, and the job is done.</li>
</ol>
<h3>New Chrome methods</h3>
<p>The code listing above uses 3 Chrome-specific methods:</p>
<ul>
<li>chrome.extension.getURL</li>
<li>chrome.tabs.query</li>
<li>chrome.tabs.sendMessage</li>
</ul>
<p>You've <a href="#window">already seen</a> <code><a href="https://developer.chrome.com/extensions/extension#method-getURL">chrome.extension.getURL</a></code>, when you first created your standalone NoteBook window, but the other two are new.</p>
<p>The <code><a href="https://developer.chrome.com/extensions/tabs#method-query">chrome.tabs.query</a></code> asks Chrome for an array of tab objects that match the query. In this case, the array should return a single object corresponding to the active tab of the current window. The goal in this case is to retrieve the unique <code>id</code> of the active tab, so that messages can be sent from the background script to that particular tab, as described next.</p>
<p>The <code><a href="https://developer.chrome.com/extensions/tabs#method-sendMessage">chrome.tabs.sendMessage</a></code> method will trigger any listeners to the <code>chrome.extension.onMessage</code> event in the content tab defined by the <code>id</code> argument. The result of the call can be handled by a callback. In this case, the message sent to <code>chrome.tabs.sendMessage</code> is an object with a <code>method property</code> and possibly other properties, but it could be any value.</p>

<h3>Updating the <code>content.js</code> script</h3>
<p>The <code>content.js</code> script needs to react to calls sent from the background script using <code>chrome.tabs.sendMessage</code>. This means creating a listener for the <code>chrome.extension.onMessage</code> event. The code below uses the <code>treatMessage</code> function for this. This assumes that the incoming request is an object, and checks for the value of its <code>request</code> property, and then dispatches the call to the appropriate method: <code>extensionStatus</code> or <code>insertToolbar</code>:</p>
<pre class="revised">"use strict"

;(function content(){

  var selectedText = ""
  <span class="new">var extensionIsActive = false
  var cssInjected = false</span>

  document.body.addEventListener("mouseup", checkSelection, false)
  document.body.addEventListener("keyup", checkSelection, false)

  function checkSelection(event) {
    <span class="new">if (!extensionIsActive) {
      return
    }</span>

    var selection = document.getSelection()
    var text = selection.toString()

    if (selectedText !== text) {
      selectedText = text

      chrome.runtime.sendMessage({
        method: "changeSelection"
      , data: selectedText
      })
    }
  }

  <span class="new">function treatMessage(request, sender, sendResponse) {
    switch (request.method) {
      case "extensionStatus":
        extensionStatus(request, sendResponse)
      break
      case "insertToolbar":
        insertToolbar(request)
      break
    }   
  }

  function extensionStatus(request, sendResponse) {
    sendResponse({
      extensionIsActive: extensionIsActive
    , cssInjected: cssInjected
    })
  }

  function insertToolbar(request) {
    </span>// request = {
    //   method: "insertToolbar"
    // , html: &lt;html string&gt;
    // }
      
    <span class="new">var body = document.body
    var injectedDOM = parseAsElements(request.html)
    appendSectionToBody(injectedDOM)
    body.classList.add("lxo-annotations")
    extensionIsActive = true

    return "toolbar inserted"

    function parseAsElements(htmlString) {
      var parser = new DOMParser()
      var tempDoc = parser.parseFromString(htmlString, "text/html")
      return tempDoc.body.childNodes
    }

    function appendSectionToBody(children) {
      var total = children.length
      
      for (var ii = 0; ii < total; ii += 1) {
        body.appendChild(children[0])
      }
    }
  }

  <span class="red">chrome.extension.onMessage.addListener</span>(treatMessage)</span>
})()</span></pre>

<h3>Extension status</h3>
<p>There are now two new variables in <code>content.js</code>:</p>
<ul>
<li><code>extensionIsActive</code> </li>
<li><code>cssInjected</code></li>
</ul>
<p>The <code>extensionIsActive</code> flag serves two purposes. It starts off <code>false</code> and is set to <code>true</code> after the Toolbar section has been displayed. First, this ensures that the Toolbar section is added to the page only once, and second, thanks to the three lines of code added to the <code>checkSelection</code> function, it also ensures that no information is sent to the NoteBook window and on to the server unless the user has explicitly activated the Annotation extension for the current tab. In other words, the presence of the Toolbar informs the user that the Annotation extension is active. In the next section, you'll see how to close the Toolbar and Deactivate the extension.</p>
<p>The <code>cssInjected</code> flag is set to <code>true</code> at the same time as <code>extensionIsActive</code>, but it is never switched back to <code>false</code>. As you will see below, once <code>chrome.tabs.insertCSS</code> has been called from the <code>background.js</code> script, the inserted CSS cannot be removed. The <code>cssInjected</code> flag is used to ensure that the extension's custom CSS rules are not inserted twice.</p>
<h3><code>insertToolbar</code></h3>
<p>The <code>insertToolbar</code> method is only triggered if the Toolbar section is not already present. The <code>request</code> object contains a property named <code>html</code> whose value is the string read in from the <code>inject.html</code> that you created at the beginning of this section. If you edited <code>inject.html</code> and reload your extension, then the Toolbar would display something different.</p>
<div class="aside note">Note the use of the <code><a href="https://developer.mozilla.org/en/docs/Web/API/DOMParser">DOMParser</a></code> object to convert a string into DOM document.
<p>The individual children of this temporary DOM document are then appended to the <code>body</code> of the document. As each child is appended to the document <code>body</code>, it is removed from the temporary DOM document, so the next child to add will always be element <code>0</code> in the array of child nodes.</p>
</div>

<h3>Setting the class of the body</h3>
<p>The <code>inject.css</code> file uses two classes with a custom <code>lxo-</code> prefix: one for the document <code>body</code>, one for the toolbar section. In the <code>appendSectionToBody</code> method, the class <code>lxo-annotations</code> is added to the body to activate the rule <code>margin-top: 32px;</code>; when the Toolbar is removed, so this className is also removed from the body to restore the original <code>margin-top</code>.</p>

<h3>inject.css</h3>
<p>The Toolbar section is appended at the end of the <code>document.body</code>, but you want it to appear at the top, without covering up any other part of the page. To do this, you can inject a CSS file into the content page. This is much simpler than injecting HTML. A simple call in <code>background.js</code> to <code>chrome.tabs.insertCSS</code> with the appropriate tab <code>id</code> and file details is enough:</p>
<pre class="revised">"use strict"

;(function background(){

  var port
  var injectedHTML = chrome.extension.getURL("html/inject.html")
  <span class="new">var injectedCSSFile = "css/inject.css"</span> // no getURL() needed

  function useExtension() {
    // code omitted for clarity
  
    function checkPageStatus(tabs) {
      var id = tabs[0].id
      var message = { 
        method: "extensionStatus"
      }
      var html // set in customizeContentPage => stateChanged()

      chrome.tabs.sendMessage(id, message, checkExtensionStatus)

      function checkExtensionStatus(response) {
        if (!response.extensionIsActive) {
          customizeContentPage(<span class="new">response.cssInjected</span>)
        }
      }

      function customizeContentPage(<span class="new">cssInjected</span>) {
        var xhr = new XMLHttpRequest()
        xhr.open("GET", injectedHTML, true)
        xhr.onreadystatechange = stateChanged
        xhr.send()

        function stateChanged() {
          if (xhr.readyState === 4) {
            html = xhr.responseText
            <span class="new">if (!cssInjected) {
              insertCSS()
            }</span>
            insertToolbar()
          }
        }
      }

      <span class="new">function insertCSS() {  
        var cssDetails = {
          file: injectedCSSFile
        , runAt: "document_start"
        }
        <span class="red">chrome.tabs.insertCSS</span>(id, cssDetails, callback)

        function callback() {
          console.log("CSS injected")
        }
      }</span>

      function insertToolbar() {
        // code omitted for clarity
      }
    }
  }

  // code omitted for clarity
})()</pre>
<p>When the Annotation extension is first activated for the current tab, your custom CSS file is inserted by <code>chrome.tabs.insertCSS</code>. However, at the time of writing, Chrome provides no way to un-insert a CSS file. All your custom rules will remain available to the page until the user navigates away. If the extension is Deactivated (see <a href="#close">next section</a>), then reactivated again, you don't want your custom CSS file to be inserted a second time. The <code>cssInjected</code> flag, retrieved by the <code>checkExtensionStatus</code> callback from the script on the content page, ensures that this does not happen.</p>
<p class="aside tip">If you want to inject CSS automatically into every content page as it is loaded, you can do this via the <a href="https://developer.chrome.com/extensions/content_scripts#registration"><code>manifest.json</code></a> file.</p>

  <div class="aside next">In this section, you've worked through all the hoops you need to inject HTML elements as-needed into a third-party content page. You've also seen how much simpler it is to inject CSS into a specific page.

  <p>You've used the following expressions that are specific to Chrome extensions:</p>
  <ul>
  <li><code>chrome.extension.getURL()</code> </li>
  <li><code>chrome.tabs.query()</code> </li>
  <li><code>chrome.tabs.sendMessage()</code> </li>
  <li><code>chrome.tabs.insertCSS()</code></li>
  </ul>

  <p>In the <a href="#close">next section</a>, you'll see how to close the Toolbar and Deactivate the Annotation extension.</p>
  </div>

  <footer>
    <ul class="nav">
    <li>
    <a href="#close">
    <img src="../img/arrow.png" alt="next"/>
    </a>
    </li>
    </ul>
  </footer>
</section>

<!-- CLOSE -->
  <section id="close">
  <h2>Closing the Toolbar</h2>
  <div class="aside preview">In this section, you'll learn how to:
  <ul>
  <li>Deactivate the Annotation extension for the current tab by clicking on the &#10006; close icon</li>
  <li>Deactivate the Annotation extension for all tabs by closing the NoteBook popup window</li>
  </ul>
  <a href="https://github.com/lexogram/notebook-extension/raw/master/tutorial/zips/10_close.zip" target="source">Download the source files</a>
  </div>

  <h3>Activating the &#10006; close icon</h3>
  <p>The code listing for <code>content.js</code> below shows how to add a <code>"click"</code> event listener to the &#10006; close icon, and how to use this to remove the toolbar and deactivate the Annotation extension for the current tab. But it also does a little bit more: it adds an entry to the <code>switch</code> statement in the <code>treatMessage</code> method, so that the Toolbar can be closed by a call sent from the <code>background.js</code> script. The <code>removeToolbar</code> function also has a check for <code>extensionIsActive</code>, so that a <code>removeToolbar</code> message can be safely sent to any tab, regardless of whether the Annotation extension is currently active for that tab.</p>

<h4><code>content.js</code></h4>
  <pre class="revised">"use strict"

;(function content(){

  // code omitted for clarity

  function treatMessage(request, sender, sendResponse) {
    switch (request.method) {
      case "extensionStatus":
        extensionStatus(request, sendResponse)
      break
      case "insertToolbar":
        insertToolbar(request)
      break
      <span class="new">case "removeToolbar":
        removeToolbar()
      break</span>
    }   
  }

  // code omitted for clarity

  function insertToolbar(request) {
    var body = document.body
    var injectedDOM = parseAsElements(request.html)
    appendSectionToBody(injectedDOM)
    body.classList.add("lxo-annotations")
    extensionIsActive = true
    cssInjected = true

    <span class="new">var close = document.querySelector(".lxo-toolbar a.close")
    close.addEventListener("click", removeToolbar, false)</span>

    return "toolbar inserted"

    // code omitted for clarity
  }

  <span class="new">function removeToolbar() {
    if (!extensionIsActive) {
      return
    }

    var toolbar = document.querySelector("section.lxo-toolbar")
    toolbar.parentNode.removeChild(toolbar)
    document.body.classList.remove("lxo-annotations")
    extensionIsActive = false
    </span>// cssInjected remains true<span class="new">
  }</span>

  chrome.extension.onMessage.addListener(treatMessage)
})()</pre>

<p class="aside note">Note that <code>extensionIsActive</code> is set to <code>false</code> when the Toolbar is removed, so that changes in the selected text are no longer forwarded to the NoteBook window. However, <code>cssInjected</code> is left as <code>true</code>, so that the <code>background.js</code> script will not use <code>chrome.tabs.insertCSS</code> a second time for this tab.</p>

<h3>Deactivating the extension when the NoteBook window is closed</h3>
<p>If the user closes the NoteBook window, then there's no point keeping the Annotation extension active in any tabs. When the NoteBook window is closed, a <code>onbeforeunload</code> event will be triggered in the window; you can intercept this and use the event to tell your extension's <code>background.js</code> script to close any Annotation toolbar that is currently open, and to destroy the connection between itself and the NoteBook window.</p>

<h4>Meteor's <code>client/main.js</code></h4>
<pre class="revised">import { Template } from 'meteor/templating'
import { Session } from 'meteor/session'

// code omitted for clarity

Meteor.startup(function() {
  // code omitted for clarity

  <span class="new">function disableExtension() {
    <span class="red">port.postMessage</span>({ method: "disableExtension" })
  }

  window.onbeforeunload = disableExtension</span>
  port.onMessage.addListener(incoming)
})</pre>

<h4><code>background.js</code></h4>
<pre class="revised">"use strict"

;(function background(){

  // code omitted for clarity

  function incoming(message) {
    <span class="new">switch (message.method) {
      case "disableExtension":
        disableExtension()
      break
    }</span>
  }

  <span class="new">function disableExtension() {
    <span class="red">chrome.tabs.query</span>({}, callAllTabs)

    function callAllTabs(tabs) {
      var message = { method: "removeToolbar" }
      var total = tabs.length
      var ii
      
      for (ii = 0; ii < total; ii += 1) {
        <span class="red">chrome.tabs.sendMessage</span>(tabs[ii].id, message)
      }

      port = null
    }
  }</span>

  // code omitted for clarity
})()</pre>
<p>Since <code>port</code> is set to <code>null</code>, the next time you click on the browser action button in the Chrome toolbar, the NoteBook window will be told to re-open.</p>

  <div class="aside next">In this section, you've added code to close the Toolbar at the top of the current tab when the close icon &#10006; is clicked, and for all tabs when the NoteBook window is closed. You've re-used the following Chrome-specific calls that you discovered earlier:
  <ul>
  <li><code>port.postMessage(...)</code></li>
  <li><code>chrome.tabs.query(...)</code></li>
  <li><code>chrome.tabs.sendMessage(...)</code></li>
  </ul>
  <p>In the <a href="#navigate">next section</a>, you'll see how to keep the Toolbar active as you navigate from one page to another in the current tab.</p>
  </div>

  <footer>
    <ul class="nav">
    <li>
    <a href="#navigate">
    <img src="../img/arrow.png" alt="next"/>
    </a>
    </li>
    </ul>
  </footer>
</section>

<!-- NAVIGATE -->
  <section id="navigate">
  <h2>Navigating to  other pages in the tab</h2>
  <div class="aside preview">In this section, you'll learn how to:
  <ul>
  <li>X</li>
  <li>Y</li>
  </ul>
  <a href="https://github.com/lexogram/notebook-extension/raw/master/tutorial/zips/03_meteor.zip" target="source">Download the source files</a>
  </div>

  <div class="aside next">In this section, you've .
  <p>In the <a href="#end">next section</a>, you'll .</p>
  </div>

  <footer>
    <ul class="nav">
    <li>
    <a href="#end">
    <img src="../img/arrow.png" alt="next"/>
    </a>
    </li>
    </ul>
  </footer>
</section>

<!-- SPANS -->
  <section id="copy">
  <h2>Altering a copy</h2>  
  <p>In the next two sections, you'll be developing a feature that uses a round-trip from a third-party content page, through the background script, through the page script in the NoteBook window, to the server, and then all the way back again.</p>
  <p>The aim is to colour each word in the third-party page to reflect how common the word is. The most common words (like "the" and "of") will appear black, words that are not in the top 10,000 will be coloured bright red, and words in between will appear in an appropriately dark shade of red.</p>
  <p class="aside info">When all the features of the Annotation extension and the NoteBook window are in place, including access to the Neo4j database, the colouring scheme will use different rules. Black words will be the words that you, personally, are most familiar with in the language you are learning; red words will be those the database thinks you have never seen before.</p>
  <div class="aside preview">In this section, you'll learn how to:
  <ul>
  <li>X</li>
  <li>Y</li>
  </ul>
  <a href="https://github.com/lexogram/notebook-extension/raw/master/tutorial/zips/03_meteor.zip" target="source">Download the source files</a>
  </div>

  <div class="aside next">In this section, you've .
  <p>In the <a href="#colouring">next section</a>, you'll .</p>
  </div>

  <footer>
    <ul class="nav">
    <li>
    <a href="#colouring">
    <img src="../img/arrow.png" alt="next"/>
    </a>
    </li>
    </ul>
  </footer>
</section>

<!-- COLOURING -->
  <section id="colouring">
  <h2>Colouring each word</h2>
  <div class="aside preview">In this section, you'll learn how to:
  <ul>
  <li>X</li>
  <li>Y</li>
  </ul>
  <a href="https://github.com/lexogram/notebook-extension/raw/master/tutorial/zips/03_meteor.zip" target="source">Download the source files</a>
  </div>

  <div class="aside next">In this section, you've .
  <p>In the <a href="#toggle">next section</a>, you'll .</p>
  </div>

  <footer>
    <ul class="nav">
    <li>
    <a href="#toggle">
    <img src="../img/arrow.png" alt="next"/>
    </a>
    </li>
    </ul>
  </footer>
</section>

<!-- TOGGLE -->
  <section id="toggle">
  <h2>Toggling the display mode</h2>
  <div class="aside preview">In this section, you'll learn how to:
  <ul>
  <li>X</li>
  <li>Y</li>
  </ul>
  <a href="https://github.com/lexogram/notebook-extension/raw/master/tutorial/zips/03_meteor.zip" target="source">Download the source files</a>
  </div>

  <div class="aside next">In this section, you've .
  <p>In the <a href="#sharing">next section</a>, you'll .</p>
  </div>

  <footer>
    <ul class="nav">
    <li>
    <a href="#sharing">
    <img src="../img/arrow.png" alt="next"/>
    </a>
    </li>
    </ul>
  </footer>
</section>

<!-- SHARING -->
  <section id="sharing">
  <h2>Sharing your extension</h2>
  <div class="aside preview">In this section, you'll learn how to:
  <ul>
  <li>X</li>
  <li>Y</li>
  </ul>
  <a href="https://github.com/lexogram/notebook-extension/raw/master/tutorial/zips/03_meteor.zip" target="source">Download the source files</a>
  </div>

  <div class="aside next">In this section, you've .
  <p>In the <a href="#end">next section</a>, you'll .</p>
  </div>

  <footer>
    <ul class="nav">
    <li>
    <a href="#end">
    <img src="../img/arrow.png" alt="next"/>
    </a>
    </li>
    </ul>
  </footer>
</section>

<!-- CONCLUSION -->
<section id="end">
  <h2>Conclusion</h2>
  <div class="aside preview">Here's what you've learnt:
  <ul>
  <li>Create a Chrome extension</li>
  <li>Modify the DOM of the main page</li>
  <li>Communicate between different pages</li>
  <li>Interact with your own server</li>
  </ul>
  </div>

  <p>Well done! Now you're ready to add features to your Meteor server, to make the service provided by the extension even more valuable. Time for a <a href="../notebook/">new tutorial</a>.</p>
</section>

<!-- OVERVIEW -->
<section id="top">
  <h2>Overview</h2>
  <p class="top">Lexogram's <a href="#">Annotations</a> is a Chrome extension which helps you learn a language by making notes about web pages that you visit in the language that you are learning. This tutorial takes you step-by-step through the process of building version 1.0 of the Annotations extension.</p>
  <p>When you launch the Annotations extension, a popup window will open to display the Lexogram Notebook web site. The extension sets up communications between the page you have open in the main window and the Notebook, and provides a series of tools that help you understand and remember what you are reading.</p>

  <div class="aside preview">In particular, the Annotations extension:
    <ul>
      <li>Tells the Notebook window what text you have selected on the main page</li>
      <li>Allows you to make your own notes and translations, and saves them to the Lexogram server so that they can be shared with others</li>
      <li>Remembers which words and expressions you have become familiar with, and highlights those that it thinks will be new to you.</li>
    </ul>
  </div>

  <figure>
  <img src="img/overview.png" alt="The Annotations extension in action" />
  <figcaption>Figure 1. The Annotations extension in action</figcaption>
  </figure>

  <footer>
    <ul class="nav">
    <li>
    <a href="#waiver">
    <img src="../img/arrow.png" alt="next"/>
    </a>
    </li>
    </ul>
  </footer>
</section>
</article>
</main>

<script src="../js/core.js"></script>
</body>
</html>
