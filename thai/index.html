<!DOCTYPE html>
<html lang=en>
<head>
<meta charset="utf-8">
<title>Selecting Thai Words</title>
<link rel="stylesheet" href="../css/core.css" />
<link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
</head>

<body>
  <div class="sidebar">
    <div class="logo">
      <a href="../"><img src="../img/logo.png" alt="openbook home" /></a>
    </div>

    <nav>
      <ol>
        <li><a href="#top">Overview</a></li>
        <li><a href="#dictionary">Defining a dictionary</a></li>
        <li><a href="#trie">Creating a trie</a></li>
        <li><a href="#detect">Detecting words</a></li>
        <li><a href="#rules">A rule-based system</a></li>
        <li><a href="#async">Asynchronous calls</a></li>
        <li><a href="#mutation">Detecting text changes</a></li>
        <li><a href="#jump">Jump to adjacent words</a></li>
        <li><a href="#translate">Querying the dictionary</a></li>   
        <li><a href="#end">Conclusion</a></li>
      </ol>
    </nav>

    <p class="aside support">If you have any difficulty in this tutorial, please <a href="https://github.com/lexogram/openbook/issues/new">tell us about it</a>, and we will do our best to deal with it for you.</p>
  </div>

<main>
<header>
  <a href="https://github.com/lexogram/openbook/blob/master/LICENSE" class="cc">&#59409;</a>
  <h1>Selecting Thai Words</h1>

  <ul class="nav">
    <li>
      <a href="#back"><img src="../img/arrow.png" alt="back" /></a>
    </li><li>
      <a href="#next"><img src="../img/arrow.png" alt="next" /></a>
    </li>
  </ul>
</header>

<article>

<!-- DICTIONARY -->
<section id="dictionary">
  <h2>Defining a dictionary</h2>
  <div class="aside preview">In this section, you'll:
    <ul>
      <li>Create an HTML file containing some Thai text and an English translation withnospacesbetweenwords</li>
      <li>Create a dictionary object for all the words in the Thai text and all the words that can be found in the English string.</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/raw/gh-pages/thai/source/zips/02_dictionary.zip" target="source" class="unselectable">Download the source files</a> <a href="source/02_dictionary/" target="test" class="unselectable">Test here</a>
  </div>

  <h3>Mimicking Thai text</h3>
  <p>During this tutorial, you'll be working with some text in Thai. To make it easier to understand what your code is doing, it might be easier to use a translation of the Thai text in English, from which all the spaces have been removed. You can then perform exactly the same actions on the English textwithnospaces, even if you understand no Thai.</p>
  <p>You can start by creating a file named <code>index.html</code> with the following HTML code:</p>

  <h4><code>index.html</code></h4>
  <pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Selecting Thai words&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;p lang="th"&gt;งมเข็มในมหาสมุทร
  พูดไปสองไพเบี้ย นิ่งเสียตำลึงทอง
  ตากลม  ตา&amp;#8203;กลม&lt;/p&gt;

  &lt;p lang="enx"&gt;lookforaneedleinthesea
  talkisworthtuppence silenceisworthgold
  exposedtotheair roundeye&lt;/p&gt;

  &lt;script src="js/dictionaries.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

  <p class="aside note">For now, the text in the HTML is simply to give you an idea of how Thai text looks. Later, in the section on <a href="#jump">using the arrow keys to jump to the neighbouring words</a>, you'll actually be interacting with Thai text.</p>

  <h3>ISO language codes</h3>
  <p>The <a href="https://en.wikipedia.org/wiki/International_Organization_for_Standardization">International Organization for Standardization</a> (ISO) has published a list of two- and three-letter language codes. You can use the <code>lang</code> attribute of an HTML element to indicate which language the text of the element is in. The standard codes for English and Thai <code>en</code> and <code>th</code>.</p>
  <p>Normally, you would add this attribute to the <code>&lt;html&gt;</code> element ...
  <pre><span class="revised">&lt;!DOCTYPE html&gt;
&lt;html </span>lang="en"<span class="revised">&gt;
   &lt;head&gt;
    <span class="ymmv">...</span>
  &lt;head&gt;
  &lt;body&gt;
    <span class="ymmv">...</span>
  &lt;/body&gt;
&lt;/html&gt;</span></pre>
<p>... to indicate the language of the entire page. But this page is in two languages, so it makes sense to give the attribute to the individual <code>&lt;p&gt;</code> tags.</p>
  <p class="aside note">Since the "English" used here to mimic the structure of Thai text is non-standard English, I have used a non-standard code: <code>enx</code>.</p>

  <h3>Zero-width space</h3>
  <p>The character encoded as <code>&amp;#8203;</code> is a "zero-width space". It is used here to force a word-break in the string ตากลม so that it will be treated as ตา กลม (eye round) and not ตาก ลม (exposed-to air).</p>

  <h3>Creating a dictionary</h3>
  <p>The JavaScript file below creates a global object called <code>dico</code>, with two dictionary maps: one for the non-standard <code>enx</code> language code, one for <code>th</code>, the Thai language.</p>
  <p>If you are reading this in English, the chances are that you already know all the English words, so a pronunciation guide and  translation is provided only for the Thai words. </p>
  <p>Notice that the <code>enx</code> dictionary contains all the words that can be found in the <code>enx</code> strings, even those that are not used to create meaning from the strings. For testing purposes, the <code>enx</code> dictionary object contains the invented word "forane", which can be found in the chunk "<span class="under">for<span class="gold">a</span>ne</span>edle"</p>

 <h4><code>js/dictionaries.js</code></h4>
 <pre>"use strict"

var dico = {}

;(function addDictionaries() {
  dico = {

    dictionaries: {
      enx: {
        " ": 0
      , "a": 0
      , "air": 0
      , "exposed": 0
      , "eye": 0
      , "for": 0
      , "forane": 0 <span class="comment">// nonsense word for testing</span>
      , "gold": 0
      , "he": 0
      , "in": 0
      , "is": 0    
      , "look": 0
      , "need": 0
      , "needle": 0
      , "old": 0
      , "or": 0
      , "pence": 0
      , "round": 0
      , "sea": 0
      , "silence": 0
      , "talk": 0
      , "the": 0
      , "these": 0
      , "to": 0
      , "tot": 0
      , "tup": 0
      , "tuppence": 0
      , "up": 0
      , "worth": 0
      }

    , th: {
        " ": {}
      , "​": {} <span class="comment">// &amp;#8203; = zero-width space</span>
      , "กลม": {
          "pronunciation": "glohm-"
        , "translation": "round; circular"
        }
      , "งม" : {
          "pronunciation": "ngohm-"
        , "translation": "to grope; search; seek; fumble for"
        }
      , "ตา": {
          "pronunctiation": "dtaa-"
        , "translation": "eye; maternal grandfather"
        }
      , "ตาก": {
          "pronunctiation": "dtaak_"
        , "translation": "[is] exposed (e.g., to the sun)"
        }
      , "ตำ" : {
          "pronunciation": "dtam-"
        , "translation": "beat; pound an object; pulverize; to pierce; puncture; prick"
        }
      , "ตำลึง" : {
          "pronunciation": "dtam- leung-"
        , "translation": "ancient Thai monetary unit"
        }
      , "ทอง" : {
          "pronunciation": "thaawng-"
        , "translation": " gold"
        }
      , "นิ่ง" : {
          "pronunciation": "ning`"
        , "translation": "[is] still; immobile; silent; motionless; quiet"
        }
      , "พูด" : {
          "pronunciation": "phuut`"
        , "translation": " to speak; to talk; to say"
        }
      , "มหา" : {
          "pronunciation": "ma' haa´"
        , "translation": "great; omnipotent; large; many; much; maximal; paramount; exalted"
        }
      , "มหาสมุทร" : {
          "pronunciation": "ma' haa´ sa_ moot_"
        , "translation": "ocean"
        }
      ,"ลม": {
          "pronunciation": "lohm-"
        , "translation": "air; wind; storm"
        }
      , "สมุทร" : {
          "pronunciation": "sa_  moot_"
        , "translation": "ocean; sea"
        }
      , "สอง" : {
          "pronunciation": "saawng´"
        , "translation": "two"
        }
      , "เข็ม" : {
          "pronunciation": "khem´"
        , "translation": "clasp; brooch; safety pin; needle; sewing pin"
        }
      , "เบี้ย" : {
          "pronunciation": "biia`"
        , "translation": "a cowrie shell [formerly used as] money"
        }
      , "เสีย" : {
          "pronunciation": "siia´"
        , "translation": "to spend; use up; lose; give up; sacrifice; pay"
        }
      , "ใน" : {
          "pronunciation": "nai-"
        , "translation": "in; inside; within; amidst; into; on; at a particular time"
        }
      , "ไป" : {
          "pronunciation": "bpai-"
        , "translation": "to go; &lt;subject&gt; goes"
        }
      , "ไพ" : {
          "pronunciation": "phai-"
        , "translation": "a certain old coin equal in value to 1/32 baht"
        }
      }
    }
  }
})()</pre>

  <div class="test unselectable">
    <a href="source/02_dictionary/" target="test" class="unselectable">Test Here</a>
  </div>

  <div class="aside next">In this section, you've created:
    <ul>
      <li>An HTML page for testing</li>
      <li>Two JavaScript dictionary objects containing a limited number of words in English and Thai.</li>
    </ul>
    <p>In the <a href="#trie">next section</a>, you'll use these dictionaries to create a <span class="keyword">trie</span> object for each language.</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#trie">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- TRIE -->
<section id="trie">
  <h2>Creating a trie</h2>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Create a trie object</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/raw/gh-pages/thai/source/zips/03_trie.zip" target="source" class="unselectable">Download the source files</a>
  </div>

  <p>The word "trie" comes from the French word for "to choose, classify, filter, pick out, separate, sort". It also sounds like the English word "tree". In computing, it refers to a data structure than starts at a common root and divides multiple times to end in a unique leaf.</p>
  <p>You can add the code below to your <code>dictionaries.js</code> file.</p>

  <h4><code>js/dictionaries.js</code></h4>
  <pre class="revised">"use strict"

var dico = {}

;(function addDictionaries() {
  dico = {

    dictionaries: {
      enx: {
        <span class="omit">// code omitted for clarity</span>
      }
    , th: {
        <span class="omit">// code omitted for clarity</span>
      }
    }

  <span class="new">, tries: {}

  , initialize: function createTries(){
      for (var languageCode in this.dictionaries) {
        this.tries[languageCode] = 
          this.createTrie(this.dictionaries[languageCode])
      }

      return this
    }

  , createTrie: function createTrie(languageMap) {
      var trie = {}
      var end = "$"
      var word
        , ii
        , length
        , last
        , chars
        , char
        , path
        , place


      for (word in languageMap) {
        chars = word.split("")
        path = trie
   
        for (ii = 0, length = word.length; ii &lt; length; ii += 1) {
          char = chars[ii]
          place = path[char]
   
          if (!place) {
            place = {}
            path[char] = place
          }
          path = place
        }
        path[end] = true
      }

      return trie
    }</span>
  }<span class="new">.initialize()</span>
})()

<span class="new">console.log(JSON.stringify(dico.tries.enx))</span>
</pre>

<p>The <code>createTrie</code> method creates an empty <code>trie</code> object, and then takes each word key in a given dictionary and splits it into its individual characters. It then checks if there is already a word which begins with the first letter. If not, it creates a new entry for that letter in the <code>trie</code> object; if so, it checks whether the existing sub-object already contains a sub-object for the next letter. In this manner, it works its way along until it reaches the end of the word, when it adds an entry for <code>"$": true</code> to the current branch, as a final leaf.</p>

<h3>Console output</h3>
<p>If you save your changes, relaunch your page and check the Developer Console, you should see output that looks something like this (but a bit less prettified).</p>

  <pre>{" ":{"$":true}
,"a":{"$":true
     ,"i":{"r":{"$":true}}}
,"e":{"x":{"p":{"o":{"s":{"e":{"d":{"$":true}}}}}}
     ,"y":{"e":{"$":true}}}
,"f":{"o":{"r":{"$":true
               ,"a":{"n":{"e":{"$":true}}}}}}
,"g":{"o":{"l":{"d":{"$":true}}}}
,"h":{"e":{"$":true}}
,"i":{"n":{"$":true}
     ,"s":{"$":true}}
,"l":{"o":{"o":{"k":{"$":true}}}}
,"n":{"e":{"e":{"d":{"$":true
                    ,"l":{"e":{"$":true}}}}}}
,"o":{"l":{"d":{"$":true}}
     ,"r":{"$":true}}
,"p":{"e":{"n":{"c":{"e":{"$":true}}}}}
,"r":{"o":{"u":{"n":{"d":{"$":true}}}}}
,"s":{"e":{"a":{"$":true}}
     ,"i":{"l":{"e":{"n":{"c":{"e":{"$":true}}}}}}}
,<span class="red">"t"</span>:{"a":{"l":{"k":{"$":true}}}
     ,<span class="red">"h"</span>:{<span class="red">"e"</span>:{"$":true
               ,<span class="red">"s"</span>:{<span class="red">"e"</span>:{<span class="red">"$"</span>:true}}}}
     ,"o":{"$":true,"t":{"$":true}}
     ,"u":{"p":{"$":true
               ,"p":{"e":{"n":{"c":{"e":{"$":true}}}}}}}}
,"u":{"p":{"$":true}}
,"w":{"o":{"r":{"t":{"h":{"$":true}}}}}}</pre>

  <p>Note how the letters of the word "these" (shown in red) have been added to the <code>trie</code> object.</p>

  <div class="test unselectable">
    <a href="source/03_trie/" target="test" class="unselectable">Test Here</a>
  </div>

  <div class="aside next">In this section, you've taken a flat dictionary object and created a branching trie object from it.
    <p>In the <a href="#detect">next section</a>, you'll use your trie object to detect the word boundaries in a given string.</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#detect">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- DETECT -->
<section id="detect">
  <h2>Detecting words with a trie</h2>
  <div class="aside preview">In this section, you'll learn how to:<ul>
  <li>Use a trie object to analyze a string of text and split it into known words.</li>
  </ul>
    <a href="https://github.com/lexogram/openbook/raw/gh-pages/thai/source/zips/04_detect.zip" target="source" class="unselectable">Download the source files</a> <a href="source/04_detect/" target="test" class="unselectable">Test Here</a>
  </div>

  <h3>Looking for known words</h3>
  <p>Now that you have a trie object, you can use it identify words in a string. The <code>splitIntoWords</code> method in the code listing below will step through the string one character at a time, matching it to a path through the trie. If it fails to find a word at any point, it will backtrack and start from the last point where it found a whole word.</p>

  <h4><code>js/.dictionaries.js</code></h4>
  <pre class="revised">"use strict"

var dico = {}

;(function addDictionaries() {
  dico = {

    dictionaries: {
      <span class="omit">// code omitted for clarity</span>
    }

  , tries: {}

  , initialize: function createTries(){
      <span class="omit">// code omitted for clarity</span>
    }

  , createTrie: function createTrie(languageMap) {
      <span class="omit">// code omitted for clarity</span>
    }

  <span class="new">, splitIntoWords: function splitIntoWords(string, languageCode) {
      var trie = this.tries[languageCode]
      var alternatives = []
      var path = trie
      var words = []
      var word = ""
      var found = false
      var char
        , next
        , alternative

      words.index = 0

      for (var ii = 0, total = string.length; ii &lt; total ; ii += 1) {
        char = string[ii]
        next = path[char]

        if (next) { <span class="comment">// { "$": 0, "a": { ... }. ...}          </span>
          word += char

          if (next.$) {
            if (found) {
              <span class="comment">// We've already added a shorter word to the list.
              // Push the list with the shorter word onto the
              // alternatives array and continue with the longer word</span>
              alternative = words.slice(0)
              alternative.index = words.index
              alternatives.push(alternative)

              words.index -= words.pop().length <span class="comment">// remove shorter word</span>
            }
            <span class="comment">// Add this whole word to the list</span>
            words.push(word)
            words.index += word.length
            found = true
          }

          path = next

        } else if (found) {
          <span class="comment">// !next, but we have a complete word already
          // This character could be the start of a new word</span>
          word = char
          path = trie[char]
          if (!path) {
            <span class="comment">// It's imposible to start a word with this letter</span>
            backtrack("Initial letter absent: " + char)

          } else if (path.$) {
            <span class="comment">// This may be a one-letter word: found remains true</span>
            words.push(word)
            words.index += word.length
            next = path

          } else {
            found = false
          }

        } else {
          <span class="comment">// !next &amp;&amp; !found: stop trying to complete this word</span>
          backtrack("Word fragment: " + word)
        }
      }

      if (!next || !next.$) {
        backtrack("Fail – Unknown word: ", word)
      }

      return words

      function backtrack(reason) {
        console.log(reason)

        <span class="comment">// Try the longest earlier alternative ...</span>
        words = alternatives.pop()
        <span class="comment">// ... if one exists ...</span>
        if (!words) {
          console.log("Failed to segment")
          ii = total
          return
        }
        <span class="comment">// ... and see if all the remaining characters cand be
        // segmented into words</span>
        ii = words.index - 1
        path = trie
        word = ""
        found = false
      }
    }</span>
  }.initialize()
})()

console.log(<span class="new">dico.splitIntoWords("lookforaneedleinthesea", "enx")</span>)
<span class="new">console.log(dico.splitIntoWords(
  "งมเข็มในมหาสมุทร "
+ "พูดไปสองไพเบี้ย นิ่งเสียตำลึงทอง "
+ "ตากลม ตา&#8203;กลม"
, "th"))</span></pre>

  <div class="test unselectable">
    <a href="source/04_detect/" target="test" class="unselectable">Test Here</a>
  </div>

  <p>The output in the Developer Console should look something like this:</p>
  <pre class="console"><span class="output">["look", "for", "a", "needle", "in", "these", "a", index: 22]</span>
<span class="output">["งม", "เข็ม", "ใน", "มหาสมุทร", " ", "พูด", "ไป", "สอง",
   "ไพ", "เบี้ย", " ", "นิ่ง", "เสีย", "ตำลึง", "ทอง", " ", 
   "ตาก", "ลม", " ", "ตา", "​", "กลม", index: 62]</span></pre>
  <p>You'll notice that the last two words in English are <code>"these", "a"</code>  and not <code>"the", "sea"</code>. The last  chunks of Thai has been split differently from the previous chunk, because of the zero-width space <code>&amp;#8203;</code>.</p>

  <h3><code>splitIntoWords</code></h3>
  <p>The <code>splitIntoWords</code> method accepts a string of text and a language code. It uses the language code to select the appropriate language trie. It takes the first character in the string and looks for it at the top level of the trie, then takes the second letter, and looks for it in the branch of the trie defined by the previous letter, adding it to its <code>word</code> variable as it goes. It will continue to do this until one of three things happens:</p>
  <ul>
  <li>It meets an object with a <code>"$": true</code> key/value pair</li>
  <li>It finds an object which contains no key for the letter in the string that it is currently looking at</li>
  <li>It reaches the end of the text</li>
  </ul>

  <h3>Adding words</h3>
  <p>The algorithm will step through the string and tunnel into the trie until it has created the string "look". At this point, it will encounter a <code>{"$": true}</code> object. This tells it to add the word "look" to its current <code>words</code> list, and to set a flag to say that at least one word has been found. Since an array is special kind of object, it can add a property to the array: it adds an <code>index</code> key with a value equal to the length of the string read so far. You'll see in a moment how this is used.</p>

  <h3>Preparing alternatives</h3>
  <p>The <code>splitIntoWords</code> algorithm is greedy: it will keep looking for the longest word that fits, and this may lead it into a blind alley. To test this, you'll find the nonsense word "forane" in the dictionary. After finding "look", the algorithm keeps moving forward. When it has read "for", it will find an object with both a <code>"$": true</code> key pair and the key "a", with a submap that it can continue to follow.</p>
  <p>It adds the word "for" to the <code>words</code> array, and updates the <code>index</code> of the array: <code>index</code> is now the sum of the lengths of the word in the array.</p>
  <p>The process continues until the <code>{"$": true}</code> object, indicating the end of the nonsense word "forane", is found. This time, however, there is already a word that uses the letters "for" in the <code>words</code> array. The <code>splitIntoWords</code> function first uses <code>words.slice(0)</code> to copy the array, and also copies the value of <code>index</code>, to create a full clone. This clone is added to the <code>alternatives</code> array. In the original <code>words</code> array, the last word ("for") is removed and replaced with "forane", and the <code>index</code> value is updated.</p>
  <p>A new word now begins, starting with the letter "e", but at the next iteration, no sub-map of <code>trie</code> is found that corresponds to the word fragment "ed". The <code>splitIntoWords</code> function has reached the end of a blind alley: it calls the <code>backtrack</code> function. This drops the current <code>words</code> array and replaces it with the longest array in <code>alternatives</code>: <code>["look", "for"]</code>, with its <code>index</code> value of 7. It resets the <code>ii</code> iterator so that the next iteration starts building a new word from position <code>ii = 7</code>: the index of the next letter after "lookfor". This time, it finds the words "a" and "need", which is soon replaced by "needle", and continues to read "these", and "a". This is a complete word and the final letter in the string, so the process stops there.</p>

  <h3>Issues with a dictionary approach</h3>
  <p>This approach suffers from two major problems:</p>
  <ul>
  <li>It is possible to split the letters in the wrong place and still create a set of valid (but meaningless) words</li>
  <li>If a word is not in the dictionary, it will fail</li>
  </ul>

  <h3>Ambiguous word boundaries</h3>
  <p>The algorithm has no "intelligence" built in, so it has no reason to reject "these", "a" and replace it with "the", "sea". Its greediness has led it into error. Refusing to be greedy could lead it to make different errors.</p>
  <p>People who speak English know almost instantly where to split what they hear into words, based on meaning and statistics. Until you read this paragraph, it's unlikely that you have ever encountered a meaningful sentence that ends with the words "in these a".</p>
  <p>As far as we know, computers are totally unaware of meaning, but a quick search on Google will show you that, statistically, "in the sea" is over 300 times more likely to appear in written English than "in these a". It should therefore be possible to improve the accuracy of the <code>splitIntoWords</code> algorithm by checking the statistical likelihood of each subset of words appearing together. However, this will require access to a vast database: not just a dictionary of words but a store of phrases indexed by the words they contain.</p>
  <p>It is not feasible to load this database in your browser. It uses much less bandwidth to send the text for analysis to the server, where it can be treated by all the CPU power necessary, and then to send the results back.</p>

  <h3>Unknown words</h3>
  <p>In this simple implementation, the absence of a single word from the dictionary will cause the algorithm to fail. A more robust version would necessarily be slower, and, without a database to provide statistical input, may still produce erroneous results.</p>

  <div class="aside next">In this section, you've seen how to use a dictionary to find word boundaries, and you have seen its shortcomings.
    <p>In the <a href="#rules">next section</a>, you'll see a different approach based on the spelling rules of the Thai language.</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#rules">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- RULES -->
<section id="rules">
  <h2>A rule-based system for detecting syllables</h2>
  <div class="aside preview">Even in a language where there are no gaps between words, there are several places that are clearly boundaries between syllables. In this section, you'll learn about:
    <ul>
      <li>Characters that only appear at the beginning of a Thai syllable</li>
      <li>Characters that appear only at the end of a Thai syllable</li>
      <li>Thai numbers</li>
      <li>Boundaries between Thai characters and non-Thai characters</li>
      <li>Common Thai words that cannot be created by chance across a word boundary</li>
    </ul>
    <p>You'll create a series of regular expressions to detect any of these boundaries, and use them to determine places where there must be a syllable boundary.</p>
    <a href="https://github.com/lexogram/openbook/raw/gh-pages/thai/source/zips/05_rules.zip" target="source" class="unselectable">Download the source files</a> <a href="source/05_rules/" target="test" class="unselectable">Test Here</a>
  </div>

  <p class="aside kudos">The approach described in this section is inspired by the <a href="http://not.siit.net/members/art/thaiwrap.html">ThaiWrap bookmarklet / ตัวตัดบรรทัดข้อความไทย</a> written by Arthit Suriyawongkul / อาทิตย์ สุริยะวงศ์กุล</p>

  <h3>Initial and final letters in Thai</h3>
  <p>In English, you are used to seeing vowel sounds that are with multiple vowel characters. For example: "fair" and "fire". In the word "fire", the final "e" appears after the last consonant, but it is not pronounced. Instead, its existence changes the sound of the preceding "i".</p>
  <p>In Thai, certain vowels are written <em>before</em> the first consonant, but are pronounced <em>after</em> the consonant. The Thai tone-twister ไม้ ใหม่ ไม่ ไหม้ ไหม (máai mài mâi mâi mái, green wood doesn't burn, does it?) uses two of these vowels: ไ and ใ. The character for "m" is ม, which is written after the vowel. You can therefore be sure that wherever you find a ไ or ใ character, it is the first character in a syllable.</p>
  <p>The five vowels that work this way are เ แ โ ใ ไ. Fortunately, they have been placed together in the <a href="https://en.wikipedia.org/wiki/Thai_(Unicode_block)">Thai Unicode block</a>, so you can use the regular expression <code>/[เ-ไ]/</code> for them.</p>
  <p>There are also a certain number of characters that only ever appear at the end of a syllable. These are more scattered so you need to use each individual character in the regular expression that identifies them all: <code>/[ฯะำฺๅๅๆ๎]/</code>. If you encounter any of these characters in Thai text, you can be 100% sure that the next character is the start of a new syllable.</p>

  <h3>Numbers</h3>
  <p>The Thai numbers from 0 to 9 are written as:</p>
  <blockquote>๐ ๑ ๒ ๓ ๔ ๕ ๖ ๗ ๘ ๙</blockquote>
  <p>Anywhere where a number is followed by a non-number, or a non-number is followed by a number, must be the end of a word. These numbers can be expressed in the regular expression: <code>/[๐-๙]/</code>. To define all the Thai characters that are not numbers, you can use <code>/[ก-ฺเ-๎]/</code> </p>

  <h3>Non-Thai characters</h3>
  <p>Thai people often use Western numerals (0 - 9), and Western names may be written in Roman characters. You can be sure that any transition from Thai to non-Thai will occur at a word boundary.</p>

  <h3>Common words</h3>
  <p>Out of the top 100 words in Thai, there are 30 which form unambiguous syllables. Out of the top 2500, there are 51 such words, as shown in the following regular expression:</p>
   <pre>/(เป็น|ใน|จะ|ไม่|และ|ได้|ให้|ความ|แล้ว|กับ|อยู่|หรือ|กัน|จาก|เขา|ต้อง|ด้วย|นั้น|ผู้|ซึ่ง|โดย|ใช้|ยัง|เข้า|ถึง|เพราะ|จึง|ไว้|ทั้ง|ถ้า|ส่วน|อื่น|สามารถ|ใหม่|ใช่|ใด|ช่วย|ใหญ่|เล็ก|ใส่|เท่า|ใกล้|ทั่ว|ฉบับ|ใต้|เร็ว|ไกล|เช้า|ซ้ำ|เนื่อง|ค้น)/</pre>
   <p>If you encounter any of these words, you can be sure that the preceding character is the end of the previous syllable and the next character is the beginning of the following syllable.</p>
   <p></p>

   <h3>Rule-based segmentation</h3>
   <p>You can add the <code>segment</code> object, as shown below, to your <code>dictionaries.js</code> script. When you call <code>segment.th(<span class="ymmv">string</span>)</code>, it will search through the string, applying each regular expression in turn, looking for all these identifiable syllable boundaries. It adds the position of these boundaries to an array. Some boundaries will be found multiple times, and these are filtered out. In the last step, it takes each boundary point, starting from the end, and replaces it with the segment of the string that starts from that point.</p>

   <h4><code>js/dictionaries.js</code></h4>
   <pre class="revised">"use strict"

var dico = {}
<span class="new">var segment</span>

;(function addDictionaries() {
  dico = {
    <span class="omit">// code omitted for clarity</span>
  }.initialize()

  <span class="new">segment = {
    th: function thai(string) {
      <span class="comment">// unambiguous words that are common, like prepositions</span>
      var cw = "(เป็น|ใน|จะ|ไม่|และ|ได้|ให้|ความ|แล้ว|กับ|อยู่|หรือ|กัน|จาก|เขา|ต้อง|ด้วย|นั้น|ผู้|ซึ่ง|โดย|ใช้|ยัง|เข้า|ถึง|เพราะ|จึง|ไว้|ทั้ง|ถ้า|ส่วน|อื่น|สามารถ|ใหม่|ใช่|ใด|ช่วย|ใหญ่|เล็ก|ใส่|เท่า|ใกล้|ทั่ว|ฉบับ|ใต้|เร็ว|ไกล|เช้า|ซ้ำ|เนื่อง|ค้น)"
      <span class="comment">// leading chars</span>
      var lc = "[เ-ไ]"
      <span class="comment">// final chars</span>
      var fc = "[ฯะำฺๅๅๆ๎]"
      <span class="comment">// thai chars</span>
      var tc = "ก-ฺเ-๎" <span class="comment">// not including numbers + ฿, ๏ or ๚๛</span>
      var no = "๐-๙"
      var isThai = /[ก-ฺเ-๎]/
      var isNumber = /[๐-๙]/

      var regexes = [
        <span class="comment">// characters that start a syllable</span>
        new RegExp(lc, "g")
        <span class="comment">// characters than end a syllable</span>
      , new RegExp(fc, "g")
         <span class="comment">// non-number followed by any Thai number</span>
      , new RegExp("[^"+no+"](?=["+no+"])", "g")
         <span class="comment">// Thai number followed by any non-number</span>
      , new RegExp("["+no+"](?=[^"+no+"])", "g")
         <span class="comment">// Thai character followed by a non-Thai character</span>
      , new RegExp("["+tc+"](?=[^"+tc+"])", "g")
        <span class="comment">// non-Thai character followed by Thai character</span>
      , new RegExp("[^"+tc+"](?=["+tc+"])", "g")
        <span class="comment">// any char followed by known word</span>
      , new RegExp("."+cw+"", "g")
        <span class="comment">// known word followed by any character</span>
      , new RegExp(cw+"(.)", "g")
        <span class="comment">// beginning of a space</span>
      , /.\s/g
        <span class="comment">// end of a space</span>
      , /\s+./g
      ]

      var adjustments = [
        <span class="comment">// characters that start a syllable</span>
        0
        <span class="comment">// characters that end a syllable</span>
      , 1
        <span class="comment">// non-number followed by any Thai number</span>
      , 1
        <span class="comment">// Thai number followed by any non-number</span>
      , 1
        <span class="comment">// Thai character followed by a non-Thai character</span>
      , 1
        <span class="comment">// non-Thai character followed by Thai character</span>
      , 1
        <span class="comment">// any char followed by known word</span>
      , 1
        <span class="comment">// known word followed by any character</span>
      , true
        <span class="comment">// spaces</span>
      , 1
      , true
      ]

      function numerical(a, b) {
        return a - b
      }

      function removeDuplicates(value, index, array) {
        return array.indexOf(value) === index
      }

      function splitIntoWords(string) {
        var segments = [0]
        var total
          , ii
          , regex
          , adjust
          , result
          , split
          , start
          , end

        for (ii = 0, total = regexes.length; ii &lt; total; ii++) {
          regex = regexes[ii]
          adjust = adjustments[ii]
          while (result = regex.exec(string)) {
            split = result.index + (adjust === true
                           ? result[0].length - 1
                           : adjust)
            segments.push(split)
          }
        }

        segments.sort(numerical)
        segments = segments.filter(removeDuplicates)

        end = string.length
        ii = segments.length
        while (ii--) {
          start = segments[ii]
          segments[ii] = string.slice(start, end)
          end = start
        }  

        return segments
      }

      return splitIntoWords(string)
    }
  }</span>
})()

console.log(dico.splitIntoWords(
  "งมเข็มในมหาสมุทร "
+ "พูดไปสองไพเบี้ย นิ่งเสียตำลึงทอง "
+ "ตากลม ตา​กลม"
, "th"
))
<span class="new">console.log(segment.th(
  "งมเข็มในมหาสมุทร "
+ "พูดไปสองไพเบี้ย นิ่งเสียตำลึงทอง "
+ "ตากลม ตา​กลม"
))</span></pre>

  <div class="test unselectable">
    <a href="source/05_rules/" target="test" class="unselectable">Test Here</a>
  </div>

  <h3>Results</h3>
  <p>In the Developer Console, you will see the output of the dictionary-based and the rule-based algorithms. Differences are marked in colour below:</p>

  <pre class="console"><span class="output">["งม","เข็ม","ใน","มหาสมุทร"," ",
   "พูด","<span class="green">ไป</span>","<span class="green">สอง</span>","ไพ","เบี้ย"," ","นิ่ง","เสีย","<span class="red">ตำลึง</span>","ทอง"," ",
   "<span class="blue">ตาก</span>","<span class="blue">ลม</span>"," ",ตา","​","กลม", index: 62]</span>

<span class="output">["งม","เข็ม","ใน","มหาสมุทร"," ",
   "พูด","<span class="green">ไปสอง</span>","ไพ","เบี้ย"," ","นิ่ง","เสีย<span class="red">ตำ","ลึง</span>ทอง"," ",
   "<span class="blue">ตากลม</span>"," ",ตา","​","กลม"]</span></pre>

  <p>In the majority of cases, the two approaches agree. However:</p>
  <ul>
  <li>The rule-based approach does not identify a boundary in four cases (one green, one blue and two either side of the red chunk)</li>
  <li>The rule-based approach splits <a href="http://www.thai-language.com/id/140482">one word</a> (shown in red) along its syllable boundaries, and the two halves fail to be detached from the adjacent words.</li>
  </ul>
  <p>This rule-based approach can function with moderate accuracy with a dictionary of only a few dozen words. It may make fail to recognize all the syllable boundaries, but it does not fail if it encounters an unknown word.</p>

  <div class="aside next">In this section, you've explored an approach based on spelling rules, and compared it to a dictionary approach. It is clear that both approaches have their shortcomings. 
  <p>Attempting to solve the problem in the browser appears unrealistic. In the <a href="#async">next section</a>, you'll see how to make an asynchronous call, to simulate a request for word segmentation data from the server.</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#async">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- ASYNC -->
<section id="async">
  <h2>Asynchronous calls</h2>
  <div class="top"><p>Correctly identifying word boundaries in Thai is not a task that is easy to perform in the browser. A better solution is to send the Thai text to a server for treatment, and to use the results as soon as they are available.</p>
  <p>Over the next three sections you will be learning to:</p>
  <ul>
    <li>Make an asynchronous call to a simulated server</li>
    <li>Make this call each time new Thai text is found in the web page, whether this is when the page is loaded or when new text is added on the fly</li>
    <li>Use the results of these calls to identify the neighbouring word when the arrow keys are pressed</li>
  </ul></div>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Create an ASYNC object that behaves like <a href="https://docs.meteor.com/api/methods.html#Meteor-call" class="plain"><code>Meteor.call</code></a> in a Meteor environment, or as a wrapper for an plain AJAX call</li>
      <li>Add a <code>getWordSegmentation</code> method to your global <code>dico</code> object</li>
      <li>Test an asynchronous call to <code>getWordSegmentation</code> and observe the results in the Developer Console.</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/raw/gh-pages/thai/source/zips/06_async.zip" target="source" class="unselectable">Download the source files</a> <a href="source/06_async/" target="test" class="unselectable">Test Here</a>
  </div>

  <h3>The ASYNC object</h3>
  <p>You can start by creating a file called <code>async.js</code> and saving it in your <code>js/</code> folder. Here's the code that defines the essential <code>call</code> method:</p>

  <h4><code>js/async.js</code></h4>
  <pre>"use strict"

var ASYNC

;(function async(){
  ASYNC = {
    call: function call (methodName) {
      var method = this.methods[methodName]
      var args = [].slice.call(arguments)
      var callback = args.pop()
      var result
        , error
   
      if (typeof method === "function") {
        args.shift()
        
        if (typeof callback === "function") {
          <span class="comment">// Simulate asynchronous call</span>
          result = method.apply(this, args)

          if (result instanceof Error) {
            error = result
            result = null
          } else {
            error = null
          }

          setTimeout(function () {
            callback(error, result)
          }, Math.floor(Math.random() * 2000))

        } else {
          <span class="comment">// Return result synchronously</span>
          args.push(callback)
          return method.apply(this, args)
        }

      } else {
        error = new Error("Unknown method: " + methodName)
        if (typeof callback === "function") {
          callback(error)
        } else {
          return error
        }
      }
    }

  , methods: {}
  }
})()</pre>

  <p>Just as with <code>Meteor.call</code> you call this using the syntax:</p>
  <pre>ASYNC.call("methodName"<span class="ymmv">, arguments ... , callback function</span>)</pre>
  <p>If a callback function is given, it will return the result asynchronously (after a random delay). If no callback is given, a result will be returned synchronously.</p>

  <h3>The <code>getWordSegmentation</code> method</h3>
  <p>You can add any method you like to the <code>methods</code> object. Here's how you can add a <code>getWordSegmentation</code> method, which will call a <code>getWordMap</code> method that you haven't yet added to the global <code>dico</code> object.</p>

  <h4><code>js/async.js</code></h4>
  <pre class="revised">"use strict"

var ASYNC

;(function async(){
  ASYNC = {
    call: function call(methodName) {      
      <span class="omit">// code omitted for clarity</span>
    }

  , methods: {
     <span class="comment">/**
       * getWordSegmentation calls dico.getWordMap() for each 
       * string in the map object, and returns an object defining
       * the positionsof the start and end of each word in each
       * string.
       * @param  {object} map has the format
       *                    { &lt;lang code&gt;: [
       *                        &lt;string&gt;
       *                      , ...
       *                      ]
       *                    , ...
       *                    }
       * @return {object}   { &lt;lang code&gt;: [
       *                        { text: &lt;string&gt;
       *                        , offsets: { starts: [
       *                                       &lt;integer&gt;
       *                                     , ...
       *                                     ]
       *                                   , ends: [
       *                                       &lt;integer&gt;
       *                                     , ...
       *                                     ]
       *                                   }
       *                           }
       *                         , ...
       *                         ]
       *                       , ...
       *                       }
       */</span> 
    <span class="new">, getWordSegmentation: function getWordSegmentation(map) {      
        var result = {}
        var lang

        for (lang in map) {
          treatLanguage(lang)
        }

        return result

        function treatLanguage(lang) {
          var stringArray = map[lang]
          var langArray = result[lang]

          if (!langArray) {
            langArray = []
            result[lang] = langArray
          }

          ;(function treatStrings() {
            var ii = stringArray.length
            var wordMap

            while (ii--) {
              try {
                wordMap = dico.getWordMap(stringArray[ii], lang)
                langArray.push(wordMap)
              } catch (error) {
                result = error
                ii = 0
              }
            }
          })()
        }
      }
    }</span>
  }
})()</pre>

  <p>The <code>getWordSegmentation</code> expects as an argument an object map whose keys are <span class="keyword">lang</span> ISO codes, and whose properties are arrays of strings in the given language. You'll have the chance to test it now.</p>

  <h3>Editing <code>index.html</code></h3>
  <p>You'll your to declare your new <code>async.js</code> script in your <code>index.html</code> file. At the same time, you can add a little JavaScript test to call the <code>getWordSegmentation</code> method in the <code>ASYNC</code> object.</p>

  <h4><code>index.html</code></h4>
  <pre><span class="revised">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Selecting Thai words&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;p lang="th"&gt;งมเข็มในมหาสมุทร พูดไปสองไพเบี้ย นิ่งเสียตำลึงทอง ตากลม  ตา&#8203;กลม&lt;/p&gt;
  &lt;p lang="enx"&gt;lookforaneedleinthesea talkisworthtuppence silenceisworthgold exposedtotheair roundeye&lt;/p&gt;

  &lt;script src="js/dictionaries.js"&gt;&lt;/script&gt;</span>
  <span class="new">&lt;script src="js/async.js"&gt;&lt;/script&gt;</span>
  &lt;script&gt;
    var map = {
      th: [
        "งมเข็มในมหาสมุทร"
      , "พูดไปสองไพเบี้ย นิ่งเสียตำลึงทอง"
      , "ตากลม ตา\u200bกลม"
      ]
    , enx: [
        "lookforaneedleinthesea"
      , "talkisworthtuppence silenceisworthgold"
      , "exposedtotheair roundeye"
      ]
    }

    ASYNC.call("getWordSegmentation", map, callback)

    function callback(error, result) {
      console.log(error || JSON.stringify(result))
    }
  &lt;/script&gt;
<span class="revised">&lt;/body&gt;
&lt;/html&gt;</span></pre>

  <h3>Provoking an error</h3>
  <p>You may have noticed that you haven't yet added a <code>getWordMap</code> method to your <code>dico</code> object. The JavaScript engine in your browser certainly will. If you save your edited files and refresh your browser, you should see the following in the Developer Console:</p>

  <pre class="console"><span class="output">TypeError: dico.getWordMap is not a function(…)</span></pre>

  <h3>The <code>getWordMap</code> method</h3>
  <p>To fix this error, you need to add a <code>getWordMap</code> method to your <code>dico</code> object.</p>

  <h4><code>js/dictionaries.js</code></h4>
  <pre class="revised">"use strict"

var dico
var segment

;(function addDictionaries() {
  dico = {

    dictionaries: {
      <span class="omit">// code omitted for clarity</span>
    }

  , tries: {}

  , initialize: function createTries(){
      <span class="omit">// code omitted for clarity</span>
    }

  , createTrie: function createTrie(languageMap) {
      <span class="omit">// code omitted for clarity</span>
    }

  , splitIntoWords: function splitIntoWords(string, languageCode){
      <span class="omit">// code omitted for clarity</span>
    }

  <span class="new">, getWordMap: function getWordMap(string, languageCode) {
      var segments = this.splitIntoWords(string, languageCode)
      var regex = <span class="red">/[^\s!-\/:-@[-`{-~\u00A0-¾—-⁊\u200b]/</span>
      var offsets

      if (!segments) {
        // Split words in unknown language by ASCII word boundaries
        segments = string.split(/\b/)
      }

      offsets = getOffsets()

      return { 
        text: string
      , offsets: offsets
      }

      function getOffsets() {
        var starts = []
        var ends = []
        var total = segments.length
        var index = 0
        var ii
          , segment
          , length
        
        for (ii = 0; ii &lt; total; ii += 1) {
          segment = segments[ii]

          if (regex.test(segment)) {
            // This segment contains word characters
            starts.push(index)
            index += segment.length
            ends.push(index)
          } else {
            // This segment is punctuation or whitespace
            index += segment.length
          }
        }

        return { starts: starts, ends: ends }
      }
    }</span>
  }.initialize()

  segment = {
    <span class="omit">// code omitted for clarity</span>
  }
})()</pre>

  <p>The <code>getWordMap</code> method accepts a string and a language code as arguments. It first checks if the <code>dico</code> object has a dictionary for the given language, and if so, it uses that to split the string into known words. In practice, this would be done on the server by a specialized application. If no dictionary exists for the given language, it splits the string into words and spaces using the simplistic <code>/\b/</code> regular expression, which really only works will with plain English text.</p>
  <p>For example, it will split the string "talkisworthtuppence silenceisworthgold" into:</p>
  <pre>["talk", "is", "worth", "tuppence", " ", "silence", "is", "worth", "gold"]</pre>

  <h3>The <code>getOffsets</code> function</h3>
  <p>The <code>getOffsets</code> function looks at each entry in the <code>segments</code> array in turn, and checks whether or not it contains a non-space character. The regular expression it uses a to do this is rather overkill for this proof-of-concept.</p>
  <pre>/[^\s!-\/:-@[-`{-~\u00A0-¾—-⁊\u200b]/</pre>
  <p>This checks that the string contains none of the non-word characters (such as whitespace, zero-width spaces and punctuation) that are used in any European language. If so, the segment must be a word.</p>
  <p>The <code>getOffsets</code> function populates two lists – <code>starts</code> and <code>ends</code> – with the index of the starting point and end point of each word. For example, for the string "talkisworthtuppence silenceisworthgold", <code>starts</code> will be ...</p>
  <pre>[0, 4, 6, 11, 20, 27, 29, 34]</pre>
  <p>... indicating that the word "talk" starts at <code>0</code> , the word "is" starts at <code>4</code> , and so on. The <code>ends</code> array will be ...</p>
  <pre>   [4, 6, 11, <span class="red">19</span>, 27, 29, 34, 38]</pre>
  <p>Each end point corresponds to the start point of the next word except for <code>19</code> which indicates the end of "tuppence" and the beginning of a space, while <code>20</code> in the <code>starts</code> array indicates the beginning of the word "silence".</p>

  <h3>Testing a second time</h3>
  <p>Now that you have added the <code>getWordMap</code> method, you can save your files and refresh your browser. This time you should see more interesting output in the Developer Console. Here's a prettified version, complete with colouring so that you can see how the index numbers and the word boundaries match each other.</p>

  <figure>
  <pre class="console"><span class="output">{ "th": [
    { "text": "ตากลม ตา​กลม"
    , "offsets": {
        "starts": [0,3,6,9]
      , "ends":     [3,5,8,12]
      }
    }
  , { "text": "<span class="blue">พูด</span>ไป<span class="blue">สอง</span>ไพ<span class="blue">เบี้ย</span> นิ่ง<span class="blue">เสีย</span>ตำลึง<span class="blue">ทอง</span>"
    , "offsets": {
        "starts": [<span class="blue">0</span>,3,<span class="blue">5</span>,8,<span class="blue">10</span>,16,<span class="blue">20</span>,24,<span class="blue">29</span>]
      , "ends":     [<span class="blue">3</span>,5,<span class="blue">8</span>,10,<span class="blue">15</span>,20,<span class="blue">24</span>,29,<span class="blue">32</span>]
      }
    }
  , { "text": "งมเข็มในมหาสมุทร"
    , "offsets": {
        "starts":[0,2,6,8]
      , "ends":    [2,6,8,16]
      }
    }
  ]
, "enx": [
    { "text": "exposedtotheair roundeye"
    , "offsets": {
        "starts": [0,7,9,12,16,21]
      , "ends":     [7,9,12,15,21,24]
      }
    }
  , { "text": "<span class="blue">talk</span>is<span class="blue">worth</span>tuppence <span class="blue">silence</span>is<span class="blue">worth</span>gold"
    , "offsets": {
        "starts": [<span class="blue">0</span>,4,<span class="blue">6</span>,11,<span class="blue">20</span>,27,<span class="blue">29</span>,34]
      , "ends":     [<span class="blue">4</span>,6,<span class="blue">11</span>,19,<span class="blue">27</span>,29,<span class="blue">34</span>,38]
      }
    }
  , { "text": "lookforaneedleinthesea"
    , "offsets": {
        "starts": [0,4,7,8,14,16,19]
      , "ends":     [4,7,8,14,16,19,22]
      }
    }
  ]
}</span></pre>
  <figcaption>Figure 1. Prettified output from <code>getWordSegmentation</code></figcaption>
  </figure>

  <div class="test unselectable">
    <a href="source/06_async/" target="test" class="unselectable">Test Here</a>
  </div>

  <div class="aside next">In this section, you've made your <code>dictionaries.js</code> script behave asynchronously, is if it were on a server. In particular, you've
    <ul>
      <li>Created an <code>async.js</code> script that allows you to simulate an asynchronous call to a server</li>
      <li>Added a <code>getWordMap</code> method to your <code>dico</code> object that takes a string and a language code as in input and returns an array of start and end points of the words in the string</li>
      <li>Used <code>ASYNCH.call</code> to send a map of strings in various languages and to receive a callback some time later with the results of the call.</li>
    </ul>
    <p>For now, you've simply tested your system using a hard-coded map. In the <a href="#mutation">next section</a>, you'll see how to use a <code>MutationObserver</code> to detect whenever new text is added to the web page, and to trigger <code>ASYNC.call("getWordSegmentation", <span class="ymmv">...</span>) </code> automatically.</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#mutation">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- MUTATION -->
<section id="mutation">
  <h2>Detecting text changes</h2>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Use a <code>MutationObserver</code> object to detect each time the text in an HTML page changes</li>
      <li>Use a <code>TreeWalker</code>  object to find which textNodes have changed</li>
      <li>Detect the <code>lang</code> associated with a given <code>textNode</code></li>
      <li>Check whether the user can select the text in a given <code>textNode</code></li>
      <li>Maintain a map of word boundary data for all relevant <code>textNode</code>s on the page</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/raw/gh-pages/thai/source/zips/07_mutate.zip" target="source" class="unselectable">Download the source files</a> <a href="source/07_mutate/" target="test" class="unselectable">Test Here</a>
  </div>

  <h3>Editing the <code>index.html</code> file</h3>
  <p>To test the new features that you will be adding in this section, you can edit your <code>index.html</code> file as shown below. These changes:</p>
  <ul>
  <li>Set the default value of the <code>lang</code> attribute of the entire HTML page to <code>en</code> (English)</li>
  <li>Add text that will not need to be treated</li>
  <li>Add spans to the Thai (<code>th</code>) and EnglishNoSpaces (<code>enx</code>) text, to create a number of <code>textNode</code>s</li>
  <li>Add two spans with a class of <code>unselectable</code>, which will also not need to be treated</li> 
  <li>Add a button and code so that you can remove the <code>unselectable</code> class, after the page has loaded</li>
  </ul>

  <pre class="revised">&lt;!DOCTYPE html&gt;
&lt;html <span class="new">lang="en"</span>&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Selecting Thai words&lt;/title&gt;
  <span class="new">&lt;link rel="stylesheet" type="text/css" href="css/style.css"&gt;</span>
&lt;/head&gt;

&lt;body&gt;
  <span class="new">&lt;h1&gt;Word Segmentation Test&lt;/h1&gt;
  &lt;p&gt;The default &lt;em&gt;lang&lt;/em&gt; of this page is &lt;em&gt;en&lt;/em&gt;.
  The paragraphs below are in Thai (&lt;em&gt;th&lt;/em&gt;) and
  EnglishNoSpaces (&lt;em&gt;enx&lt;/em&gt;).&lt;/p&gt;</span>
  &lt;p lang="th"&gt;งมเข็มในมหาสมุทร
  <span class="new">&lt;span&gt;</span>พูดไปสองไพเบี้ย นิ่งเสียตำลึงทอง<span class="new">&lt;/span&gt;</span>
  <span class="new">&lt;span class="unselectable"&gt;</span>คำเหล่านี้ไม่สามารถเลือกได้<span class="new">&lt;/span&gt;</span>
  ตากลม  ตา&#8203;กลม&lt;/p&gt;
  &lt;p lang="enx"&gt;lookforaneedleinthesea
  <span class="new">&lt;span&gt;</span>talkisworthtuppence silenceisworthgold<span class="new">&lt;/span&gt;</span>
  <span class="new">&lt;span class="unselectable"&gt;</span>thewordsherecannotbeselected<span class="new">&lt;/span&gt;</span>
  exposedtotheair roundeye&lt;/p&gt;

  <span class="new">&lt;button type="button"&gt;Remove .unselectable class&lt;/button&gt;

  &lt;script&gt;
  document.querySelector("button").onclick = function (event) {
    var spans = document.querySelectorAll(".unselectable")
    for (var ii = 0, length = spans.length; ii &lt; length; ii += 1) {
      spans[ii].classList.remove("unselectable")
    }
    this.setAttribute("disabled", true)
  }
  &lt;/script&gt;</span>

  &lt;script src="js/dictionaries.js"&gt;&lt;/script&gt;
  &lt;script src="js/async.js"&gt;&lt;/script&gt;
  <span class="new">&lt;script src="js/selection.js"&gt;&lt;/script&gt;</span>
&lt;/body&gt;
&lt;/html&gt;</pre>

  <h3>Updating the dictionaries</h3>
  <p>This new version of <code>index.html</code> includes new words that you'll need to add to the dictionaries in the <code>dico</code> object:</p>

  <h4><code>js/dictionaries.js</code></h4>
  <pre class="revised">"use strict"

var dico
var segment

;(function addDictionaries() {
  dico = {

    dictionaries: {
      enx: {
        " ": 0
      , "a": 0
      , "air": 0
      <span class="new">, "be": 0
      , "can": 0
      , "cannot": 0
      , "elect": 0
      , "elected": 0
      , "ere": 0</span>
      , "exposed": 0
      , "eye": 0
      , "for": 0
      , "gold": 0
      , "he": 0
      <span class="new">, "here": 0
      , "hew": 0</span>
      , "in": 0
      , "is": 0    
      , "look": 0
      , "need": 0
      , "needle": 0
      <span class="new">, "not": 0</span>
      , "old": 0
      , "or": 0
      , "pence": 0
      , "ran": 0
      , "round": 0
      , "sea": 0
      <span class="new">, "select": 0
      , "selected": 0</span>
      , "she": 0
      , "silence": 0
      , "talk": 0
      , "the": 0
   // , "these": 0
      , "to": 0
   // , "tot": 0
      , "tup": 0
      , "tuppence": 0
      , "up": 0
      , "word": 0
      <span class="new">, "words": 0     
      , "words": 0</span>
      , "worth": 0
      }

    , th: {
        " ": {}
      , "​": {} // &#8203;
      <span class="omit">// code omitted for clarity</span>
      , "ไพ" : {
          "pronunciation": "phai-"
        , "translation": "a certain old coin equal in value to 1/32 baht"
        }
      <span class="new">, "คำ": {
          "pronunciation": "kham-"
        , "translation": "term; discourse; a mouthful or bite; morsel [numerical classifier for a word, an answer to a question, a spoonful of food]"
        }
      , "เหล่า": {
          "pronunciation": "lao_"
        , "translation": "[numerical classifier for groups of items]; a group [of items or things]"
        }
      , "นี้": {
          "pronunciation": "nee'"
        , "translation": "this; these; [is] now"
        }
      , "ไม่": {
          "pronunciation": "mai`"
        , "translation": "not; no; [auxiliary verb] does not; has not; is not; [negator particle]"
        }
      , "สามารถ": {
          "pronunciation": "saa´ maat`"
        , "translation": "capable; able; to have the ability to; can; a Thai given name"
        }
      , "เลือก": {
          "pronunciation": "leuuak`"
        , "translation": "to select or choose; elect; pick"
        }
      , "ได้": {
          "pronunciation": "dai`"
        , "translation": "can; to be able; is able; am able; may; might [auxiliary of potential, denoting possbility, ability, or permission]; to receive; to obtain; acquire; get; have got; to pick out; to choose; to pass [a test or an exam]"
        }</span>
      }
    }

  , tries: {}

  , initialize: function createTries(){
      <span class="omit">// code omitted for clarity</span>
    }

  , createTrie: function createTrie(languageMap) {
      <span class="omit">// code omitted for clarity</span>
    }

  , splitIntoWords: function splitIntoWords(string, languageCode) {
      <span class="omit">// code omitted for clarity</span>
    }
  }.initialize()

  segment = {
    <span class="omit">// code omitted for clarity</span>
  }
})()</pre>

  <h3>Making text unselectable</h3>
  <p>The <code>unselectable</code> class does nothing without a CSS rule. You can create a file called <code>styles.css</code> and save it in a folder named <code>css</code> alongside your HTML document.</p>

  <h4><code>css/styles.css</code></h4>
  <pre>body {
  width: 22em;
}

.unselectable {
  -webkit-touch-callout: none; <span class="comment">/* iOS Safari */</span>
  -webkit-user-select: none;   <span class="comment">/* Chrome/Safari/Opera */</span>
  -khtml-user-select: none;    <span class="comment">/* Konqueror */</span>
  -moz-user-select: none;      <span class="comment">/* Firefox */</span>
  -ms-user-select: none;       <span class="comment">/* Internet Explorer/Edge */</span>
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
  color: #999;
}
</pre>

  <h3>Detecting the value of the <code>lang</code> attribute for a node</h3>
  <p>In the current circumstances, you want to ask the server only for the word boundary data for <code>textNode</code>s in Thai or in our invented EnglishNoSpaces. To choose only text nodes in these languages, you need no detect the closest parent that has a <code>lang</code> attribute, and return the value of that attribute.</p>
  <p>You can create a new file named <code>selection.js</code> and save it in your <code>js/</code> folder. Here's a <code>getLang</code> function. You can leave it in the global namespace for now.</p>

  <h4><code>js/selection.js</code></h4>
  <pre>function getLang(node) {
  var lang = ""

  if(!node.closest) {
    node = node.parentNode
  }
  node = node.closest("[lang]")
  if (node) {
    lang = node.getAttribute("lang")
  }

  return lang
}</pre>

  <p>You can test this in the Developer Console:</p>
  <pre class="console"><span class="input">getLang(document.body)</span>
<span class="output">"en"</span>
<span class="input">getLang(document.querySelector(".unselectable"))</span>
<span class="output">"th"</span>
<span class="input">getLang(document.querySelector("[lang=enx] span"))</span>
<span class="output">"enx"</span>
<span class="input">getLang(document.querySelector("button"))</span>
<span class="output">"en"</span></pre>

  <p class="aside info">Early versions of Internet Explorer do not support the <code><span class="ymmv">element.</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/closest">closest</a>()</code> method. If you need to support such browsers, you can use <a href="https://plainjs.com/javascript/traversing/get-closest-element-by-selector-39/">this polyfill</a>.</p>

  <h3>Detecting unselectable nodes</h3>
  <p>There is no point asking the server send word boundary information on text that cannot be selected. To make the contents of an HTML element unselectable, your can create a CSS rule based on the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/user-select"><code>user-select</code></a> property. As of August 2016, he major browser vendors have not reached agreement on how this is to be implemented, so there are a number of properties with vendor prefixes that you need to test for.</p>
  <p>You can use <code><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle">getComputedStyle</a>(<span class="ymmv">element</span>)</code> to obtain an object with key/value pairs for all properties applied to an element. You can then use the <code><span class="ymmv">array.</span>every</code> method to check all the versions of <code>user-select</code> and to stop looking any further if any of them has a value of <code>none</code>.</p>

  <h4><code>js/selection.js</code></h4>
  <pre>function elementIsSelectable(element) {
  var prefixes = [
    "-webkit-"
  , "-khtml-"
  , "-moz-"
  , "-ms-"
  , ""
  ]
  var style = window.getComputedStyle(element)

  var selectable = prefixes.every(function check(key) {
    key += "user-select"
    return style.getPropertyValue(key) !== "none"
  })

  return selectable
}</pre>

<p>You can test this in the Developer Console:</p>
  <pre class="console"><span class="input">elementIsSelectable(document.body)</span>
<span class="output">true</span>
<span class="input">elementIsSelectable(document.querySelector(".unselectable"))</span>
<span class="output">false</span>
<span class="input">elementIsSelectable(document.querySelector("[lang=enx] span"))</span>
<span class="output">true</span>
<span class="input">elementIsSelectable(document.querySelector("button"))</span>
<span class="output">true</span></pre>

  <h3>Detecting changes to text on the page</h3>
  <p>To detect changes to the DOM, you can create a <code><a href="https://developer.mozilla.org/en/docs/Web/API/MutationObserver">MutationsObserver</a></code> object, and tell it which function to call when an mutation is observed.</p>
  <p class="aside note">In the code listing below, the <code>getLang</code> and <code>elementIsSelectable</code> functions have been moved inside an <a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">immediately-invoked function expression</a>, to take them out of global namespace, now that you have had a chance to test them.</p>

  <pre class="revised"><span class="new">"use strict"

;(function selection() {
  var observer = new MutationObserver(checkForAlteredTextNodes)

  observer.observe(document.body, { 
    childList: true
  , attributes: true
  , subtree: true
  })</span>

  function getLang(node) {
    <span class="omit">// code omitted for clarity</span>
  }

  function elementIsSelectable(element) {
    <span class="omit">// code omitted for clarity</span>
  }

  <span class="new">function checkForAlteredTextNodes(mutations) {
    mutations.forEach(populateNewTextArray)

    function populateNewTextArray(mutation) {
      <span class="comment">// TODO</span>
      console.log(mutation.type, mutation.target, mutation)
    }
  }
})()</span></pre>

  <p>A <code>MutationObserver</code> is set up in two steps. First you create the object and define the function to call when any changes are detected. Then you call <code><span class="ymmv">observer.</span>observe(<span class="ymmv">target, mutationOptions</span>)</code>, to tell it which target element to observe, and what changes to observe on that element.</p>
  <p>The options object needs to set at least one of the following properties to <code>true</code>: <code>attributes</code>, <code>characterData</code> or <code>childList</code>. If your target is a specific <code>textNode</code> then <a href="http://stackoverflow.com/a/33524423/1927589">it is useful to observe <code>characterData</code></a>. If you want to observe changes to the text of all the children of a element (as you do here), then you need to set both <code>childList</code> and <code>subtree</code> to <code>true</code>. In the test that you will run shortly, you will convert unselectable text to selectable text by removing a class from a node; to observe this change, you will also need to set <code>attributes</code> to <code>true</code>.</p>
  <p>The <code>populateNewTextArray</code> function doesn't do much yet, but it does display information about the mutations that are observed in the Developer Console. Here's what you should see when you refresh the page:</p>

  <figure>
  <img src="img/mutation.png" alt="The MutationRecord, with its type and target, that is created when the page is loaded" />
  <figcaption>Figure 2. A MutationRecord with its type and target, that is created when the page is loaded</figcaption>
  </figure>

  <p>When the page is loaded, the <code>childList</code> of the <code>document.body</code> is altered. When you click on the button, you will change the <code>classList</code> attribute of two spans, and the <code>disabled</code> attribute of the button itself. Here is what these mutations look like:</p>
  <figure>
  <img src="img/attributes.png" alt="The Mutation Records created when you click on the button" />
  <figcaption>Figure 3. The Mutation Records created when you click on the button</figcaption>
  </figure>

  <h3>Generating the map to send to <code>getWordSegmentation</code> </h3>
  <p>The purpose of the <code>populateNewTextArray</code> function is to walk through the body of the entire document, looking for <code>textNode</code>s that have been added or changed, and specifically those that need to be set to be treated by the <code>getWordSegmentation</code> method. Once a string has been segmented into words, its segmentation data will be stored in a <code>wordsMap</code> object to be used as needed. The keys in the original empty<code>wordsMap</code> object also indicate which languages need such special treatment.</p>

  <h3>Using a <code>TreeWalker</code></h3>
  <p>An efficient way of doing this is to use a <code><a href="https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker">TreeWalker</a></code> object. The <code>document.<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/createTreeWalker">createTreeWalker</a></code> method accepts up to four arguments. The fourth is not useful here. The three arguments you can use are:</p>
  <ul>
  <li>The root node for the tree to walk</li>
  <li>An <a href="https://www.w3.org/TR/DOM-Level-2-Traversal-Range/traversal.html#Traversal-NodeFilter">NodeFilter integer</a> to indicate which types of nodes in the tree you want to consider</li>
  <li>A filter object with an <code>acceptNode</code> method, which will be called for each node that matches the types indicated by the NodeFilter integer</li>
  </ul>
  <p>Normally, the <code>acceptNode</code> method is used to return <code>true</code> or <code>false</code>, to indicate whether the node should be returned and added to an array for further treatment. In the code listing below, the <code>acceptNode</code> method is co-opted to do all the work of building the map that will be sent to the <code>getWordSegmentation</code> method.</p>

  <h4><code>js/selection.js</code></h4>
  <pre class="revised">"use strict"

;(function selection() {
  <span class="new">var wordsMap = { th: {}, enx: {} }</span>
  var observer = new MutationObserver(checkForAlteredTextNodes)

  observer.observe(document.body, { 
    childList: true
  , attributes: true
  , subtree: true
  })

  function getLang(node) {
    <span class="omit">// code omitted for clarity</span>
  }

  function elementIsSelectable(element) {
    <span class="omit">// code omitted for clarity</span>
  }

  function checkForAlteredTextNodes(mutations) {
    <span class="new">var newTextMap = {} <span class="comment">// { &lt;lang&gt;: [&lt;string&gt;, ...], ...}</span>
    var newTextFound = false</span>

    mutations.forEach(populateNewTextArray)

    <span class="new">if (newTextFound) {
      ASYNC.call("getWordSegmentation", newTextMap, updateWordsMap)
    }</span>

    function populateNewTextArray(mutation) {
      <span class="new">var filter = {
        acceptNode: function(node) {
          var text = node.data
          var lang
            , map
            , langArray

          if (!/^\s*$/.test(text)) {
            lang = getLang(node)

            if (map = wordsMap[lang]){
              if (elementIsSelectable(node.parentNode)) {
                if (!map[text]) {
                  if (!(langArray = newTextMap[lang])) {
                    langArray = []
                    newTextMap[lang] = langArray
                  }

                  langArray.push(text)
                  map[text] = true
                  newTextFound = true
                }
              }
            }
          }
        }
      }
      var walker = document.createTreeWalker(
        mutation.target
      , NodeFilter.SHOW_TEXT
      , filter
      )

      while (walker.nextNode()) {
        <span class="comment">// Action occurs in filter.acceptNode</span> 
      }</span>
    }

    <span class="new">function updateWordsMap(error, result) {
      <span class="comment">// TODO</span>
      console.log(error || JSON.stringify(result))
    }</span>
  }
})()</pre>

  <p>For each <code>textNode</code>, the <code><span class="ymmv">filter.</span>acceptNode</code> function is called. This runs through the following checklist:</p>
  <dl>
    <dt><code>if (!/^\s*$/.test(text)) {<span class="ymmv">...</span>}</code></dt>
    <dd>Does this textNode contain anything other than whitespace?</dd>
    <dt><code>lang = getLang(node); if (map = wordsMap[lang]) {<span class="ymmv">...</span>}</code></dt>        
    <dd>Is this textNode in a language that needs custom word segmentation?</dd>
    <dt><code>if (elementIsSelectable(node.parentNode)) {<span class="ymmv">...</span>}</code></dt>
    <dd>Does this textNode contain text that the user can select?</dd>
    <dt><code>if (!map[text]) {</code></dt>
    <dd>Has the string data found in this textNode not already been treated, or started to be treated?</dd>            
  </dl>
  <p>If the answer to all these questions is Yes, then the string <code>data</code> of the textNode will be added to the appropriate language array in <code>newTextMap</code>, and an entry will be added in the appropriate place in the <code>wordsMap</code> object, to indicate that the string is about to be treated. If an identical string is found later, the script will know not to make a new request for treatment.</p>
  <p>When you save your changes and refresh the page in your browser, you should see the same output as is shown in Figure 1 at the end of the previous section. This time, however, the text is taken directly from the HTML page, and not hard-coded in JavaScript.</p>
  <figure>
  <img src="img/wordmap.png" alt="Output generated automatically from newTextMap" />
  <figcaption>Figure 4. Figure 1. Output generated automatically from <code>newTextMap</code></figcaption>
  </figure>

  <p>If you click on the button, the spans that currently have the <code>unselectable</code> class will lose that class, and the <code>getWordSegmentation</code> method will be called again, with just the text that has become selectable:</p>

  <figure>
  <img src="img/selectable.png" alt="Making text selectable will trigger the checkForAlteredTextNodes function again" />
  <figcaption>Figure 5. Making text selectable will trigger the <code>checkForAlteredTextNodes</code> function again</figcaption>
  </figure>

  <h3><code>updateWordsMap</code></h3>
  <p>The last step for this section is to update the <code>wordsMap</code> object, to store the data retrived by the asynchronous call to <code>getWordSegmentation</code>. You can make the changes shown below in your <code>selection.js</code> script, and then refresh the page in your browser.</p>

  <h4><code>js/selection.js</code></h4>
  <pre class="revised">"use strict"

;(function selection(){
  var wordsMap = { th: {}, enx: {} }
  var observer = new MutationObserver(checkForAlteredTextNodes)

  observer.observe(document.body, { 
    childList: true
  , attributes: true
  , subtree: true
  })

  function getLang(node) {
    <span class="omit">// code omitted for clarity</span>
  }

  function elementIsSelectable(element) {
    <span class="omit">// code omitted for clarity</span>
  }

  function checkForAlteredTextNodes(mutations) {
    <span class="omit">// code omitted for clarity</span>
  }

  <span class="comment">/**
   * updateWordsMap is triggered by a callback from the ASYNC
   * call to getWordSegmentation. For each language and each
   * text key, it replaces the existing `true` entry with the
   * `offsets` array for the word boundaries in the given
   * string.
   * @param  {Error|null}  error
   * @param  {null|object} result 
   *                       { &lt;lang&gt;: [
   *                           { "text": &lt;string&gt;
   *                           , "offsets": {
   *                               "starts": [&lt;integer&gt;, ...]
   *                             , "ends": [&lt;integers&gt;, ...]
   *                             }
   *                           }
   *                         , ...
   *                         ]
   *                       , ...
   *                       }
   */</span>
  function updateWordsMap(error, result) {    
    <span class="new">if (error) {
      return console.log(error)
    }

    var lang
      , langArray
      , langMap
      , ii
      , textData

    for (lang in result) {
      langMap = wordsMap[lang]
      langArray = result[lang]

      ii = langArray.length
      while (ii--) {
        textData = langArray[ii]
        langMap[textData.text] = textData.offsets
      }
    }

    console.log(JSON.stringify(wordsMap))</span>
  }
})()</pre>

  <div class="test unselectable">
    <a href="source/07_mutate/" target="test" class="unselectable">Test Here</a>
  </div>

  <div class="aside next">In this section, you've automated the process of getting word segmentation for Thai text. In particular you've:
    <ul>
      <li>Used the <code><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/closest">closest</a></code> method to find the closest element in the hierarchy with a <code>lang</code> attribute</li>
      <li>Used <code><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle">getComputedStyle</a></code> to determine if the text in a given node is selectable</li>
      <li>Used a <code><a href="https://developer.mozilla.org/en/docs/Web/API/MutationObserver">MutationsObserver</a></code> to detect when text in the page changes</li>
      <li>Created a <code><a href="https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker">TreeWalker</a></code> to find which textNodes have changed</li>
    </ul>
    <p>In the <a href="#jump">next section</a>, you'll use the code that you have created so far to extend a <a href="../selection/">jumpToNextWord</a> function, where pressing arrow keys will select the neighbouring word.</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#jump">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- JUMP -->
<section id="jump">
  <h2>Jump to adjacent words</h2>
  <div class="top"><p>In the <a href="../selection/">Text Selection tutorial</a>, you can see how to develop a script named <code>selection.js</code> that allows you to use the arrow keys to select the word adjacent to the current selection.</p>
  <p>The script developed in that tutorial only works with languages where words are separated by spaces. In this current tutorial, you have learned how to generate word segmentation data for a string of Thai text. Now you're ready to merge the two <code>selection.js</code> scripts so that you can use the arrow keys to jump to adjacent words in Thai text too.</p></div>
  <div class="aside preview">In this section, you'll discover how to extend the <code>selection.js</code> script from the <a href="../selection/" class="plain">Text Selection tutorial</a> so that it also works with the Thai language. You see how to:
    <ul>
      <li>Add the functions you have developed in this tutorial to the original <code>selection.js</code> script</li>
      <li>Modify the <code>jumpLeft</code> and <code>jumpRight</code> functions of the original <code>selection.js</code> script so that they work with Thai text</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/raw/gh-pages/thai/source/zips/08_jump.zip" target="source" class="unselectable">Download the source files</a> <a href="source/08_jump/" target="test" class="unselectable">Test Here</a>
  </div>
  <p class="aside info">The original <code>selection.js</code> script is quite lengthy. This section shows only the parts of it where you need to make changes. It's a good idea to download the full source code and follow where the changes have been made.</p>

  <h3>Merging the two <code>selection.js</code> scripts</h3>
  <p>The abridged code listing below shows where the code from your new <code>selection.js</code> script can be added to the original script. Note that the <code>jumpLeft</code> and <code>jumpRight</code> functions that you will be looking at here are different from those in the original version.</p>

  <h4><code>js/selection.js</code></h4>
  <pre class="revised">"use strict"

;(function selection(){
  <span class="omit">// code omitted for clarity</span>

  var box = document.<span class="new">body //</span> querySelector(".box")
  <span class="new">var wordsMap = { th: {}, enx: {} }
  var observer = new MutationObserver(checkForAlteredTextNodes)

  observer.observe(document.body, { 
    childList: true
  , attributes: true
  , subtree: true
  })</span>

  box.ondblclick = selectHyphenatedWords
  document.body.onkeydown = jumpToNextWord

  function selectHyphenatedWords(event) {
    <span class="omit">// code omitted for clarity</span>
  }

  function extendSelectionBackBeforeHypen(string, offset) {
    <span class="omit">// code omitted for clarity</span>
  }

  function extendSelectionForwardAfterHyphen(string, offset) { 
    <span class="omit">// code omitted for clarity</span>
  }

  function jumpToNextWord (event) {
    <span class="omit">// code omitted for clarity</span>
  }

  function jumpLeft() {
    <span class="new">// code here will be edited</span>
  }

  function jumpRight() {
    <span class="new">// code here will be edited</span>
  }

  function getAdjacentTextNode(node, whichSibling, arrayMethod) {
    <span class="omit">// code omitted for clarity</span>
  }

  function scrollIntoView(range) {
    <span class="omit">// code omitted for clarity</span>
  }

  <span class="new">function getLang(node) {
    <span class="omit">// code omitted for clarity</span>
  }

  function elementIsSelectable(element) {
    <span class="omit">// code omitted for clarity</span>
  }

  function checkForAlteredTextNodes(mutations) {
    <span class="omit">// code omitted for clarity</span>
  }

  function updateWordsMap(error, result) {
    <span class="omit">// code omitted for clarity</span>
  }</span>
})()</pre>

  <h3>Checking <code>lang</code> in <code>jumpLeft</code></h3>
  <p>The technique that you will use for selecting the adjacent word will be different when the language is Thai. The code listing below shows how <code>jumpLeft</code> can be split into two internal functions: <code>jumpLeftWithRegex</code>, which behaves use almost exactly the same code as the original <code>jumpLeft</code> function, and <code>jumpLeftWithMap</code> which will use the data in the <code>wordsMap</code> object. A <code>switch</code> statement uses the <code>lang</code> attribute applied to the container node to determine which approach should be taken.</p>
  <p>Note the minor change in the <code>jumpLeftWithRegex</code> function. If the current word is the first in the current container, word to select will be in the previous textNode. It's possible that the previous textNode is in a different language, and the <code>jumpLeftWithRegex</code> function might not be appropriate for that language.</p>
  <p>The solution is to:
  <ul>
  <li>Create a new <code>range</code> object (so that the selection is not changed if there is nothing earlier to select)</li>
  <li>Place the <code>range.endOffset</code> at the end of the previous textNode</li>
  <li>Call the parent <code>jumpLeft</code> function recursively.</li>
  </ul>
  <p>The <code>endOffset</code> cannot be placed earlier than the <code>startOffset</code>, so <code>startOffset</code> is now set to exactly the same point. You'll see the importance of this in a moment. This technique ensures that the function used for selecting the last word in the previous textNode is appropriate for the language of that node.</p>

  <h4><code>js/selection.js</code></h4>
  <pre class="revised"><span class="omit">...</span>

  function jumpLeft() {
    container = range.endContainer
    <span class="new">var lang = getLang(container)

    switch (lang) {
      case "th":
      case "enx":
        return jumpLeftByMap(container)
      default:
        return jumpLeftByRegex(container)
    }

    function jumpLeftByMap(container) {
      <span class="comment">// TODO</span>
    }

    function jumpLeftByRegex(container) {</span>
      var string = container.textContent
      var result = getPreviousWord(string, range.startOffset)
      var startOffset
        , endOffset
        , rangeData

      if (!result) {
        <span class="comment">// There are no more words in this text node. Try the previous.</span>
        container = getAdjacentTextNode(
          container
        , "previousSibling"
        , "pop"
        )

        if (container) {
          <span class="new">range = document.createRange()
          range.setEnd(container, container.textContent.length)
          return jumpLeft()</span>

        } else {
          <span class="comment">// We're at the very beginning of the selectable text. 
          // There's nothing earlier to select.</span>
          return
        }
      }

      startOffset = result.index
      endOffset = startOffset + result[0].length

      rangeData = {
        container: container
      , startOffset: startOffset
      , endOffset: endOffset
      , string: string
      }

      return rangeData

      function getPreviousWord(string, offset) {
        string = string.substring(0, offset)
        var result
          , temp

        while (temp = lastWordRegex.exec(string)) {
          result = temp
        }

        return result
      }
    <span class="new">}</span>
  }

<span class="omit">...</span></pre>

  <h3><code>jumpLeftByMap</code></h3>
  <p>The <code>jumpLeftByMap</code> function first checks that there is an entry in <code>wordsMap</code> for the textContent of the current node. If the server has not yet called back with the result of the <code>getWordSegmentation</code> call, then the only solution is to cancel the action.</p>
  <p class="aside issue">In a production version of this feature, it would be good to <a href="https://github.com/lexogram/openbook/issues/3">show a tooltip or a spinner</a> to justify why nothing is happening.</p>
  <p>If the server has already responded, then <code>endOffset</code> is set to <code>range.endOffset + (range.startOffset === string.length)</code> and the function <code>setOffsets</code> is called to set the values of <code>startOffset</code> and <code>endOffset</code> as required to select the previous word.</p>
  <p>In most cases, <code>range.startOffset === string.length</code>  will be <code>false</code> so <code>endOffset</code> will be set to <code>range.endOffset</code>. When <code>jumpLeft</code> is called recursively because the current selection is the first word in the next textNode, then the instruction <code>range.setEnd(container, container.textContent.length)</code> described above will also set the <code>startOffset</code> to the end of the previous container. In this case <code>range.startOffset === string.length</code> will be <code>true</code> and <code>endOffset</code> will be set to <code>range.endOffset + 1</code>. This ensures that the <code>setOffsets</code> function will correctly choose the start and end offsets for the last word in the current container.</p>

  <h4><code>js/selection.js</code></h4>
  <pre><span class="omit">...</span>

    function jumpLeftByMap(container) {
      var string = container.textContent
      var wordMap = wordsMap[lang][string]
      if (typeof wordMap !== "object")) {
        return console.log("No word map for ", string)
      }
      var wordEnds = wordMap.ends
      var wordStarts = wordMap.starts
      var endOffset = range.endOffset
                    + (range.startOffset === string.length)
      var startOffset
      var rangeData
      var result = setOffsets(endOffset)

      if (!result) { 
        <span class="comment">// TODO</span>
      }

      rangeData = {
        container: container
      , startOffset: startOffset
      , endOffset: endOffset
      , string: string
      }

      return rangeData

      function setOffsets(offset) {
        var ii = wordEnds.length

        while (ii--) {
          if ((endOffset = wordEnds[ii]) &lt; offset) {
            startOffset = wordStarts[ii]
            ii = 0
          }
        }

        return (startOffset !== undefined)
      }
    }

<span class="omit">...</span></pre>

  <h3><code>setOffsets</code></h3>
  <p>The <code>wordEnds</code> variable is an array of index numbers of the next character after the end of each word. For the sentence "lookforaneedleinthesea" <code>wordEnds</code> will be <code>[4,7,8,14,16,19,22]</code>. The <code>setOffsets</code> function receives an offset which may be the current <code>range.endOffset</code> (if a word in this textNode is already selected), or the-last-item-in-<code>wordEnds</code>-plus-1 (if the first word in the next textNode is selected). It works backwards from the end of the <code>wordEnds</code>, looking for the first number that is smaller. If it finds such a number, it sets <code>startOffset</code>to the corresponding entry in <code>wordStarts</code>. However, if the first word in the current textNode is selected, then it won't find a smaller number, and <code>startOffset</code> will remain undefined. When this happens, <code>setOffsets</code> will return <code>false</code>. This will trigger a recursive jump to the previous textNode, as you'll see below.</p>

  <h4><code>js/selection.js</code></h4>
  <pre class="revised"><span class="omit">...</span>

    function jumpLeftByMap(container) {
      var string = container.textContent
      var wordMap = wordsMap[lang][string]
      if (!wordMap) {
        return console.log("No word map for ", string)
      }
      var wordEnds = wordMap.ends
      var wordStarts = wordMap.starts
      var endOffset = range.endOffset
                    + (range.startOffset === string.length)
      var startOffset
      var rangeData
      var result = setOffsets(endOffset)

      if (!result) {     
        <span class="new">container = getAdjacentTextNode(
          container
        , "previousSibling"
        , "pop"
        )

        if (container) {
          range = document.createRange()
          range.setEnd(container, container.textContent.length)
          return jumpLeft()

        } else {
          <span class="comment">// We're at the very beginning of the selectable text.
          // There's nothing earlier to select.</span>
          return
        }</span>
      }

      rangeData = {
        container: container
      , startOffset: startOffset
      , endOffset: endOffset
      , string: string
      }

      return rangeData

      function setOffsets(offset) {
        <span class="omit">// code omitted for clarity</span>
      }
    }
<span class="omit">...</span></pre>

  <p>The technique for jumping back to the previous textNode is identical to the way it is done in <code>jumpLeftByRegex</code> </p>

  <h3>Jumping to the right</h3>
  <p>Jumping to the right works in a very similar way.</p>

  <h4><code>js/selection.js</code></h4>
  <pre class="revised">...

  function jumpRight() {
    container = range.startContainer
    <span class="new">var lang = getLang(container)

    switch (lang) {
      case "th":
      case "enx":
        return jumpRightByMap(container)
      default:
        return jumpRightByRegex(container)
    }

    function jumpRightByMap(container) {
      var string = container.textContent
      var wordMap = wordsMap[lang][string]
      if (typeof wordMap !== "object") {
        return console.log("No word map for ", string)
      }
      var wordEnds = wordMap.ends
      var wordStarts = wordMap.starts
      var startOffset = range.startOffset - (!range.endOffset)
      var endOffset
      var rangeData
      var result = setOffsets(startOffset)

      if (!result) {     
        container = getAdjacentTextNode(
          container
        , "nextSibling"
        , "shift"
        )

        if (container) {
          range = document.createRange()
          range.setStart(container, 0)
          return jumpRight()

        } else {
          // We're at the very beginning of the selectable text.
          // There's nothing earlier to select.
          return
        }
      }

      rangeData = {
        container: container
      , startOffset: startOffset
      , endOffset: endOffset
      , string: string
      }

      return rangeData

      function setOffsets(offset) {
        var ii
        var length = wordStarts.length

        for (ii = 0; ii &lt; length; ii += 1) {
          if ((startOffset = wordStarts[ii]) > offset) {
            endOffset = wordEnds[ii]
            ii = length
          }
        }

        return (endOffset !== undefined)
      }
    }

    function jumpRightByRegex(container) {</span>
      var startOffset = range.endOffset
      var string = container.textContent
      var result = nextWordRegex.exec(string.substring(startOffset))
      var endOffset
        , rangeData

      if (result) {
        startOffset += result[0].length

      } else {
        // There are no more words in this text node. Try the next.
        container = getAdjacentTextNode(
          container
        , "nextSibling"
        , "shift"
        )

        if (container) {
          <span class="new">range = document.createRange()
          range.setStart(container, 0)
          return jumpRight()</span>

        } else {
          // We're at the very end of the selectable text. There's
          // nothing more to select.
          return
        }
      }

      result = wordEndRegex.exec(string.substring(startOffset))
      endOffset = startOffset + result.index

      rangeData = {
        startOffset: startOffset
      , endOffset: endOffset
      , string: string
      }

      return rangeData
    }
  }</pre>

  <p>You can now double-click on a word to select it and use the left and right arrow keys to move the selection to the adjacent word.</p>

  <div class="test unselectable">
    <a href="source/08_jump/" target="test" class="unselectable">Test Here</a>
  </div>

  <div class="aside next">In this section, you've added the functions that you recently created in your <code>selection.js</code> script with the <code>selection.js</code> script from an earlier tutorial. You've split the <code>jumpLeft</code> and <code>jumpRight</code> functions to create two ways to select the adjacent word, depending on the language.
  <p>In the <a href="#translate">next section</a>, you'll see how to simulate querying the server for the translation of the selected word.</p>
  </div>

  <footer>
    <ul class="nav">
      <li>
        <a href="#translate">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- TRANSLATE -->
<section id="translate">
  <h2>Querying an online dictionary</h2>
  <div class="aside preview">In this section, you'll learn how to:
    <ul>
      <li>Query the <code>dico</code> object asynchronously the translation of the current selection</li>
      <li>Display the translation in your web page</li>
      <li>Cache translations in order to display them faster the second and subsequent times they are requested</li>
    </ul>
    <a href="https://github.com/lexogram/openbook/raw/gh-pages/thai/source/zips/09_translate.zip" target="source" class="unselectable">Download the source files</a> <a href="source/09_translate/" target="test" class="unselectable">Test Here</a>
  </div>

  <h3>Simplifying <code>index.hmtl</code></h3>
  <p>In this final section, you can simplify your <code>index.html</code> file by removing all the text in EnglishNoSpaces. To limit the action of the word selection feature, you can create a box around the Thai text. You can also add a &lt;div&gt; element to contain the translation, when it becomes available.</p>

  <h4><code>index.html</code></h4>
  <pre class="revised">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Selecting Thai words&lt;/title&gt;
  &lt;link rel="stylesheet" type="text/css" href="css/style.css"&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;h1&gt;Word Segmentation Test&lt;/h1&gt;
  <span class="new">&lt;p&gt;Select a Thai word to see its pronounciation and
  translation.&lt;/p&gt;
  &lt;div class="box"&gt;
    &lt;p lang="th"&gt;งมเข็มในมหาสมุทร พูดไปสองไพเบี้ย นิ่งเสียตำลึงทอง
    ตากลม ตา&#8203;กลม&lt;/p&gt;
  &lt;/div&gt;

  &lt;div id="translation"&gt;&lt;div&gt;</span>

  &lt;script src="js/dictionaries.js"&gt;&lt;/script&gt;
  &lt;script src="js/async.js"&gt;&lt;/script&gt;
  &lt;script src="js/selection.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

  <p>You can add some cosmetic CSS, to make the page more elegant.</p>

  <h4><code>css/style.css</code></h4>
  <pre class="revised">body {
  width: 22em;
}

<span class="new">.box {
background-color: #eef;
border: 1px solid #ccf;
border-style:inset;
}
.box p {
  margin: 0.5em;
}

dt {
  font-weight: bold;
}</span></pre>

  <h3>Adding a <code>getWordData</code> method to the dictionary</h3>
  <p>The <code>th</code> entry in your dictionary is a map object where the keys are Thai words and the values are objects with the format:</p>
  <pre>{ pronunctiation: &lt;string&gt;
  , translation: &lt;string&gt;
  }</pre>

  <p>You can add a <code>getWordData</code> method to the <code>dico</code> object that will return an object with the format:</p>
  <pre>{ pronunctiation: &lt;string&gt;
  , translation: &lt;string&gt;
  , word: &lt;string&gt;
  , lang: &lt;string&gt;
  }</pre>

  <p>However, if a request is made for a word that doesn't exist, or for a language for which there is no dictionary, it makes sense to return an object with the format ...</p>
  <pre>{ 
  , ⚠: "no data available"
  , word: &lt;string&gt;
  , lang: &lt;string&gt;
  }</pre>
  <p>... where ⚠ is encoded in JavaScript as <code>"\u26A0"</code>.</p>
  <p class="aside tip">A fast way to make a deep clone of a JavaScript object is to use <code><span class="ymmv">clone</span> = JSON.parse(JSON.stringify(<span class="ymmv">original</span>))</code> </p>


  <h4><code>js/dictionary.js</code></h4>
  <pre class="revised">"use strict"

var dico
var segment

;(function addDictionaries() {
  dico = {

    dictionaries: {
      <span class="omit">// code omitted for clarity</span>
    }

  , tries: {}

  , initialize: function createTries(){
      <span class="omit">// code omitted for clarity</span>
    }

  , createTrie: function createTrie(languageMap) {
      <span class="omit">// code omitted for clarity</span>
    }

  , splitIntoWords: function splitIntoWords(string, languageCode) {
      <span class="omit">// code omitted for clarity</span>
    }

  , getWordMap: function getWordMap(string, languageCode) {
      <span class="omit">// code omitted for clarity</span>
    }

  <span class="new">, getWordData: function getWordData(word, languageCode) {
      var dictionary = this.dictionaries[languageCode]
      var data

      if (dictionary) {
        data = dictionary[word]
        if (data) {
          data = JSON.parse(JSON.stringify(data))
        } else {
          data = { "\u26A0": "no data available" }
        }
        data.word = word
        data.lang = languageCode
      }

      return data
    }</span>
  }.initialize()

  segment = {
    <span class="omit">// code omitted for clarity</span>
  }
})()</pre>

  <h3>Defining an asynchronous method for calling <code>dico.getWordData</code></h3>
  <p>To call <code>dico.getWordData</code> asynchronously, you can add the following <code>getTranslation</code> method to your <code>ASYNC</code> object:</p>

  <h4><code>js/async.js</code></h4>
  <pre class="revised">"use strict"

var ASYNC

;(function async(){
  ASYNC = {
    <span class="omit">// code omitted for clarity</span>
    }

  , methods: {
      getWordSegmentation: function getWordSegmentation(map) {
        <span class="omit">// code omitted for clarity</span>
      }

    <span class="new">, getTranslation: function getTranslation(word, languageCode) {
        try {
          return dico.getWordData(word, languageCode)
        } catch (error) {
          return error
        }
      }
    }
  }</span>
})()</pre>

  <h3>Updating <code>selection.js</code></h3>
  <p>With all these changes in place, you can now add a <code>requestTranslation</code> function to your <code>selection.js</code> script. You can add calls to this from 3 places:</p>
  <ul>
  <li>Any mouseup event on the <code>div.box</code> element, in case the user clicks and drags to make a custom selection</li>
  <li>Any dblclick event on the <code>div.box</code> element, after a complete word (which may contain hyphens) is selected</li>
  <li>Any time the user presses the left or right arrow key to select a new word</li>
  </ul>

  <p>As you will see in the code listing below, the <code>requestTranslation</code> function can work both asynchronously and synchronously. A <code>wordsCache</code> object is created when the code is loaded. The <code>requestTranslation</code> function first checks if this <code>wordsCache</code> object already contains an entry for the selected word and language. If not, it makes a call to <code>ASYNC.call("getTranslation", <span class="ymmv">...</span>)</code>, using the nested <code>showTranslation</code> function as a callback. If the <code>wordsCache</code> object already contains an entry for the word, the <code>showTranslation</code> function is called immediately, with the <code>alreadyCached</code> argument set to <code>true</code>.</p>
  <p>If the translation is retrieved via the asynchronous call to <code>ASYNC.call("getTranslation", <span class="ymmv">...</span>)</code>, the <code>alreadyCached</code> argument will be <code>undefined</code>, and the incoming data will be added to <code>wordsCach</code>, so that it can be retrieved locally the next time. If the selection has changed in the meantime, the operation ends there. If the selected is string is identical to the <code>word</code> property of the incoming <code>data</code> object, then a header and a description list element (<code>&lt;dl&gt;</code>) are created to show information about the word, and displayed in the <code>div#translation</code> element.</p>

  <h4><code>js/selection.js</code></h4>
  <pre class="revised">;(function selection(){
  <span class="omit">// code omitted for clarity</span>

  var box = document.<span class="new">querySelector(".box")
  var wordsCache = {}</span>
  var wordsMap = { th: {}, enx: {} }
  var observer = new MutationObserver(checkForAlteredTextNodes)

  observer.observe(document.body, { 
    childList: true
  , attributes: true
  , subtree: true
  })

  <span class="new">box.onmouseup = requestTranslation</span>
  box.ondblclick = selectHyphenatedWords
  document.body.onkeydown = jumpToNextWord

  function selectHyphenatedWords(event) {
    <span class="omit">// code omitted for clarity</span>

    if (selectionUpdated) {
      selection.removeAllRanges()
      selection.addRange(range)
    }

    scrollIntoView(range)
    <span class="new">requestTranslation()</span>
  }

  <span class="omit">// code omitted for clarity</span>

  function jumpToNextWord (event) {
    <span class="omit">// code omitted for clarity</span>

    selection.removeAllRanges()
    selection.addRange(range)
    scrollIntoView(range)
    <span class="new">requestTranslation()</span>
  }
  
  <span class="omit">// code omitted for clarity</span>

  <span class="new">function requestTranslation() {
    var word = selection.toString()
    var lang = getLang(selection.getRangeAt(0).startContainer)
    var data

    // Ignore word if it is all whitespace
    word = word.match(lastWordRegex)
    if (word) {
      word = word[0]
    } else {
      return
    }

    if ((data = wordsCache[lang]) &amp;&amp; (data = data[word])) {
      return showTranslation(null, data, true)
    }
    
    ASYNC.call("getTranslation", word, lang, showTranslation)

    function showTranslation (error, data, alreadyCached) {
      if (error) {
        return console.log(error)
      }

      var pTranslation = document.getElementById("translation")
      var string
        , word
        , lang

      if (data) {
        word = data.word
        lang = data.lang
        if (!alreadyCached) {
          addToWordsCache(lang, word, data)
        }

        if (word !== selection.toString()) {
          return
        }

        string = "&lt;h3&gt;" + word + "&lt;/h3&gt;&lt;dl&gt;"

        for (var key in data) {
          if (key !== "word" &amp;&amp; key !== "lang") {
            string += "&lt;dt&gt;" + key + "&lt;/dt&gt;"
            string += "&lt;dd&gt;" + data[key] + "&lt;/dd&gt;"
          }
        }

        string += "&lt;/dl&gt;"
      }

      pTranslation.innerHTML = string
    }

    function addToWordsCache(lang, word, data) {
      var langMap = wordsCache[lang]
      if (!langMap) {
        langMap = {}
        wordsCache[lang] = langMap
      }

      langMap[word] = data
    }
  }</span>
})()</pre>

  <div class="test unselectable">
    <a href="source/09_translate/" target="test" class="unselectable">Test Here</a>
  </div>

  <h3>Testing</h3>
  <p>After you save your changes and relaunch your web page, you can test the translation feature. You can try both double-clicking on a Thai word or clicking and dragging to make a custom selection.</p>
  <div class="aside tip">See what happens when you:
  <ul>
  <li>Select the individual syllables "มหา" or "สมุทร" in the word "มหาสมุทร"</li>
  <li>Select all the characters between two spaces, so that more than one word is selected</li>
  <li>Use the right arrow key to jump to the next word. You can start by moving slowly from word to word, waiting until the asynchronous call returns, and then use the left arrow key to jump back to words whose translation has already been cached. You'll see that the response is much faster.</li>
  </ul></div>

  <p class="aside next">In this section, you've completed a simulation of calling a server in order to get both word boundary data and word definitions, using a number of techniques that you discovered earlier in this tutorial.</p>

  <footer>
    <ul class="nav">
      <li>
        <a href="#end">
         <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>

<!-- CONCLUSION -->
<section id="end">
  <h2>Conclusion</h2>
  <p>If you have made the effort to get this far, well done!</p>
  <div class="aside preview">Here's what you've learnt:
    <ul>
      <li>Finding word boundaries in certain languages requires a call to a dedicated application on a server</li>
      <li>You can detect when the text on a page changes, and call the server after each change to obtain the word boundary data for the new text</li>
      <li>You can cache the results of calls to the server to speed up future operations</li>
      <li>You can use the word boundary data to determine the next and previous words, and use the arrow keys to jump between them.</li>
      <li>You can query a database for information about the words</li>
    </ul>
  </div>

  <h3>Where to go from here</h3>
  <p>The <a href="../reference/">Language Reference</a> tutorial builds on the techniques that you have learned here, to connect to a <a href="https://en.wiktionary.org">Wiktionary page</a> when you select a word in the box at the top of the NoteBook popup window.</p>
</section>

<!-- OVERVIEW  -->
<section id="top">
  <h2>Overview</h2>

  <p class="top">This tutorial is part of a series that describes ho to build a Chrome extension that helps you to learn a foreign language. With the extension, any text you select in any web page will be copied to a pop-up window. If you select a word in the pop-up window, the appropriate Wiktionary page for that word will be shown in an iFrame. An <a href="../selection/">earlier tutoral</a> shows you how to get this to work for European languages, which use spaces as word boundaries. This tutorial shows you how to extend it to Thai (and by extension to other Asian languages), where no spaces are used between words.</p>
  <p>In a browser, you expect a double-click to select a whole word, regardless of which language that word is written in. A browser like Chrome, the word boundaries for many languages are automatically detected. Other browsers may fail to indentify word boundaries in non-European languages and select either syllables or whole phrases instead. If you want to select a whole word in such browsers, or without using a double-click, you need to know how to analyze text to find word boundaries.</p>
  <p>The aim of this tutorial is to develop a proof-of-concept system which will allow you to use the arrow keys to jump to neighbouring Thai words. As you will see, distinguishing boundaries between Thai words is best performed asynchronously on the server. This tutorial will show you how to create a minimal word boundary detection system that will run in your browser, and to make asynchronous calls to it, to simulate a connection to the server.</p>
  <p>The final step is to simulate a connection to a server to retrieve the dictionary definition of the selected word.</p>
  <h3>Word boundaries</h3>
  <p>In spoken language, words tend to flow together. In a sentence like "We went on a long journey", you have to wait until the word "journey" is spoken before you can be sure that "a long" is two words. Conversely, if the sentence was "We went on along the road", you would need to wait until the word "the" to know that the same sounds were the single word "along".</p>
  <p>In many written languages, there are visual signs to indicate where words end. In European languages descended from Latin and Greek, a space is used between words, but there is still some ambiguity about whether "can't" is one word or two. In Arabic, letters have different shapes depending on whether they appear at the beginning, in the middle or the end of a word, as an additional clue.</p>
  <p>However, in other languages, such as Chinese and Japanese, there are spaces between sentences, but no spaces between words. In Thai and Lao, there may also be spaces between clauses, so the space character itself is ambiguous. In Vietnamese, there is a space between each syllable, while several syllables may combine to make a single word.</p>
  <p>This tutorial explores two simple techniques for segmenting written Thai into words. However, there is no generic automated solution for this, for several reasons, including:</p>
  <ul>
  <li>Ambiguous word boundaries</li>
  <li>Unknown words</li>
  </ul>
  <h3>Ambiguous word boundaries</h3>
  <p>Word boundaries found in identical character sequences can depend on the meaning, which is inaccessible to anyone (including a computer) who does not speak the language. A classic example in Thai is ตากลม, which can be ตา|กลม (round eyes) or ตาก|ลม (exposed to the air). You see a similar kind of ambiguity in the following English sentences:</p>
  <ul>
  <li>Those who <em>died are devils</em></li>
  <li>The <strong>do or </strong><em><strong>di</strong>e daredevils</em></li>
  <li>The <strong>door di</strong>d no<em>t o</em>pen</li>
  </ul>
  <p>If this were written with no spaces, a machine or non-English speaker would have no way of knowing where to place the word boundaries. There are multiple ways of dividing the letters to yield real English words.</p>
  <h3>Unknown words</h3>
  <p>A dictionary-based approach fails as soon as it encounters an unknown word. At best, it can skip over chunks that do not correspond to any entry in the dictionary, but this can be a costly and error-prone process. If it had no spaces, and the name "Houdini" was not in the dictionary, a sentence like ...</p>
  <blockquote>A noted wit, Houdini told many jokes.</blockquote>
  <p>... could be segmented as ...</p>
  <blockquote>a noted wit<strong>h <span class="red">ou</span> din it old</strong> many jokes</blockquote> 
  <p>... or ...</p>
  <blockquote>a noted <strong><span class="red">wi</span> thou din it old</strong> many jokes</blockquote> 
  <p>... with one unknown word leading to a longer garbled passage, and a misleading chunk being labelled "unknown".</p>

  <p class="aside note">This tutorial will not address either of these issues, which are still the subject of much research.</p>

  <div class="aside preview">In this tutorial, you will be learning to:
    <ul>
      <li>Create a trie from a dictionary</li>
      <li>Use the trie to detect word boundaries in EnglishNoSpaces</li>
      <li>Apply the trie technique to Thai text</li>
      <li>Use a "rule-based" system to identify syllable boundaries in Thai text</li>
      <li>Run an asynchronous method (to simulate an AJAX request to a server) to obtain the word segmentation of a chunk of text</li>
      <li>Use the callback result to select the word indicated by a click on a press on an arrow key.</li>
    </ul>
  </div>
  <p class="aside info">Note: the <code>selection.js</code> code used in this tutorial is describe in more detail <a href="../selection/">here</a>.</p>

  <footer>
    <ul class="nav">
      <li>
        <a href="#dictionary">
          <img src="../img/arrow.png" alt="next"/>
        </a>
      </li>
    </ul>
  </footer>
</section>
</article>
</main>

<script src="../js/core.js"></script>
</body>
</html>
