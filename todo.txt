
REINSTATE parseAsElements() as a separate function in 11:navigate, and rebuild ZIP

Click on X close icon jumps to #close section

Remind readers to rebuild the extension and reload it.

Save "Show annotations" status in background.js
Remember Active and Annotate status per site (per URL)

✓ Words within tags (<span> or <a>, or whatever) don't have spaces after the end of the original span in the annotated version. (Visible on http://lx/openbook/annotations/#connection)

Track changes to DOM in real time, and annotate the changes as they occur.

TEXT
- Image of completed extension, for section 1
- Link to install extension in section 1
- Create image showing interaction between various extension components, and add it to section 3 
- End of section 5: link to section which deals with the tab id of the popup window.
- Add reference to Neo4j in section 6?

JS
✓ Remember scrollTop when navigating away from a page; restore scrollTop when returning to that page.

CSS
<printing>
- Place "last" page at the beginning
- Number sections
- Avoid splitting images on page breaks
- Hide sidebar if page is too narrow
<encapsulation>
- Ensure CSS for Toolbar is independent on CSS for page

MISC
- Zoom scaled-down images to full size when clicked
- Find text in all sections
- Display as single page
- Restore display for active tab when switching tabs
- Add "Lock" button to prevent automatically updating on tab switch

TESTING
- Check that Tip disclosure triangles work correctly now in all major browsers
✓ Is inject.css added multiple times?
- What happens to the Toolbar and extensionIsActive when you navigate to a different page within the same tab?

POPUP WINDOW
- Menu
  - Open
  - Close
  - Show original | annotations
  - Register / Log in
  - Log out
  - Manage automatic activation
    - Specific languages
    - Specific pages
    - Specific pages to ignore
- Icon
  - Appearance depends on page language and activation state

——————————

The background script receives the browserAction event, as `useExtension`. It immediately calls `chrome.tabs.query()` to get the `id` of the active tab. By the time the `checkPageStatus` callback is called, it does not need to ask the tab itself if it is showing the extension Toolbar: it can decide for itself:
- if map[id] === true then do nothing (it's already active)
- if map[id] === false it was open: injectToolbar()
- if map[id] === undefined then injectCSS(), injectToolbar()

When a page is loaded, the content.js script is triggered. This can call getExtensionStatus() in background.js. This will look up map{}:
- if map[id] === true then injectCSS(), injectToolbar()
- if map[id] !== true, then set it to undefined, so that a browserAction click will injectCSS.

When using `chrome.runtime.sendMessage`, the `url` is sent both as a property of the `sender` object and of the `sender.tab` object. It can thus be passed through a filter to determine if the Toolbar should automatically be shown.
{ id: "uniquestringofsomeconsiderablelength"
, frameId: <integer>
, url: <string>
, tab: {
    active: <boolean>
  , audible: <boolean>
  , favIconUrl: <string>
  , height: <integer>
  , highlighted: <boolean>
  , id: <integer>
  , incognito: <boolean>
  , index: <integer>
  , mutedInfo: { ... }
  , pinned: <boolean>
  , selected: <boolean>
  , status: <"loading" | ... >
  , title: <string>
  , url: <same as ../url?>
  , width: <integer>
  , windowId: <integer>
  }
}

——————————

